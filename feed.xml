<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>布鲁斯鱼的妙想天开</title>
        <link>https://next.emergencyexit.xyz//</link>
        <description>此间的博文大抵有两类，一种是水的，另一种仍是水的罢。 —— 鲁迅</description>
        <lastBuildDate>Tue, 12 Sep 2023 03:02:15 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-CN</language>
        <copyright>All rights reserved 2023, bluesyu</copyright>
        <item>
            <title><![CDATA[SRE 冲浪记 - 2]]></title>
            <link>https://next.emergencyexit.xyz//sre-surfing-2</link>
            <guid>https://next.emergencyexit.xyz//sre-surfing-2</guid>
            <pubDate>Tue, 12 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[冲浪记]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-7af0f28c2ee340839df01790796cac80"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-e575ee3b7510450e992663ed9fff0399"><a href="#b092f785d877493c83f9e2adfc295dd5" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">观点</span></a><a href="#83bd19731edd42b6a57be44485c5e9c3" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">GIL or no GIL ?</span></a><a href="#ad2e0093ae5b4f9e8a7e2057553e9836" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Why did Python win?</span></a><a href="#42bd5b4254114e5994f565e178f71837" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">为什么 Python 没有尾递归优化？</span></a><a href="#562592c6569e494f906db9f1371f4577" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">旧文拾遗：如何做一个有质量的技术分享</span></a><a href="#5c6313becd134facbdf6819b0d6a1101" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">为什么 Rust 是开发者中最受推崇的语言</span></a><a href="#a2d6ba67a4b64fc2919a59e68414bca3" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">实践</span></a><a href="#89633e9f8eed41b0be8ec93741e567ae" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Go 的内存逃逸</span></a><a href="#4f68de85c05c41328e0b266efd71ce95" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Go 的 PGO 发布了</span></a><a href="#9417e1915f3d4effb2c9271b6389872e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">函数柯里化</span></a><a href="#7615fcca0ccb493e9c5588bccc1762b5" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">布谷鸟过滤器</span></a><a href="#15c9fded8645448a806aae78a196f452" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">pypi-timemachine</span></a><a href="#86ac37b253a34b0bbaf9b54da86e387d" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">小憩</span></a><a href="#4d86f5dbb826406788dd14f1ab601d66" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">meme 赏</span></a><a href="#0494280d19934e3488387f0aa34ec282" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">antigravity</span></a><a href="#2509b50ba6d54354983464fea092223b" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">全国地铁数据库</span></a><a href="#d429cd6927464f42a058e75c8cf2569c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Google 随机街景</span></a><a href="#a545ba54760d4cd8864dc758a6e26dc5" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Fin</span></a></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-6e7bdb46be504c6f907958628e3e6dd4"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Ff%2Fb0a64676-90b9-4734-9c63-2d704ee573b6%2Fcce28a0f-5f49-4397-aa48-f158ef340ba8%2FUntitled.png%3Fid%3D6e7bdb46-be50-4c6f-9079-58628e3e6dd4%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DZzL_-EhZxnkbcx59w36hU6eh6FfqD57OhEyulBp15YM?table=block&amp;id=6e7bdb46-be50-4c6f-9079-58628e3e6dd4&amp;cache=v2" loading="lazy" alt="夜晚的鹦鹉洲长江大桥" decoding="async"/><figcaption class="notion-asset-caption">夜晚的鹦鹉洲长江大桥</figcaption></div></figure><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-b092f785d877493c83f9e2adfc295dd5" data-id="b092f785d877493c83f9e2adfc295dd5"><span><div id="b092f785d877493c83f9e2adfc295dd5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b092f785d877493c83f9e2adfc295dd5" title="观点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">观点</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-83bd19731edd42b6a57be44485c5e9c3" data-id="83bd19731edd42b6a57be44485c5e9c3"><span><div id="83bd19731edd42b6a57be44485c5e9c3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#83bd19731edd42b6a57be44485c5e9c3" title="GIL or no GIL ?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">GIL or no GIL ?</span></span></h4><div class="notion-text notion-block-9cd1b144c2d44b238c73a7e73d58afe3">在损失 5-10% 单核情况下去掉 GIL，提升多核效率，这会是 Python 以后的发展方向吗？</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-89ac296da740425e85343f99a610cb35" href="https://peps.python.org/pep-0703/"><div><div class="notion-bookmark-title">PEP 703 – Making the Global Interpreter Lock Optional in CPython | peps.python.org</div><div class="notion-bookmark-description">Python Enhancement Proposals (PEPs)</div><div class="notion-bookmark-link"><img src="https://peps.python.org/_static/py.png" alt="PEP 703 – Making the Global Interpreter Lock Optional in CPython | peps.python.org" loading="lazy"/><div>https://peps.python.org/pep-0703/</div></div></div></a></div><div class="notion-text notion-block-035a811f4ccb42a6996708d31a4275ff">我们知道，提升多核的主要原因是需要释放更多的 CPU 计算能力，也就是在数据分析、AI 计算领域会有更大的用途，在传统的 Web 工程里，IO 出现瓶颈是更普遍的事，单核性能也许会更关键。</div><div class="notion-text notion-block-cd8674a6a0334c93bc5596b23a1b3182">随着 AI 等领域进一步发展，Python 在 Web 工程上的使用占比也许会进一步减少——根据 JetBrains 的调查统计，2022 年 Web 开发比 2021 年少了 6% 的占比 （<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.jetbrains.com/lp/devecosystem-2021/python/">2021</a> vs <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.jetbrains.com/lp/devecosystem-2022/python/">2022</a>），那么以后的 Python 是会拥抱大数据和 AI 领域，彻底走上去除 GIL 的道路，还是分裂成两个编译版本、两个社区呢？让我们拭目以待吧。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-ad2e0093ae5b4f9e8a7e2057553e9836" data-id="ad2e0093ae5b4f9e8a7e2057553e9836"><span><div id="ad2e0093ae5b4f9e8a7e2057553e9836" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ad2e0093ae5b4f9e8a7e2057553e9836" title="Why did Python win?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Why did Python win?</span></span></h4><div class="notion-text notion-block-8f1b8bb74ea84013be24571a7450ea10">一些人讨论为什么 Python 比 Ruby 在这些年市场增长更快。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-89221d80ee4545e2959ff86e7b4fb540" href="https://news.ycombinator.com/item?id=37308747"><div><div class="notion-bookmark-title">news.ycombinator.com</div><div class="notion-bookmark-link"><div>https://news.ycombinator.com/item?id=37308747</div></div></div></a></div><div class="notion-text notion-block-187fa909f9354738895220549d8cd25c">但 Python 真的赢了吗？在 Web 开发领域，现在依旧是不同领域有不同的专精语言和框架，远谈不上“赢”，而在 AI 领域，至少现在会有一些新兴的对手，比如 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.modular.com/mojo">Mojo</a>，一个不管会不会流行，但注定会“火”的面向 AI 编程语言。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-42bd5b4254114e5994f565e178f71837" data-id="42bd5b4254114e5994f565e178f71837"><span><div id="42bd5b4254114e5994f565e178f71837" class="notion-header-anchor"></div><a class="notion-hash-link" href="#42bd5b4254114e5994f565e178f71837" title="为什么 Python 没有尾递归优化？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">为什么 Python 没有尾递归优化？</span></span></h4><div class="notion-text notion-block-c9ae6490286641cc8f904bfdc8ff6aef">接上一期的尾递归优化内容，为什么 Python 里没有呢？核心原因是 Guido 并不认为递归是所有编程的基础。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-ea85850a1b4343cca67f946c7ac08def" href="https://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html"><div><div class="notion-bookmark-title">Tail Recursion Elimination</div><div class="notion-bookmark-description">I recently posted an entry in my Python History blog on the origins of Python&#x27;s functional features .  A side remark about not supporting ta...</div><div class="notion-bookmark-link"><img src="https://neopythonic.blogspot.com/favicon.ico" alt="Tail Recursion Elimination" loading="lazy"/><div>https://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html</div></div></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-562592c6569e494f906db9f1371f4577" data-id="562592c6569e494f906db9f1371f4577"><span><div id="562592c6569e494f906db9f1371f4577" class="notion-header-anchor"></div><a class="notion-hash-link" href="#562592c6569e494f906db9f1371f4577" title="旧文拾遗：如何做一个有质量的技术分享"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">旧文拾遗：<b>如何做一个有质量的技术分享</b></span></span></h4><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-f5922bff6f2d424d8ac1d37b6fa39856" href="https://coolshell.cn/articles/21589.html"><div><div class="notion-bookmark-title">如何做一个有质量的技术分享 | 酷 壳 - CoolShell</div><div class="notion-bookmark-description">分享信息并不难，大多数人都能做到，就算是不善言谈性格内向的技术人员，通过博客或社交媒体，或是不正式的交流，他们都能或多或少的做到。但是如果你想要做一个有质量有高度的分享，这个就难了，所谓的有质量和有高度，我心里面的定义有两点：1）分享内容的保鲜期是很长的，2）会被大范围的传递。我们团队内每周都在做技术分享，虽然分享的主题都很有价值，但是分享的质量参差不齐，所以，想写下这篇文章 。供大家参考。</div><div class="notion-bookmark-link"><img src="https://coolshell.cn/favicon.png" alt="如何做一个有质量的技术分享 | 酷 壳 - CoolShell" loading="lazy"/><div>https://coolshell.cn/articles/21589.html</div></div></div><div class="notion-bookmark-image"><img src="https://coolshell.cn/wp-content/uploads/2021/07/knowledge_sharing.jpeg" alt="如何做一个有质量的技术分享 | 酷 壳 - CoolShell" loading="lazy"/></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-5c6313becd134facbdf6819b0d6a1101" data-id="5c6313becd134facbdf6819b0d6a1101"><span><div id="5c6313becd134facbdf6819b0d6a1101" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5c6313becd134facbdf6819b0d6a1101" title="为什么 Rust 是开发者中最受推崇的语言"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">为什么 Rust 是开发者中最受推崇的语言</span></span></h4><div class="notion-text notion-block-f67385e607a74d04b5a86cb150450f64">不管你有没有开始写 Rust，但一定也被这股 “Rust 重写一切” 的风刮到过，为什么呢？Github 官方博客给出了他们的答案。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-d0ff38079d16410b9b6cb41f1081faea" href="https://github.blog/2023-08-30-why-rust-is-the-most-admired-language-among-developers/"><div><div class="notion-bookmark-title">Why Rust is the most admired language among developers</div><div class="notion-bookmark-description">Rust continues to top the charts as the most admired and desired language by developers, and in this post, we dive a little deeper into how (and why) Rust is stealing the hearts of developers around the world.</div><div class="notion-bookmark-link"><img src="https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192" alt="Why Rust is the most admired language among developers" loading="lazy"/><div>https://github.blog/2023-08-30-why-rust-is-the-most-admired-language-among-developers/</div></div></div><div class="notion-bookmark-image"><img src="https://github.blog/wp-content/uploads/2023/08/1200x630-AI-Unfurl-DARK-Inverto.png" alt="Why Rust is the most admired language among developers" loading="lazy"/></div></a></div><div class="notion-text notion-block-3d9f93c960c0402e96a99e4f0c7c258a">（不说了，明天就开始学写 Rust 🫠）</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-a2d6ba67a4b64fc2919a59e68414bca3" data-id="a2d6ba67a4b64fc2919a59e68414bca3"><span><div id="a2d6ba67a4b64fc2919a59e68414bca3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a2d6ba67a4b64fc2919a59e68414bca3" title="实践"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">实践</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-89633e9f8eed41b0be8ec93741e567ae" data-id="89633e9f8eed41b0be8ec93741e567ae"><span><div id="89633e9f8eed41b0be8ec93741e567ae" class="notion-header-anchor"></div><a class="notion-hash-link" href="#89633e9f8eed41b0be8ec93741e567ae" title="Go 的内存逃逸"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Go 的内存逃逸</span></span></h4><div class="notion-text notion-block-ca6ee9e5ce1c47bbbe0fa439c229d2c7">Go 的 GC 虽然有不少优化，但终究是 STW，减少逃逸代码是相对必要的。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-22b440aa57054165887ea4168dcaab2e" href="https://segmentfault.com/a/1190000040450335"><div><div class="notion-bookmark-title">详解Go语言中的内存逃逸</div><div class="notion-bookmark-description">哈喽，大家好，我是asong。最近无聊看了一下Go语言的面试八股文，发现面试官都喜欢问内存逃逸这个话题，这个激起了我的兴趣，我对内存逃逸的了解很浅，所以找...</div><div class="notion-bookmark-link"><img src="https://static.segmentfault.com/main_site_next/8359f490/favicon.ico" alt="详解Go语言中的内存逃逸" loading="lazy"/><div>https://segmentfault.com/a/1190000040450335</div></div></div><div class="notion-bookmark-image"><img src="https://segmentfault.com/img/bVcTS8U?spec=cover" alt="详解Go语言中的内存逃逸" loading="lazy"/></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-4f68de85c05c41328e0b266efd71ce95" data-id="4f68de85c05c41328e0b266efd71ce95"><span><div id="4f68de85c05c41328e0b266efd71ce95" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4f68de85c05c41328e0b266efd71ce95" title="Go 的 PGO 发布了"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Go 的 PGO 发布了</span></span></h4><div class="notion-text notion-block-b0f991908000439393f5a0f81b59c09b">可以想见，如果能够结合上 Continuous Profiling（可以看以前的一篇<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://emergencyexit.xyz/continuous-profiling">漫谈</a>了解更多），翔实的线上数据作为分析基底，加上 PGO 的优化，也许会让一些比较稳定的成熟服务得到较大的性能提升。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-10183fb3342e4f5d8712eb760c29ea94" href="https://go.dev/blog/pgo"><div><div class="notion-bookmark-title">Profile-guided optimization in Go 1.21 - The Go Programming Language</div><div class="notion-bookmark-description">Introduction to profile-guided optimization, generally available in Go 1.21.</div><div class="notion-bookmark-link"><img src="https://go.dev/images/favicon-gopher.png" alt="Profile-guided optimization in Go 1.21 - The Go Programming Language" loading="lazy"/><div>https://go.dev/blog/pgo</div></div></div><div class="notion-bookmark-image"><img src="https://go.dev/doc/gopher/gopher5logo.jpg" alt="Profile-guided optimization in Go 1.21 - The Go Programming Language" loading="lazy"/></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-9417e1915f3d4effb2c9271b6389872e" data-id="9417e1915f3d4effb2c9271b6389872e"><span><div id="9417e1915f3d4effb2c9271b6389872e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9417e1915f3d4effb2c9271b6389872e" title="函数柯里化"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">函数柯里化</span></span></h4><div class="notion-text notion-block-dba90d1bb1874478bd93e8bced0ba110">在 JS 非常实用，在 Python 中我们该如何实现它呢？</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-e3f0819514c847f18e4b56d253657416" href="https://www.askpython.com/python/examples/currying-in-python"><div><div class="notion-bookmark-title">Currying in Python - A Beginner&#x27;s Introduction - AskPython</div><div class="notion-bookmark-description">In this article, we will try to understand the concept &quot;Curry&quot;, its advantages, and its implementation in python. Currying is actually named in honor of the</div><div class="notion-bookmark-link"><img src="https://www.askpython.com/wp-content/uploads/2019/12/cropped-favicon-1-192x192.png" alt="Currying in Python - A Beginner&#x27;s Introduction - AskPython" loading="lazy"/><div>https://www.askpython.com/python/examples/currying-in-python</div></div></div><div class="notion-bookmark-image"><img src="https://www.askpython.com/wp-content/uploads/2022/07/curry-in-Python.png" alt="Currying in Python - A Beginner&#x27;s Introduction - AskPython" loading="lazy"/></div></a></div><div class="notion-text notion-block-9350eec42f2e4228a63ecafeda5fc9ee">虽然我还没想到它能在日常使用中提升什么可读性。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-7615fcca0ccb493e9c5588bccc1762b5" data-id="7615fcca0ccb493e9c5588bccc1762b5"><span><div id="7615fcca0ccb493e9c5588bccc1762b5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#7615fcca0ccb493e9c5588bccc1762b5" title="布谷鸟过滤器"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">布谷鸟过滤器</span></span></h4><div class="notion-text notion-block-e3454bb7785341bd9322413b9d0323fa">相较于更原始的布隆过滤器，有四个更优的点：</div><ul class="notion-list notion-list-disc notion-block-e2d2ea7d205549d3913312b73298dff9"><li>它支持动态添加和删除项；</li></ul><ul class="notion-list notion-list-disc notion-block-18a255f667c6421098bf3b20d6dbde4c"><li>它提供了比传统的布隆过滤器更高的查找性能，即使当其接近满载（例如，95%的空间已被使用）；</li></ul><ul class="notion-list notion-list-disc notion-block-001bd1296bc54b7c86681704e64c9ae4"><li>它比诸如商过滤器等替代品更容易实现；</li></ul><ul class="notion-list notion-list-disc notion-block-8dba73c5a58c4619b2987c293e44c55d"><li>在许多实际应用中，如果目标假阳性率 <code class="notion-inline-code">ε</code> 小于3%，则它使用的空间小于布隆过滤器；</li></ul><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-0f47d4412c8c4c1b96138a664ec4ef80" href="http://www.linvon.cn/posts/cuckoo/"><div><div class="notion-bookmark-title">布谷鸟过滤器：实际上优于布隆过滤器</div><div class="notion-bookmark-description">本文译自原论文:https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf 译注：下文将</div><div class="notion-bookmark-link"><img src="http://www.linvon.cn/apple-touch-icon.png" alt="布谷鸟过滤器：实际上优于布隆过滤器" loading="lazy"/><div>http://www.linvon.cn/posts/cuckoo/</div></div></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-15c9fded8645448a806aae78a196f452" data-id="15c9fded8645448a806aae78a196f452"><span><div id="15c9fded8645448a806aae78a196f452" class="notion-header-anchor"></div><a class="notion-hash-link" href="#15c9fded8645448a806aae78a196f452" title="pypi-timemachine"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/astrofrog/pypi-timemachine">pypi-timemachine</a></span></span></h4><div class="notion-text notion-block-eed66e8382094704a21c90e4d3264305">这个库有一点意思：能够模拟在你给定某个过去的时间点安装 pypi 依赖，对于很多没有 lock 文件的旧项目会有点用。不过都这年头了，<b>还在用原生 pip 维护管理依赖的项目真的应该升级到新工具了😂</b></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-446aeec7c72444a0bf4cd3ff5dd36582"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Ff%2Fb0a64676-90b9-4734-9c63-2d704ee573b6%2Fe33637f1-c879-4e3f-95ad-086ac5523552%2FUntitled.png%3Fid%3D446aeec7-c724-44a0-bf4c-d3ff5dd36582%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DMCWVFKoJ5bFi_WxOYc2GSgG5GYCq9QzHvzPb-cchOP8?table=block&amp;id=446aeec7-c724-44a0-bf4c-d3ff5dd36582&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-86ac37b253a34b0bbaf9b54da86e387d" data-id="86ac37b253a34b0bbaf9b54da86e387d"><span><div id="86ac37b253a34b0bbaf9b54da86e387d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#86ac37b253a34b0bbaf9b54da86e387d" title="小憩"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">小憩</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-4d86f5dbb826406788dd14f1ab601d66" data-id="4d86f5dbb826406788dd14f1ab601d66"><span><div id="4d86f5dbb826406788dd14f1ab601d66" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4d86f5dbb826406788dd14f1ab601d66" title="meme 赏"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">meme 赏</span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-27e9ba18588645c08e4e5321a1c10636"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:336px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F329e3a33-b06e-471f-adbe-6a250fe07c05%2FUntitled.png%3Fid%3D27e9ba18-5886-45c0-8e4e-5321a1c10636%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3Db6qV13eCJlor4Au5dpRSsbkskDGJmoirkYugNn_7rfQ?table=block&amp;id=27e9ba18-5886-45c0-8e4e-5321a1c10636&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-0494280d19934e3488387f0aa34ec282" data-id="0494280d19934e3488387f0aa34ec282"><span><div id="0494280d19934e3488387f0aa34ec282" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0494280d19934e3488387f0aa34ec282" title="antigravity"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">antigravity</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-72da3de5295b4f5ba340e8413d9305c2" href="https://xkcd.com/"><div><div class="notion-bookmark-title">Marshmallow</div><div class="notion-bookmark-link"><img src="https://xkcd.com/s/919f27.ico" alt="Marshmallow" loading="lazy"/><div>https://xkcd.com/</div></div></div><div class="notion-bookmark-image"><img src="https://imgs.xkcd.com/comics/marshmallow_2x.png" alt="Marshmallow" loading="lazy"/></div></a></div><div class="notion-text notion-block-c6a3c75e9650410eac05bcfd02b192a3">非常有名的网络漫画，在 Python <code class="notion-inline-code">import antigravity</code> 就能打开。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-2509b50ba6d54354983464fea092223b" data-id="2509b50ba6d54354983464fea092223b"><span><div id="2509b50ba6d54354983464fea092223b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2509b50ba6d54354983464fea092223b" title="全国地铁数据库"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">全国地铁数据库</span></span></h3><div class="notion-text notion-block-0ceddb89855b44cb8ce71fdf41ff64ba">有时可以从地铁数据一瞥城市的经济状态。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-abcffd87f5384f22a48b66d0e7102b83" href="https://metrodb.org/"><div><div class="notion-bookmark-title">地铁数据库 | 地铁客流量查询</div><div class="notion-bookmark-description">地铁数据库:提供中国地铁客流量查询,北京地铁客流查询,上海地铁客流查询,广州地铁客流查询,深圳地铁客流查询,成都地铁客流查询,南京地铁客流查询,武汉地铁客流查询,重庆地铁客流查询,西安地铁客流查询,长沙地铁客流查询...</div><div class="notion-bookmark-link"><img src="https://metrodb.org/favicon.ico" alt="地铁数据库 | 地铁客流量查询" loading="lazy"/><div>https://metrodb.org/</div></div></div></a></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-d429cd6927464f42a058e75c8cf2569c" data-id="d429cd6927464f42a058e75c8cf2569c"><span><div id="d429cd6927464f42a058e75c8cf2569c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d429cd6927464f42a058e75c8cf2569c" title="Google 随机街景"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Google 随机街景</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-e389ad1beebe4908871b6ca9bbd5add9" href="https://neal.fun/wonders-of-street-view/"><div><div class="notion-bookmark-title">Wonders of Street View</div><div class="notion-bookmark-description">Explore the weird and wonderful things on Google Street View</div><div class="notion-bookmark-link"><img src="https://neal.fun/favicons/wonders-of-street-view.png" alt="Wonders of Street View" loading="lazy"/><div>https://neal.fun/wonders-of-street-view/</div></div></div><div class="notion-bookmark-image"><img src="https://neal.fun/share-cards/wonders-of-street-view.png" alt="Wonders of Street View" loading="lazy"/></div></a></div><div class="notion-text notion-block-6e046b61e239476fb16733135f1d05e1">该网站收集了非常多奇怪且有趣的 Google 街景。比如我找到一个<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://neal.fun/wonders-of-street-view/?v=Cbkobw">波兰的盐矿教堂</a>，看起来立马让我想起了盐与避难所这款游戏。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-a545ba54760d4cd8864dc758a6e26dc5" data-id="a545ba54760d4cd8864dc758a6e26dc5"><span><div id="a545ba54760d4cd8864dc758a6e26dc5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a545ba54760d4cd8864dc758a6e26dc5" title="Fin"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Fin</span></span></h2><div class="notion-text notion-block-4971c39ce026403682e4921c8f5adb0f">等等，这个还有第二期？没想到吧，在胡乱编完了第一期后，又抠抠索索搞了第二期。</div><div class="notion-text notion-block-9b049f458f624e6cb42b3f196952e2f3">以下是一些自问自答。</div><div class="notion-blank notion-block-26ea3bd52ae141998b5ce6d59775cb89"> </div><div class="notion-text notion-block-11580e4f35d14006820bbdb2e458e728">Q：你这个发布有什么时间周期吗？</div><div class="notion-text notion-block-5fb0831467ce4470b3e2a4f6040558f9">A：没有，我觉得内容攒的差不多了就发一期，也许半个月也许一个月，取决于我日常工作是否繁忙。好吧，实际也没人关心这个。</div><hr class="notion-hr notion-block-da02cfdfe26d434e99317af4de6aac58"/><div class="notion-text notion-block-3b68d23e6e1146dd9c9fe98206fbbcdf">Q：为什么内容我好像在哪里看过？</div><div class="notion-text notion-block-144e8bfdfd1a410d93da234dde346423">A：没错，我就是四处摘抄。网络上有不少很成熟的个人周刊、RSS，我这个就是从这些高手的信息流中淘漉而来。<s>做一个重口味的比喻，信息流的人体蜈蚣，我这个肯定是在很后面的一个。</s></div><hr class="notion-hr notion-block-64788ec3d5e94d539981b422767fc70b"/><div class="notion-text notion-block-27eebc3c4ff0482886a778a5d4d57e91">Q：内容有主题吗？</div><div class="notion-text notion-block-408586866ee84f148c0875468520d441">A：没有，凡是我觉得有点子意思的内容（除了 NSFW），我就会摘抄过来。一定程度上，这些信息就是我个人的兴趣点展览。如果你也喜欢这里面的内容，欢迎评论交流，我们很可能可以聊得来；如果你不喜欢，也请轻喷或者直接关掉页面，不好意思浪费你时间了。</div><div class="notion-blank notion-block-47cd02aceadf4e74a7444f0e54aa8180"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SRE 冲浪记 - 1]]></title>
            <link>https://next.emergencyexit.xyz//sre-surfing-1</link>
            <guid>https://next.emergencyexit.xyz//sre-surfing-1</guid>
            <pubDate>Mon, 24 Jul 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[冲浪记]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-75cd1dc0c250437fbb8762fda63ed092"><div class="notion-viewport"></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-3c0b8ecce0384f67a2cd33156329c96c"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Ff%2Fb0a64676-90b9-4734-9c63-2d704ee573b6%2Ffa626624-030d-447f-a2d7-24fa139ff3ae%2FIMG_20230805_193254.heic%3Fid%3D3c0b8ecc-e038-4f67-a2cd-33156329c96c%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DU_VyWSky1Lx4fYsJl_a-z-Uo75ZLgkFM9sjHhIV2jOc?table=block&amp;id=3c0b8ecc-e038-4f67-a2cd-33156329c96c&amp;cache=v2" loading="lazy" alt="循礼门夜市，狭长走道，深蓝色天空" decoding="async"/><figcaption class="notion-asset-caption">循礼门夜市，狭长走道，深蓝色天空</figcaption></div></figure><div class="notion-table-of-contents notion-gray notion-block-3cf6b913347c48ca8dd6f0d62890f14c"><a href="#2a2d9605935c49f187f12a1e2afcd314" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">观点</span></a><a href="#a986c6241e7641978a66d2360db33e8e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Go for range 的坑</span></a><a href="#4dd7d8e6e1d146b988aecf38f6cb9fe5" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Discord 为什么用 Rust 代替 Go</span></a><a href="#677288502eee4130a6325adb6795bec7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">延展阅读：像 Rust 一样写 Python</span></a><a href="#eafe32df3a4a423086b0ec8435875b16" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Python vs Rust: 异步网络框架性能对比</span></a><a href="#220a28e265cc4b7bba67e08efda1b339" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Threads 还是用的 Python + Django</span></a><a href="#4e3d7392e2dc4fc2894ea02de75b84ae" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">延展阅读：Instagram 如何将 Python2 升级到 3</span></a><a href="#abb8a931d4f34992b79cbf52fe691549" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">延展思考：我们应该改用 Cinder 吗? No.</span></a><a href="#cd826dc360a3423584fcfe53cf0e08b7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">为什么我讨厌 Asyncio ?</span></a><a href="#5160cf3f49df43e289890b47fbb6f576" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">有人在上云，有人在下云</span></a><a href="#d6b528bc23f04278bb3dd109bb46421f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">实践</span></a><a href="#b0459a7f9c0540a3bbf55d69ec855c5f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">如何组织超级大的 Python 单体应用</span></a><a href="#fb011a833d5b44b38b0f80a36ca1790b" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">延伸关注：Import Linter</span></a><a href="#634de4c83c094bd18c5e01b46d412947" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">使用随即排序的 QuerySet 来减少测试的不稳定性</span></a><a href="#1705888a1bdb4047a1d87f904386d56f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">在 Python 中增加尾调用优化</span></a><a href="#e5474435dd544c3dbc1d21778df652b0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">技术文章和技术分享的一些经验</span></a><a href="#c036259e92e7418eb003d6035c8da4f7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">小憩</span></a><a href="#567472c50da547959da85acaf20258dc" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Go proposal: 使用 .ʕ◔ϖ◔ʔ 作为 Go 文件的后缀名</span></a><a href="#1d16f292a26e4e818ddd13c3c3ed31d7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">行为艺术：此地无银三百两</span></a><a href="#a3f93ae553e84cf2941addb26da0f889" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">K8SGPT - 用简单的英语扫描 Kubernetes 集群、诊断和分类问题的工具</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-2a2d9605935c49f187f12a1e2afcd314" data-id="2a2d9605935c49f187f12a1e2afcd314"><span><div id="2a2d9605935c49f187f12a1e2afcd314" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2a2d9605935c49f187f12a1e2afcd314" title="观点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">观点</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-a986c6241e7641978a66d2360db33e8e" data-id="a986c6241e7641978a66d2360db33e8e"><span><div id="a986c6241e7641978a66d2360db33e8e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a986c6241e7641978a66d2360db33e8e" title="Go for range 的坑"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Go <code class="notion-inline-code">for range</code> 的坑</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-9256ff8ccea4480ba327c2aa6d523b58" href="https://zhuanlan.zhihu.com/p/641611712"><div><div class="notion-bookmark-title">Go 团队将修改 for 循环变量的语义，Go1.21 新版本即可体验！</div><div class="notion-bookmark-description">大家好，我是煎鱼。 之前有提到 Go for 循环变量的问题，许多面试题和泄露与此有关。 Russ Cox（下称：rsc）甚至一度表示他一直在研究这个问题，认为当前语义的代价是很大的，想看看能不能进行变更。 经过 Go1 向…</div><div class="notion-bookmark-link"><img src="https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png" alt="Go 团队将修改 for 循环变量的语义，Go1.21 新版本即可体验！" loading="lazy"/><div>https://zhuanlan.zhihu.com/p/641611712</div></div></div></a></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-4dd7d8e6e1d146b988aecf38f6cb9fe5" data-id="4dd7d8e6e1d146b988aecf38f6cb9fe5"><span><div id="4dd7d8e6e1d146b988aecf38f6cb9fe5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4dd7d8e6e1d146b988aecf38f6cb9fe5" title="Discord 为什么用 Rust 代替 Go"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Discord 为什么用 Rust 代替 Go</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-1f42083526254e909aa75a849164f330" href="https://medium.com/discord-engineering/why-discord-is-switching-from-go-to-rust-a190bbca2b1f"><div><div class="notion-bookmark-title">Why Discord is switching from Go to Rust</div><div class="notion-bookmark-description">Rust is becoming a first class language in a variety of domains. At Discord, we’ve seen success with Rust on the client side and server…</div><div class="notion-bookmark-link"><img src="https://miro.medium.com/v2/resize:fill:152:152/1*sHhtYhaCe2Uc3IU0IgKwIQ.png" alt="Why Discord is switching from Go to Rust" loading="lazy"/><div>https://medium.com/discord-engineering/why-discord-is-switching-from-go-to-rust-a190bbca2b1f</div></div></div><div class="notion-bookmark-image"><img src="https://miro.medium.com/v2/resize:fit:1200/1*BYeVEgTVQia4MD5LSLoUlA.png" alt="Why Discord is switching from Go to Rust" loading="lazy"/></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-677288502eee4130a6325adb6795bec7" data-id="677288502eee4130a6325adb6795bec7"><span><div id="677288502eee4130a6325adb6795bec7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#677288502eee4130a6325adb6795bec7" title="延展阅读：像 Rust 一样写 Python"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">延展阅读：像 Rust 一样写 Python</span></span></h4><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-974e9288a6c246179d5ef161fe501f9a" href="https://kobzol.github.io/rust/python/2023/05/20/writing-python-like-its-rust.html"><div><div class="notion-bookmark-title">Writing Python like it’s Rust</div><div class="notion-bookmark-description">I started programming in Rust several years ago, and it has gradually changed the way I design programs in other programming languages, most notably in Python. Before I started using Rust, I was usually writing Python code in a very dynamic and type-loose way, without type hints, passing and returning dictionaries everywhere, and occasionally falling back to “stringly-typed” interfaces. However, after experiencing the strictness of the Rust type system, and noticing all the problems that it prevents “by construction”, I suddenly became quite anxious whenever I got back to Python and wasn’t provided with the same guarantees.</div><div class="notion-bookmark-link"><img src="https://kobzol.github.io/favicon.ico" alt="Writing Python like it’s Rust" loading="lazy"/><div>https://kobzol.github.io/rust/python/2023/05/20/writing-python-like-its-rust.html</div></div></div></a></div><div class="notion-text notion-block-071166ac24024200aefee3a76fdde80c">作者从 Rust 编写习惯出发，重新审视了 Python 的“静态”写法。我作为不写 Rust 老 Pythonista，文章里面绝大多数的提议已经是习以为常了，但重新从 Rust 视角过一遍还是很有意思的。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-eafe32df3a4a423086b0ec8435875b16" data-id="eafe32df3a4a423086b0ec8435875b16"><span><div id="eafe32df3a4a423086b0ec8435875b16" class="notion-header-anchor"></div><a class="notion-hash-link" href="#eafe32df3a4a423086b0ec8435875b16" title="Python vs Rust: 异步网络框架性能对比"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Python vs Rust: 异步网络框架性能对比</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-ad077a6b85c74b2c842956a77a442301" href="https://codesolid.com/benchmarking-python-and-rust-async-web-server-performance/"><div><div class="notion-bookmark-title">Benchmarking Python and Rust Async Web Server Performance</div><div class="notion-bookmark-description">Benchmarks showing how Python&#x27;s Blacksheep and Uvicorn stack up to a Rust solution using Axum and Tokio.</div><div class="notion-bookmark-link"><img src="https://codesolid.com/wp-content/uploads/2022/12/cropped-CodeSolidFavicon-192x192.png" alt="Benchmarking Python and Rust Async Web Server Performance" loading="lazy"/><div>https://codesolid.com/benchmarking-python-and-rust-async-web-server-performance/</div></div></div><div class="notion-bookmark-image"><img src="https://codesolid.com/wp-content/uploads/2023/04/PythonRust.png" alt="Benchmarking Python and Rust Async Web Server Performance" loading="lazy"/></div></a></div><div class="notion-text notion-block-cd88b65f2db54897aa9bef388fc141e8">文章里对比的异步框架有限，但是也提供了一个视角，仅在异步场景下，Python 和 Rust 的差距没有那么大。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-220a28e265cc4b7bba67e08efda1b339" data-id="220a28e265cc4b7bba67e08efda1b339"><span><div id="220a28e265cc4b7bba67e08efda1b339" class="notion-header-anchor"></div><a class="notion-hash-link" href="#220a28e265cc4b7bba67e08efda1b339" title="Threads 还是用的 Python + Django"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Threads 还是用的 Python + Django</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-476c4319e13b4187b4330af50c3a1049" href="https://mp.weixin.qq.com/s/Rxy_nWzivLZyT7TjXiy_BQ"><div><div class="notion-bookmark-title">Twitter劲敌Threads注册量已破三千万，后端基于CPython深度“魔改”</div><div class="notion-bookmark-description">Python YYDS！</div><div class="notion-bookmark-link"><img src="https://res.wx.qq.com/a/wx_fed/assets/res/MjliNWVm.svg" alt="Twitter劲敌Threads注册量已破三千万，后端基于CPython深度“魔改”" loading="lazy"/><div>https://mp.weixin.qq.com/s/Rxy_nWzivLZyT7TjXiy_BQ</div></div></div><div class="notion-bookmark-image"><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/dkwuWwLoRKibTWw3pCHLgtOeFDAicIKvyKc2iaiaIzJ5zdSUIm0IrTyJWcm0bI5Q88b2IXORra408iaa8tBmDRSCB4g/0?wx_fmt=jpeg" alt="Twitter劲敌Threads注册量已破三千万，后端基于CPython深度“魔改”" loading="lazy"/></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-4e3d7392e2dc4fc2894ea02de75b84ae" data-id="4e3d7392e2dc4fc2894ea02de75b84ae"><span><div id="4e3d7392e2dc4fc2894ea02de75b84ae" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4e3d7392e2dc4fc2894ea02de75b84ae" title="延展阅读：Instagram 如何将 Python2 升级到 3"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">延展阅读：Instagram 如何将 Python2 升级到 3</span></span></h4><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-a37e1e4da0574cd5b2feed9bddf01084" href="https://www.piglei.com/articles/instagram-pycon-2017/"><div><div class="notion-bookmark-title">Instagram 在 PyCon 2017 的演讲摘要  | Piglei</div><div class="notion-bookmark-description">piglei 的 blog</div><div class="notion-bookmark-link"><div>https://www.piglei.com/articles/instagram-pycon-2017/</div></div></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-abb8a931d4f34992b79cbf52fe691549" data-id="abb8a931d4f34992b79cbf52fe691549"><span><div id="abb8a931d4f34992b79cbf52fe691549" class="notion-header-anchor"></div><a class="notion-hash-link" href="#abb8a931d4f34992b79cbf52fe691549" title="延展思考：我们应该改用 Cinder 吗? No."><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">延展思考：我们应该改用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/facebookincubator/cinder">Cinder</a> 吗? No.</span></span></h4><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-cd826dc360a3423584fcfe53cf0e08b7" data-id="cd826dc360a3423584fcfe53cf0e08b7"><span><div id="cd826dc360a3423584fcfe53cf0e08b7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#cd826dc360a3423584fcfe53cf0e08b7" title="为什么我讨厌 Asyncio ?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">为什么我讨厌 Asyncio ?</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-ecc897d2d52141fe961ed989bef2f210" href="https://charlesleifer.com/blog/asyncio/"><div><div class="notion-bookmark-title">charles leifer | AsyncIO</div><div class="notion-bookmark-link"><img src="https://charlesleifer.com/favicon.ico" alt="charles leifer | AsyncIO" loading="lazy"/><div>https://charlesleifer.com/blog/asyncio/</div></div></div></a></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-5160cf3f49df43e289890b47fbb6f576" data-id="5160cf3f49df43e289890b47fbb6f576"><span><div id="5160cf3f49df43e289890b47fbb6f576" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5160cf3f49df43e289890b47fbb6f576" title="有人在上云，有人在下云"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">有人在上云，有人在下云</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-bc853e46860b4d9ea4d2da6d9b77714a" href="https://world.hey.com/dhh/we-have-left-the-cloud-251760fb"><div><div class="notion-bookmark-title">We have left the cloud</div><div class="notion-bookmark-description">Since it took us years to get into the cloud in the first place, I originally imagined it would take us years to get out as well. But all that work to containerize our applications and prepare them for the cloud actually turned out to make it relatively easy to exit. And now, after six months of effort, it&#x27;s done. We&#x27;re out. The last a...</div><div class="notion-bookmark-link"><img src="https://world.hey.com/dhh/avatar-df6405b0f7fafda980fd38b04c334bec936aef69" alt="We have left the cloud" loading="lazy"/><div>https://world.hey.com/dhh/we-have-left-the-cloud-251760fb</div></div></div><div class="notion-bookmark-image"><img src="https://world.hey.com/dhh/avatar-df6405b0f7fafda980fd38b04c334bec936aef69" alt="We have left the cloud" loading="lazy"/></div></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-d6b528bc23f04278bb3dd109bb46421f" data-id="d6b528bc23f04278bb3dd109bb46421f"><span><div id="d6b528bc23f04278bb3dd109bb46421f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d6b528bc23f04278bb3dd109bb46421f" title="实践"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">实践</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-b0459a7f9c0540a3bbf55d69ec855c5f" data-id="b0459a7f9c0540a3bbf55d69ec855c5f"><span><div id="b0459a7f9c0540a3bbf55d69ec855c5f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b0459a7f9c0540a3bbf55d69ec855c5f" title="如何组织超级大的 Python 单体应用"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">如何组织超级大的 Python 单体应用</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-5d50492abb614fd7bb21c0eda76c0935" href="https://blog.europython.eu/kraken-technologies-how-we-organize-our-very-large-pythonmonolith/"><div><div class="notion-bookmark-title">Kraken Technologies: How we organise our very large Python monolith</div><div class="notion-bookmark-description">By David Seddon from Kraken Technologies. Hi, I’m David, a Python developer at Kraken Technologies. I work on Kraken: a Python application which has, at last count, 27,637 modules. Yes, you read that right: nearly 28k separate Python files - not including tests. I do this along with</div><div class="notion-bookmark-link"><img src="https://blog.europython.eu/favicon.png" alt="Kraken Technologies: How we organise our very large Python monolith" loading="lazy"/><div>https://blog.europython.eu/kraken-technologies-how-we-organize-our-very-large-pythonmonolith/</div></div></div><div class="notion-bookmark-image"><img src="https://blog.europython.eu/content/images/2023/04/Duplicate_Hack_ep2023-social-card-for-website_banner_1686-x-888-2.png" alt="Kraken Technologies: How we organise our very large Python monolith" loading="lazy"/></div></a></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-fb011a833d5b44b38b0f80a36ca1790b" data-id="fb011a833d5b44b38b0f80a36ca1790b"><span><div id="fb011a833d5b44b38b0f80a36ca1790b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#fb011a833d5b44b38b0f80a36ca1790b" title="延伸关注：Import Linter"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">延伸关注：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/seddonym/import-linter">Import Linter</a></span></span></h4><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-634de4c83c094bd18c5e01b46d412947" data-id="634de4c83c094bd18c5e01b46d412947"><span><div id="634de4c83c094bd18c5e01b46d412947" class="notion-header-anchor"></div><a class="notion-hash-link" href="#634de4c83c094bd18c5e01b46d412947" title="使用随即排序的 QuerySet 来减少测试的不稳定性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">使用随即排序的 QuerySet 来减少测试的不稳定性</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-bd5c5ea616b943c294efbc0c8fbddb72" href="https://adamj.eu/tech/2023/07/04/django-test-random-order-querysets/"><div><div class="notion-bookmark-title">Django: Flush out test flakiness by randomly ordering QuerySets - Adam Johnson</div><div class="notion-bookmark-description">Sometimes code depends on the order of a QuerySet whilst not specifying an order. This can lead to random, flaky test failures because databases can return rows in any order when none is specified. The problem is made worse by some databases, notably PostgreSQL, which nearly always return rows in insert order, but occasionally use a different order when a table has had recent deletions.</div><div class="notion-bookmark-link"><img src="https://adamj.eu/favicon.ico" alt="Django: Flush out test flakiness by randomly ordering QuerySets - Adam Johnson" loading="lazy"/><div>https://adamj.eu/tech/2023/07/04/django-test-random-order-querysets/</div></div></div><div class="notion-bookmark-image"><img src="https://adamj.eu/tech/assets/2023-07-02-shuffles.jpeg" alt="Django: Flush out test flakiness by randomly ordering QuerySets - Adam Johnson" loading="lazy"/></div></a></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-1705888a1bdb4047a1d87f904386d56f" data-id="1705888a1bdb4047a1d87f904386d56f"><span><div id="1705888a1bdb4047a1d87f904386d56f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1705888a1bdb4047a1d87f904386d56f" title="在 Python 中增加尾调用优化"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">在 Python 中增加尾调用优化</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-0fe5dc80d45241c287f7a94fdc97eeff" href="https://blog.jonas.foo/posts/python-tail-call-optimization/"><div><div class="notion-bookmark-title">Adding tail call optimization to Python</div><div class="notion-bookmark-description">Tail call optimization is a great feature. It’s obviously easier to solve recursive problems recursively rather than iteratively. It’s a shame it’s not available in Python (or many other languages), so let’s add it. TL;DR The following function will result in RecursionError when its argument &gt;= 1000 def my_fn(target_iters, iteration=0): if iteration &gt;= target_iters: return iteration return my_fn(target_iters, iteration+1)  &gt;&gt;&gt; my_fn(1000) ... RecursionError: maximum recursion depth exceeded in comparison  With some extra code, we can add tail call optimization</div><div class="notion-bookmark-link"><img src="https://blog.jonas.foo/images/favicon.ico" alt="Adding tail call optimization to Python" loading="lazy"/><div>https://blog.jonas.foo/posts/python-tail-call-optimization/</div></div></div></a></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e5474435dd544c3dbc1d21778df652b0" data-id="e5474435dd544c3dbc1d21778df652b0"><span><div id="e5474435dd544c3dbc1d21778df652b0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e5474435dd544c3dbc1d21778df652b0" title="技术文章和技术分享的一些经验"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">技术文章和技术分享的一些经验</span></span></h3><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-bfce36b338004b32976018c26f18db4b" href="https://coolshell.cn/articles/21589.html"><div><div class="notion-bookmark-title">如何做一个有质量的技术分享 | 酷 壳 - CoolShell</div><div class="notion-bookmark-link"><img src="https://coolshell.cn/favicon.png" alt="如何做一个有质量的技术分享 | 酷 壳 - CoolShell" loading="lazy"/><div>https://coolshell.cn/articles/21589.html</div></div></div><div class="notion-bookmark-image"><img src="https://coolshell.cn/wp-content/uploads/2021/07/knowledge_sharing.jpeg" alt="如何做一个有质量的技术分享 | 酷 壳 - CoolShell" loading="lazy"/></div></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-c036259e92e7418eb003d6035c8da4f7" data-id="c036259e92e7418eb003d6035c8da4f7"><span><div id="c036259e92e7418eb003d6035c8da4f7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c036259e92e7418eb003d6035c8da4f7" title="小憩"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">小憩</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-567472c50da547959da85acaf20258dc" data-id="567472c50da547959da85acaf20258dc"><span><div id="567472c50da547959da85acaf20258dc" class="notion-header-anchor"></div><a class="notion-hash-link" href="#567472c50da547959da85acaf20258dc" title="Go proposal: 使用 .ʕ◔ϖ◔ʔ 作为 Go 文件的后缀名"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Go proposal: <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/golang/go/issues/59968">使用 </a><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/golang/go/issues/59968"><code class="notion-inline-code"><b>.ʕ◔ϖ◔ʔ</b></code></a><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/golang/go/issues/59968"><b> 作为 Go 文件的后缀名</b></a></span></span></h3><div class="notion-text notion-block-330ae9a95111427495394e21a2264adb">受到 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.modular.com/mojo">Mojo</a> 语言以 <code class="notion-inline-code">.🔥</code> 作为后缀名的启发，有人提议 Go 也不要落后，可以用 <code class="notion-inline-code">.ʕ◔ϖ◔ʔ</code> 替代 <code class="notion-inline-code">.go</code> 。  虽然是一个以搞笑为主旨的提议，但也让人脑洞打开，如果以 Unicode Emoji 作为文件扩展名，到底会有哪些意想不到的影响，比如 Windows 是否支持？要不要把命令行的 <code class="notion-inline-code">go run</code> 也改成 <code class="notion-inline-code">.ʕ◔ϖ◔ʔ run</code> ？当然，也有网友选择直接“报警”：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-71d398934ae9421187db3760339319b4"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:336px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fbc9411e3-ed64-4e2a-a729-1c2ead24a1cf%2FUntitled.png%3Fid%3D71d39893-4ae9-4211-87db-3760339319b4%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DRQkeg4QgQNXu02VjY_SyVaaVf9p-yE7se2FAzToBxmM?table=block&amp;id=71d39893-4ae9-4211-87db-3760339319b4&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-1d16f292a26e4e818ddd13c3c3ed31d7" data-id="1d16f292a26e4e818ddd13c3c3ed31d7"><span><div id="1d16f292a26e4e818ddd13c3c3ed31d7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1d16f292a26e4e818ddd13c3c3ed31d7" title="行为艺术：此地无银三百两"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">行为艺术：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/danielmiessler/SecLists/pull/155">此地无银三百两</a></span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ca9f9d4f3d314315bceaf03cbc7ba04f"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F5cf15af7-f317-4330-a34b-5fb4aa883653%2FUntitled.png%3Fid%3Dca9f9d4f-3d31-4315-bcea-f03cbc7ba04f%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DTStTqWjLe6tGsVOxEw02mPzjfZ3pogoQGMeJw6AR2xE?table=block&amp;id=ca9f9d4f-3d31-4315-bcea-f03cbc7ba04f&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-a3f93ae553e84cf2941addb26da0f889" data-id="a3f93ae553e84cf2941addb26da0f889"><span><div id="a3f93ae553e84cf2941addb26da0f889" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a3f93ae553e84cf2941addb26da0f889" title="K8SGPT - 用简单的英语扫描 Kubernetes 集群、诊断和分类问题的工具"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/k8sgpt-ai/k8sgpt">K8SGPT</a> - 用简单的英语扫描 Kubernetes 集群、诊断和分类问题的工具</span></span></h3><div class="notion-text notion-block-3d9a3972cab94caaac2b85ad846cdd6c">没错，GPT 开始进入 SRE 领域了。</div><div class="notion-blank notion-block-162a2a6547e44268925073b9bfefc76e"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Continuous Profiling 持续分析漫谈]]></title>
            <link>https://next.emergencyexit.xyz//continuous-profiling</link>
            <guid>https://next.emergencyexit.xyz//continuous-profiling</guid>
            <pubDate>Wed, 12 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[漫谈就是什么都谈，又好像什么都没谈]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-9faa9c16825a40c0898f7b9f31c30722"><div class="notion-viewport"></div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-8a63738bbb034053aecc722d21296f4e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fba3bcfdb-70e8-4f32-a43c-e73e766b6d71%2Fpersona5.jpeg%3Fid%3D8a63738b-bb03-4053-aecc-722d21296f4e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DbMnORElLoB_fSdVRTUmWDtOA3WS9T-tK8qXER6E2LwE?table=block&amp;id=8a63738b-bb03-4053-aecc-722d21296f4e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-table-of-contents notion-gray notion-block-5baa35ba29014df78acc535c25618622"><a href="#c2124fee14f7434e8ff07011493e806b" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">What ?</span></a><a href="#face42b936b945b49f132f1b07d05168" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Profiling vs Continuous Profiling</span></a><a href="#206bb88933be49679f368558bcc606e7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">来龙</span></a><a href="#ed9e1ca699764d0eb6deedd2e8828630" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">去脉</span></a><a href="#ff8aa8cb27304cf9b83c7ba73db89db4" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Why ?</span></a><a href="#75952cf6b2114d39b3854bae190044c4" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">开源方案</span></a><a href="#3314794fb53c45d5a3a2c663c6c31feb" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Pyroscope</span></a><a href="#2d043ca42a0a4a579def0858bbd3bd05" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">语言支持</span></a><a href="#08786eb20478421a81fb47dd7bf5b366" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">存储优化</span></a><a href="#37e40bbda9a749daa1a67892cc97d832" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">总结</span></a><a href="#076bbf9997b94a71ab23682052568fc4" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Parca</span></a><a href="#88491eadc7ff407a9a64160c71a85044" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">eBPF Agent</span></a><a href="#a60e62ba31514a2d899cfa999592dc00" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">Meta Sample 分离存储</span></a><a href="#4c1de643193b4a2fbd6f04e44ebf9978" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">总结</span></a><a href="#f2770103f80e4810bf88b50be6f34f55" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Phlare</span></a><a href="#bd78b2d100614fbf9dc9dd151a176579" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">水平扩展</span></a><a href="#6418d4f2c11e4b0d9c50138a28b47cc0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">分级存储</span></a><a href="#8e4d8ade7820401ebdcf474902336cc0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">总结</span></a><a href="#617226dac0924b34adb5c589ea30c6d9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Pixie</span></a><a href="#e00ee34fb0844b0d989297233c5e626e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">商业软件</span></a><a href="#6de913a222044b2496063feb21c4ff9e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Datadog Continuous Profiler</span></a><a href="#05c52ae909e04cf1899de9f07940e7f1" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">可以细粒度控制 function 展示内容</span></a><a href="#23f4922cd3cd4a3c97f5f3c0def5c118" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">Only My Code 可以聚焦于用户代码</span></a><a href="#6be2086592f947ad9a39f664cbd00cba" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">对比图表直观清晰</span></a><a href="#8b8b5ae4a8bd483092fd8bd09622f708" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">常用的数据聚合快捷入口</span></a><a href="#f427825cc82d402a951d6bbc75022f29" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">Elastic Profiler?</span></a><a href="#8bb6b79be1494abd95fc05375e139b88" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">方案选型对抗赛</span></a><a href="#729375fb46d2432a971f3de708f5fa8c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">推 vs 拉</span></a><a href="#492b9ded6ab74c859f1b670c85082431" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">存算分离 vs 存算一体</span></a><a href="#3b4160403f964f46818d70117d0dd1ec" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">块存储 vs 对象存储</span></a><a href="#61ca23ded6ce4926892710f5dc7049d9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">eBPF vs Native Language Tools</span></a><a href="#f9474cb377364a1faa740d5276deb613" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">pprof vs OT</span></a><a href="#e6f5bc4ccbe141c492231597ed30f5d1" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-c2124fee14f7434e8ff07011493e806b" data-id="c2124fee14f7434e8ff07011493e806b"><span><div id="c2124fee14f7434e8ff07011493e806b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#c2124fee14f7434e8ff07011493e806b" title="What ?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">What ?</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-face42b936b945b49f132f1b07d05168" data-id="face42b936b945b49f132f1b07d05168"><span><div id="face42b936b945b49f132f1b07d05168" class="notion-header-anchor"></div><a class="notion-hash-link" href="#face42b936b945b49f132f1b07d05168" title="Profiling vs Continuous Profiling"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Profiling vs Continuous Profiling</span></span></h3><div class="notion-text notion-block-3cd4891367c4492b84d0108e79327646">相信各位开发老司机都给自己的程序“号过脉”，所以对于 Profiling 一定不陌生，在这里我还是搬一下 Profiling 的定义: </div><blockquote class="notion-quote notion-block-7c482f03931a47a3a6acabc2bf6fdc76">Profiling 是一种性能分析工具，用于确定程序或系统中哪些部分消耗了最多的资源（例如 CPU、内存、磁盘和网络）。它可以帮助开发人员找到性能瓶颈并改进代码。</blockquote><div class="notion-text notion-block-96dd4b4e95ca4598832c12ddeb6ae405">而 Continuous Profiling 就是在这个基础上，增加一个“持续”，也就是在生产环境里定期跑 Profiling 并将数据上报。</div><div class="notion-text notion-block-449915989c90440c869c46c0e8aefbf1">通常开发者手动跑 Profiling 往往是发现了线上代码性能瓶颈后，用工具<b>尝试复现瓶颈</b>，而 Continuous 最大的优势就是：持续意味着贯穿整个程序的完整生命周期，不会漏掉任何一个历史上产生过的异常，能直接从数据中找到“现场”，而不是尝试复现。</div><div class="notion-text notion-block-abb00b4c6d0d41c38afc4fab94df4e48">用一个非常直观的比较就能迅速理解二者的差异：如果 Profiling 最有代表性展示方式是火焰图的话，那么 Continuous Profiling 的表现形式就是带有时序功能的火焰图，你可以在拖动展示、对比不同时刻的火焰图，找到代码在时间维度上的性能变迁。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-12cfaf12fa4049b599e8333b9af2abac"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F63089862-ccda-4eda-bc70-c6b6b63e3f29%2FUntitled.png%3Fid%3D12cfaf12-fa40-49b5-99e8-333b9af2abac%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DbaQT-JOGiettRZKvo9jPrQRBZzYN4dqbE7mvLMbFeJE?table=block&amp;id=12cfaf12-fa40-49b5-99e8-333b9af2abac&amp;cache=v2" loading="lazy" alt="一个典型的例子" decoding="async"/><figcaption class="notion-asset-caption">一个典型的例子</figcaption></div></figure><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-206bb88933be49679f368558bcc606e7" data-id="206bb88933be49679f368558bcc606e7"><span><div id="206bb88933be49679f368558bcc606e7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#206bb88933be49679f368558bcc606e7" title="来龙"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">来龙</span></span></h3><div class="notion-text notion-block-dfe8cabb47ec4bb5b63c62b5c96c614c">Continuous Profiling 这个概念最早出自 Google 2010 年的研究文章： <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://research.google/pubs/pub36575/">Google-Wide Profiling</a> 。它虽然没有直接输出可用的工具，但是却给这个理念“打了样”：以较低的开销（～0.01% Overhead) 换取了大量对生产有用的代码状态数据，并且通过类 SQL 的方式查询以定位问题。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-ed9e1ca699764d0eb6deedd2e8828630" data-id="ed9e1ca699764d0eb6deedd2e8828630"><span><div id="ed9e1ca699764d0eb6deedd2e8828630" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ed9e1ca699764d0eb6deedd2e8828630" title="去脉"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">去脉</span></span></h3><div class="notion-text notion-block-dd03b69112404d01b0b226abdfc55d61">转眼到了十多年后，这期间有不少开源或商业软件涌现，但 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/open-telemetry/oteps/issues/139">OpenTelemetry 的加入</a>给了 Continuous Profiling 领域一个确定的未来。</div><blockquote class="notion-quote notion-block-635a88233c1445e2afedf2315c50b516">&quot;Four pillars&quot; </blockquote><div class="notion-text notion-block-11cf641a9e2d463c8fca31c7c45ab36e">在 Monitoring, Logging, Tracing 三大支柱的工具链逐渐完善后，Profiling 将成为可观测领域新的支柱。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-ff8aa8cb27304cf9b83c7ba73db89db4" data-id="ff8aa8cb27304cf9b83c7ba73db89db4"><span><div id="ff8aa8cb27304cf9b83c7ba73db89db4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ff8aa8cb27304cf9b83c7ba73db89db4" title="Why ?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Why ?</span></span></h2><div class="notion-text notion-block-7f1458051efa42e085e7b6771209e858">借用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/open-telemetry/oteps/blob/main/text/profiles/0212-profiling-vision.md#profiling-use-cases">OT Profiling Vision</a> 里列举的一些场景：</div><ul class="notion-list notion-list-disc notion-block-cbc020f0094c4bba8ece9c29b911a3bc"><li>跟踪应用程序的资源利用情况，以了解代码更改、硬件配置更改和临时环境问题如何影响性能</li></ul><ul class="notion-list notion-list-disc notion-block-fa770be690a34f3a8cb6b11545b435e9"><li>理解哪些代码负责消耗资源（例如 CPU、内存、磁盘、网络）</li></ul><ul class="notion-list notion-list-disc notion-block-7dcb3a9eeb364513926b0fb7b1f10ebf"><li>为在生产中运行的一组服务规划资源分配</li></ul><ul class="notion-list notion-list-disc notion-block-211ac4b4a1644bcab9f3e8d5523795bc"><li>比较不同代码版本的配置文件，了解代码如何随时间改进或退化</li></ul><ul class="notion-list notion-list-disc notion-block-498c3037f7224b47a5b0c66fd8e69177"><li>在生产中检测经常使用的和“死”代码</li></ul><ul class="notion-list notion-list-disc notion-block-c7854492820e4509a70e05fe7c870d52"><li>将跟踪跨度分解为代码级粒度（例如函数调用和代码行），以了解该特定单元的性能</li></ul><div class="notion-text notion-block-c93e9981143c48cf96a2d8ec8b784443">简而言之，Continue Profiling 可以帮助开发者掌握代码的“持续生产状态”。对于 DevOps 团队而言，它应该是 CD 后进行持续分析的一部分。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-43e2167daba84f9fadeec2a1df9e27be"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:641px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fd7c357f0-60a3-4143-99d7-8bb5e48c4d3c%2Fci_cd_cp.png%3Fid%3D43e2167d-aba8-4f9f-adee-c2a1df9e27be%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DEgngC6SYRGPKFGG40jqDsrojVhFBoshtrilWe1JU8Ss?table=block&amp;id=43e2167d-aba8-4f9f-adee-c2a1df9e27be&amp;cache=v2" loading="lazy" alt="CI → CD → CP" decoding="async"/><figcaption class="notion-asset-caption">CI → CD → CP</figcaption></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-75952cf6b2114d39b3854bae190044c4" data-id="75952cf6b2114d39b3854bae190044c4"><span><div id="75952cf6b2114d39b3854bae190044c4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#75952cf6b2114d39b3854bae190044c4" title="开源方案"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">开源方案</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3314794fb53c45d5a3a2c663c6c31feb" data-id="3314794fb53c45d5a3a2c663c6c31feb"><span><div id="3314794fb53c45d5a3a2c663c6c31feb" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3314794fb53c45d5a3a2c663c6c31feb" title="Pyroscope"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Pyroscope</span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-a80d3ca9d6bf432d8af5b230ce8e316e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fcbb841eb-f3d2-4eb5-96d9-dbd145229387%2FUntitled.png%3Fid%3Da80d3ca9-d6bf-432d-8af5-b230ce8e316e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3D-mUkW2Lg19lXFy5TYunDtTwZ940ASoaROQj0KXle5uM?table=block&amp;id=a80d3ca9-d6bf-432d-8af5-b230ce8e316e&amp;cache=v2" loading="lazy" alt="架构图" decoding="async"/><figcaption class="notion-asset-caption">架构图</figcaption></div></figure><div class="notion-text notion-block-fd6ad36920ce4430b2d066a3d12a09e9"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/pyroscope">Pyroscope</a> 项目算是这个领域中最热门的种子选手了。相较于其他几个项目有这么几个显著的优势：</div><ul class="notion-list notion-list-disc notion-block-6a16796c51eb45e5b44fd9e272ba3863"><li>UI 清晰美观，功能齐全，可以从官方提供的 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://demo.pyroscope.io/">demo</a> 窥见一二</li></ul><ul class="notion-list notion-list-disc notion-block-87f47658ccc64b75bca769bb413ffaad"><li>支持的语言广泛</li></ul><ul class="notion-list notion-list-disc notion-block-e694bbd59cbb4dc288836b8b6e22b6a9"><li>支持<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/pyroscope-io/otel-profiling-go"> Go\Java 的 Tracer 整合方案</a></li></ul><ul class="notion-list notion-list-disc notion-block-92b2af7fada54185a701bfc665d76ee8"><li>对存储有着额外的优化</li></ul><div class="notion-blank notion-block-6457ad46132e40518094645d0c94e2e0"> </div><div class="notion-text notion-block-a09a185df8f648df83cfd8e98e36473e">下面会针对一些有特点的优势展开说说：</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-2d043ca42a0a4a579def0858bbd3bd05" data-id="2d043ca42a0a4a579def0858bbd3bd05"><span><div id="2d043ca42a0a4a579def0858bbd3bd05" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2d043ca42a0a4a579def0858bbd3bd05" title="语言支持"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">语言支持</span></span></h4><div class="notion-text notion-block-e09cda5a8d6d4ec3afc15f038c6bfd37">上面有提到，Pyroscope 对于 pull 和 push 模型都有着完备的支持，最大的原因就是它针对各个语言的采集工具上都做了适配，并封装成了 SDK：</div><ul class="notion-list notion-list-disc notion-block-64ce02c0d80f4c1eb01a3416d04a88ef"><li>Go: pprof</li></ul><ul class="notion-list notion-list-disc notion-block-8aea834ea1b846ab9f572023b699122c"><li>ruby: rbspy</li></ul><ul class="notion-list notion-list-disc notion-block-8d2876d7fc8b451bb9c0ecfb7c873a8e"><li>python: py-spy</li></ul><ul class="notion-list notion-list-disc notion-block-3f1641beb763490f84533125077ae361"><li>Java: async-profiler</li></ul><ul class="notion-list notion-list-disc notion-block-a29951416c6f441c8ba66c56356018ac"><li>php: phpspy</li></ul><ul class="notion-list notion-list-disc notion-block-8d064bb078c14a71bd96dd08a7a7867b"><li>.NET: dotnet trace</li></ul><ul class="notion-list notion-list-disc notion-block-0296b97b1cfa4a8db27265d372f617fc"><li>Rust: pprof-rs</li></ul><div class="notion-text notion-block-00852e1981984a5e9200f1988a79b716">即使部分语言的支持并不完美（例如 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/pyroscope/issues/316">Python 不支持 Memory 数据上报</a>），但鉴于其他项目基本都只支持 Go + pprof，在面临多语言环境时，Pyroscope 基本是开源的唯一选择。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-08786eb20478421a81fb47dd7bf5b366" data-id="08786eb20478421a81fb47dd7bf5b366"><span><div id="08786eb20478421a81fb47dd7bf5b366" class="notion-header-anchor"></div><a class="notion-hash-link" href="#08786eb20478421a81fb47dd7bf5b366" title="存储优化"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>存储优化</b></span></span></h4><div class="notion-text notion-block-e178846c8fc64ba5a937b10aa103dc65">与其他几个项目还有一个很大的不同，pyroscope 在 profiling 数据的存储上做了额外的优化，开发者专门写了<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://pyroscope.io/docs/storage-design/">一篇 Blog 介绍了思路</a>。在这里做下简要的介绍并分析。</div><div class="notion-text notion-block-81436e3f7d3e416aae5769ef6d67ed44">首先是借助树和字典树，它针对 Profiling 的重复数据做了压缩。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-9338f096d1654d938c521f62f398c4bd"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F9e702fd3-af76-4d02-8c0a-a63492cc01aa%2Fstorage.gif%3Fid%3D9338f096-d165-4d93-8c52-1f62f398c4bd%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DP2YT89OyXeL-aqIOZ4jQ-o5Ud2SD7CbH2Jhy8Ca1a8Q?table=block&amp;id=9338f096-d165-4d93-8c52-1f62f398c4bd&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-59e4348f998e4206bf7bd0023e8a8e87">其次，为了解决长时间跨度数据的查询延迟问题，利用线段树对数据进行了预合并。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-5a0fd51dfc174e8ab3be79d680bc26a5"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F933febec-2e5c-44e4-ad8a-d18c952064d6%2Fsegment.gif%3Fid%3D5a0fd51d-fc17-4e8a-b3be-79d680bc26a5%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DTF0__PJYw9yNY0XE29xkCrUePgcz9cV54Fn4vTbkAFU?table=block&amp;id=5a0fd51d-fc17-4e8a-b3be-79d680bc26a5&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4e7f4491b1fd4bd0a7c9d949749fa38e">虽然和其他项目一样，它的存储逻辑模型基本依照 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/google/pprof/blob/main/proto/profile.proto">pprof 定义</a>，得益于这些优化，它在存储空间和读取延迟上都有更好的表现。但也带来了一些其他的问题：</div><ul class="notion-list notion-list-disc notion-block-dfcfa7b637974d1a8f5e8e0fc601ed68"><li>为了更容易实现这些优化，存储引擎选择了灵活的 K-V 结构内嵌引擎 BadgerDB，也因此失去了更好的水平扩展能力。</li></ul><ul class="notion-list notion-list-disc notion-block-bb062c71c23948d98d568f80d64fabae"><li>在结构落库时需要消耗更多的 CPU 计算，压测时 CPU 更容易出现瓶颈。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-37e40bbda9a749daa1a67892cc97d832" data-id="37e40bbda9a749daa1a67892cc97d832"><span><div id="37e40bbda9a749daa1a67892cc97d832" class="notion-header-anchor"></div><a class="notion-hash-link" href="#37e40bbda9a749daa1a67892cc97d832" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h4><div class="notion-text notion-block-e976ec5fe5fe45c585fb7ee41d1746db">Pyroscope 绝对是 Profiling 领域的开源种子选手，它的长板很长（语言支持、存储优化等），同时考虑到最近被 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://grafana.com/blog/2023/03/15/pyroscope-grafana-phlare-join-for-oss-continuous-profiling/">Grafana Labs 收购</a>，原来的短板恰好是 Grafana 团队擅长处理的，相信等待一段时间的发展，Pyroscope 有潜力成为该领域的<b>开源标准答案</b>。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-076bbf9997b94a71ab23682052568fc4" data-id="076bbf9997b94a71ab23682052568fc4"><span><div id="076bbf9997b94a71ab23682052568fc4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#076bbf9997b94a71ab23682052568fc4" title="Parca"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Parca</span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-220a046a390c49569d06210dbaaf21db"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:150px"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fce81fb64-8a5f-4466-8745-857180009084%2FParca_Overview.svg%3Fid%3D220a046a-390c-4956-9d06-210dbaaf21db%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DRAMZ19E1A8Q3JHiGlvsG9qGEm4vn0zYGluEo1Kju2x4?table=block&amp;id=220a046a-390c-4956-9d06-210dbaaf21db&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-d81dc4adb7ba4611bea062f04f74ff7f"> </div><div class="notion-text notion-block-1a3c33f64c9e4a63b1e996674a74f62b"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/parca-dev/parca/">Parca</a> 项目是由原 Prometheus 团队的开发者开发，带有浓浓的 Prometheus 的味道。相较于其他项目，它也有几个显著的特点：</div><ul class="notion-list notion-list-disc notion-block-67b2a209de734b0dac7aa1615518435f"><li>Agent 完全采用了 ebpf  作为采集方案</li></ul><ul class="notion-list notion-list-disc notion-block-0804f542fd8a45429a71579962335f5b"><li>Profile Meta 和 Profile Sample 使用了两种不同的引擎存储，其中 Sample 存储采用了自研的内嵌列存 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/polarsignals/frostdb">FrostDB</a></li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-88491eadc7ff407a9a64160c71a85044" data-id="88491eadc7ff407a9a64160c71a85044"><span><div id="88491eadc7ff407a9a64160c71a85044" class="notion-header-anchor"></div><a class="notion-hash-link" href="#88491eadc7ff407a9a64160c71a85044" title="eBPF Agent"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">eBPF Agent</span></span></h4><div class="notion-text notion-block-d7cc5e3f224d4df29528e14ea39e56fd">近几年 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://ebpf.io/">eBPF</a> 在云原生、可观测领域讨论度很高，相信紧跟热点的各位读者也是早有耳闻，我在这里就不做多的赘述。Parca 最显著的一个特点就是在 Agent 上完全使用 eBPF 来解决问题。以下是一个简化的处理流程：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-2feb672e1a784431a03fcaa90749554e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fc0197489-56d8-4b57-8710-f6b517f8fcba%2FPasted_image_20230113174652.png%3Fid%3D2feb672e-1a78-4431-a03f-caa90749554e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DzBOCHI64vVI_7oHdg67mRKQA7sR3l_gsg_zCl5GGzwc?table=block&amp;id=2feb672e-1a78-4431-a03f-caa90749554e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-fcbebe65025c41548496140149b36e9e">在 Profiling 领域，eBPF 的优劣我们会在后面的章节谈到，这里就一笔带过了。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-a60e62ba31514a2d899cfa999592dc00" data-id="a60e62ba31514a2d899cfa999592dc00"><span><div id="a60e62ba31514a2d899cfa999592dc00" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a60e62ba31514a2d899cfa999592dc00" title="Meta Sample 分离存储"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Meta Sample 分离存储</span></span></h4><div class="notion-text notion-block-2f3a7263aabc473bb644365009281f93">Parca 和其他项目一样，存储的逻辑模型也是依照 pprof 的数据定义，而 pprof 逻辑模型中，按照其不同的特性，可以划分为两类数据：<b>Meta 和 Sample</b>。所谓的分离存储，实际上是讨论：<b>这两类数据是否使用不同的存储引擎。</b></div><table class="notion-simple-table notion-block-12da01c5a71b44e989025837ba513115"><tbody><tr class="notion-simple-table-row notion-block-e7c505e720604348851134b3e8737e6f"><td class="" style="width:120px"><div class="notion-simple-table-cell">类型/特性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">具体内容</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">是否需要计算</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">数据量级</div></td></tr><tr class="notion-simple-table-row notion-block-e83d4d870fe64139ad9f8afa128ac8e4"><td class="" style="width:120px"><div class="notion-simple-table-cell">Metadata</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">Function/Mapping/Location 等</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">很少</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">较小</div></td></tr><tr class="notion-simple-table-row notion-block-89fa559f828f4751a31052b880e6f8a6"><td class="" style="width:120px"><div class="notion-simple-table-cell">Sample</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">时序的 Stacktrace</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">大量合并计算</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">大</div></td></tr></tbody></table><div class="notion-text notion-block-46e77f4d1a8a4bf2a8b1e8d915ad3311">由于以上特性，二者的读写需求也不同，所以顺其自然的想法就是将其分成不同的引擎存储。</div><table class="notion-simple-table notion-block-17365db1ff864361bf2545e52b8392a6"><tbody><tr class="notion-simple-table-row notion-block-13051b7e3fe24afb9f0f30f9d09ccacd"><td class="" style="width:120px"><div class="notion-simple-table-cell">方式/特性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">开发便捷性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">后期存储维护性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">存储引擎选择空间</div></td></tr><tr class="notion-simple-table-row notion-block-f56ed814e806402a8e05eefd3b153340"><td class="" style="width:120px"><div class="notion-simple-table-cell">统一存放</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">高</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">一般</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">一般</div></td></tr><tr class="notion-simple-table-row notion-block-f8816f65d78846c7bef7c60baf91c49d"><td class="" style="width:120px"><div class="notion-simple-table-cell">分离存放</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">较低</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">高</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">高</div></td></tr></tbody></table><div class="notion-text notion-block-9b3122f2d68544ccb5e4045187dbe25f">相较于后期的维护性，开发便捷性的损失是一次性且短期的，且不分离的情况是不太方便针对二者特性做针对性优化的。所以 Meta / Sample 分离存储，对于服务的“长治久安”有着更好的积极意义。<em>当然 Parca 目前在 Sample 存储上使用的 FrostDB 还未到可以直接生产的阶段，目前仅是 Parca 专用内嵌引擎。</em></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-4c1de643193b4a2fbd6f04e44ebf9978" data-id="4c1de643193b4a2fbd6f04e44ebf9978"><span><div id="4c1de643193b4a2fbd6f04e44ebf9978" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4c1de643193b4a2fbd6f04e44ebf9978" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h4><div class="notion-text notion-block-eb594843a6c64160bc81dddc4ca6bca3">Parca 项目在 Agent 选择和存储设计上有独到之处，虽然在语言支持上比较少（Go 和有限的 Java），但仍旧可以作为方案设计上的重要参考。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f2770103f80e4810bf88b50be6f34f55" data-id="f2770103f80e4810bf88b50be6f34f55"><span><div id="f2770103f80e4810bf88b50be6f34f55" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f2770103f80e4810bf88b50be6f34f55" title="Phlare"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Phlare</span></span></h3><div class="notion-row notion-block-9da5ce52ec33408a920005e785402e04"><div class="notion-column notion-block-9c6db133b2f54cad9f644e16783bd111" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.25)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-246d23ebb5b340fdb8c534f8b2dbffe6"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:192px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fcb2d83a7-b7b5-4e45-8d72-0ac07fce9042%2FUntitled.png%3Fid%3D246d23eb-b5b3-40fd-b8c5-34f8b2dbffe6%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3D5XeKJbzvFpoR_d6DMzPQcxLM3NbqL8Pf4EDkBnzQbwM?table=block&amp;id=246d23eb-b5b3-40fd-b8c5-34f8b2dbffe6&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></div><div class="notion-spacer"></div><div class="notion-column notion-block-526b9dadc3e4407a997e91102bf5e51d" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.75)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-727db1ff238b48a4831d8797ccfa555e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F87cd1ef9-8c30-4c64-8e0f-c2c6aa20da27%2FUntitled.png%3Fid%3D727db1ff-238b-48a4-831d-8797ccfa555e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DckrMQtKlYFkBgsbtpLE8gpLYBQE4w_rBzq4Ks_1kA7M?table=block&amp;id=727db1ff-238b-48a4-831d-8797ccfa555e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-b2293d9a71bc457d8827a793da2c3445"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/phlare">Phlare</a> 是 Grafana Labs 出品的 Profiling 产品，随着 Pyroscope 被收购，Phlare 项目很可能会被直接揉碎，合并到 Pyroscope 中去。即便如此，Phlare 项目仍旧有着不少有意思的亮点：</div><ul class="notion-list notion-list-disc notion-block-0232149f3a7a4cb384aa7e3ae1746c2c"><li>支持 monolithic/microservices 两种启动模式，既能满足快速验证，又能在大规模部署中轻易水平扩展</li></ul><ul class="notion-list notion-list-disc notion-block-23ce3432c80946d493d2262ffc13ff25"><li>数据存储分层，热数据存放在 ingster 的本地块存储中，冷数据发送到远端的对象存储中，总占有成本 TCO 较低（当然是存储空间的，没有考量到对象存储发送带来的带宽成本）</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-bd78b2d100614fbf9dc9dd151a176579" data-id="bd78b2d100614fbf9dc9dd151a176579"><span><div id="bd78b2d100614fbf9dc9dd151a176579" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bd78b2d100614fbf9dc9dd151a176579" title="水平扩展"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">水平扩展</span></span></h4><div class="notion-text notion-block-b11bc31a057e44b7a5572a0844f3b0c1">相较于 Parca 和 Pyroscope，Phlare 总算把工程的扩展能力当作重要考量了。要知道前面二者想要水平扩展，无论是想扩展读或者写的能力，都只能将整个进程跑起来，存储走 remote write 的方式，既笨拙又浪费资源，难称优雅。而 Phlare 具备以微服务部署的能力，qureier 和 distrubutor 可以较轻松地水平扩展。</div><ul class="notion-list notion-list-disc notion-block-6ad656e2dd1d402e99076d562540f7d9"><li>在存储上通过一致性哈希解决分片问题</li></ul><ul class="notion-list notion-list-disc notion-block-f642c64176f94b1aa709966cfa0d891b"><li>通过 Gossip 解决分布式选主问题</li></ul><div class="notion-text notion-block-79b9e13d7c284eb78e5005bc2c016d8f">为了更好地理解它是如何工作的，以四个 ingester 和一个位于0和9之间的令牌空间为例（<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://grafana.com/docs/phlare/latest/operators-guide/architecture/hash-ring/#a-practical-example">来源</a>）：</div><ul class="notion-list notion-list-disc notion-block-0abb44d9585a4ccc824b5ddf30c97fb7"><li>ingester#1在令牌环中注册令牌<code class="notion-inline-code">2</code></li></ul><ul class="notion-list notion-list-disc notion-block-c07c3761d32047ad8eb3adb0487e7652"><li>ingester#2在令牌环中注册令牌<code class="notion-inline-code">4</code></li></ul><ul class="notion-list notion-list-disc notion-block-baa45b6b8f6148cba4455c18a7f7eb4d"><li>ingester#3在令牌环中注册令牌<code class="notion-inline-code">6</code></li></ul><ul class="notion-list notion-list-disc notion-block-eaf4410a5f0b4d5193e5cdf5d2657eb9"><li>ingester#4在令牌环中注册令牌<code class="notion-inline-code">9</code></li></ul><div class="notion-text notion-block-b894ea0988e449af8745088af1efa4a8">当它接收到一个带有 label <code class="notion-inline-code">{</code><code class="notion-inline-code"><b>name</b></code><code class="notion-inline-code">=&quot;process_cpu&quot;, instance=&quot;1.1.1.1&quot;}</code> 的 Profile 数据时，它会将 label 内容进行哈希计算，假如这次计算后的结果是 <code class="notion-inline-code">3</code> 。为了找到对应的 ingester，将会尝试寻找哈希环上 token 值上大于 <code class="notion-inline-code">3</code> 最靠近的一个，即 ingester#2，并认为它将是这份 Profile 的权威数据拥有者。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-418f8f28c28d431c9066d18a902fc56c"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fa9b13bb1-7174-46a7-ba2e-98d9804ae94c%2FUntitled.png%3Fid%3D418f8f28-c28d-431c-9066-d18a902fc56c%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DRqQBi78GGguYD23yfp4n0XthY2qfOXy_NDae-qUJX1M?table=block&amp;id=418f8f28-c28d-431c-9066-d18a902fc56c&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-1f2d089073794a2c961af4aafb4d2eeb">此时， Ingester 的副本数设置如果是 3 个，在 ingester#2 被选主后，将继续向后寻找接下来的两个实例，即 ingester#3 &amp; ingester#4，并将数据复制分摊到他们的存储中，以保证数据能够均匀地被复制成多副本来保证高可用。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-b63c5b803d2d46998fd3fc48ed2674f0"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fa86cc56a-1126-4d9d-984c-3d1ebd31c01a%2FUntitled.png%3Fid%3Db63c5b80-3d2d-4699-8fd3-fc48ed2674f0%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DZ5rYJs4dPpD0kzMaT1yHCgTKkpVObG0F_cm1_NwmM_c?table=block&amp;id=b63c5b80-3d2d-4699-8fd3-fc48ed2674f0&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-6418d4f2c11e4b0d9c50138a28b47cc0" data-id="6418d4f2c11e4b0d9c50138a28b47cc0"><span><div id="6418d4f2c11e4b0d9c50138a28b47cc0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6418d4f2c11e4b0d9c50138a28b47cc0" title="分级存储"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">分级存储</span></span></h4><div class="notion-text notion-block-1499e616f1614485a163a068227e4b8c">phlare 的存储流程较为复杂，主要分成了三个部分：</div><ul class="notion-list notion-list-disc notion-block-d1982325a2e143df85159efe7f5d819f"><li>head block，ingester 模块获取到数据后不会立即写入到长期存储中，而是首先放在内存</li></ul><ul class="notion-list notion-list-disc notion-block-4098b0b3a6e242e09baa0c03e48c3251"><li>当 head block 大小超限或者超时，会将这些数据写到 ingester 本地磁盘</li></ul><ul class="notion-list notion-list-disc notion-block-2a79cae4a8f74c0ead71e87ac1532eb8"><li>内存和磁盘的数据都将会周期上报到 Long term storage</li></ul><div class="notion-text notion-block-d54af76f9e3540568914ee603bd3f859">这样做的好处显而易见：</div><ul class="notion-list notion-list-disc notion-block-226d9fce607249a896978d3c694c006b"><li>最热的数据将在内存中被访问，速度最快</li></ul><ul class="notion-list notion-list-disc notion-block-a8f0029cb20a4ba3b36156f7b145d2fc"><li>大量的冷数据放到了对象存储，成本更低</li></ul><div class="notion-text notion-block-77b99172e84b45318da712e7b41575f7">但也有些问题，就像上面 <code class="notion-inline-code">read path</code> 中表述的，对象存储中冷数据的读取问题会存在延迟问题，后面在对象存储和块存储的对比环节会稍微展开。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-8e4d8ade7820401ebdcf474902336cc0" data-id="8e4d8ade7820401ebdcf474902336cc0"><span><div id="8e4d8ade7820401ebdcf474902336cc0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8e4d8ade7820401ebdcf474902336cc0" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h4><div class="notion-text notion-block-cd1e02de1ac640358de6201ae337a5b5">Phlare 相较于 Parca 和 Pyroscope 增加了更多工程上的探索，它比后两者都更容易在大集群中部署和扩展，但它只支持 pprof Http 端点数据拉取，仅有 Go 能够被较好的支持，这也成了它没法被大规模采用的最大障碍。在 Pyroscope 被收购后，Phlare 的这些工程特点也许会被整合到前者里去，就让我们继续关注接下来会发生什么吧。 </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-617226dac0924b34adb5c589ea30c6d9" data-id="617226dac0924b34adb5c589ea30c6d9"><span><div id="617226dac0924b34adb5c589ea30c6d9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#617226dac0924b34adb5c589ea30c6d9" title="Pixie"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Pixie</span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-df187fd9c3d64b68803fe7015fb83b79"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F04cb20ca-0d39-4887-90b1-b156b1c5e266%2FPasted_image_20230106143708.png%3Fid%3Ddf187fd9-c3d6-4b68-803f-e7015fb83b79%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DEqa3jL5V5_c4SzFN8RW2eBhhEgfF-Ydo3Ti--M0SIz8?table=block&amp;id=df187fd9-c3d6-4b68-803f-e7015fb83b79&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-32aa0517a8c648a586437c1bd3cd8a4a"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/pixie-io/pixie">pixie</a> 实际上并不是一个 Profiling 专用软件，而是一个 K8S 应用的观测工具。除了 Profiling 以外，它还包括了Service 映射、集群资源、应用流量等能力。我们这里仅关注它的 Continuous Profiling 能力。</div><div class="notion-text notion-block-cf8de9121c9649d786a77600dbc8fc13">相较于以上其他开源软件，它又有一些不同的特点：</div><ul class="notion-list notion-list-disc notion-block-e876d5c1fd4f42c9992cdc75dc106cc7"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.px.dev/reference/pxl/">PxL</a>，用于查询 SQL 不再是 PromQL like 而是 Python 风格</li></ul><ul class="notion-list notion-list-disc notion-block-78fe8bc96a2c4353987bfea9ef58a589"><li>与 K8S 集群绑定较强，不适合部署在物理机的服务</li></ul><ul class="notion-list notion-list-disc notion-block-e49581c5d352403caae0ebd5f1eacb11"><li>底层使用 eBPF 采集数据，编译型语言支持更好</li></ul><ul class="notion-list notion-list-disc notion-block-66c292295b0e4d02b6114870c302d564"><li>仅限于 CPU Profiling</li></ul><div class="notion-text notion-block-1b1638fc5f1a46c09c79c08a66ded20b">由于它在 Profiling 领域着墨不多，功能也相对简单，这里就不做过多展开了。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-e00ee34fb0844b0d989297233c5e626e" data-id="e00ee34fb0844b0d989297233c5e626e"><span><div id="e00ee34fb0844b0d989297233c5e626e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e00ee34fb0844b0d989297233c5e626e" title="商业软件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">商业软件</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-6de913a222044b2496063feb21c4ff9e" data-id="6de913a222044b2496063feb21c4ff9e"><span><div id="6de913a222044b2496063feb21c4ff9e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6de913a222044b2496063feb21c4ff9e" title="Datadog Continuous Profiler"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Datadog Continuous Profiler</span></span></h3><div class="notion-text notion-block-6d22ce30e1e14355b971b895fa8e3775">Datadog 作为可观测的商业 SaaS 产品巨头，推出的 Profiler 产品质量非常高，由于它的闭源性，我们很难分析它具体的技术架构，仅从它产品表现来窥见一二。</div><div class="notion-text notion-block-bb9bbc619d7d45a28291756594c5d74b">以下是一些 Datadog 有别于开源产品的亮眼功能。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-05c52ae909e04cf1899de9f07940e7f1" data-id="05c52ae909e04cf1899de9f07940e7f1"><span><div id="05c52ae909e04cf1899de9f07940e7f1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#05c52ae909e04cf1899de9f07940e7f1" title="可以细粒度控制 function 展示内容"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">可以细粒度控制 function 展示内容</span></span></h4><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-825348739a044914904a996da3771045"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F4c5de3f5-8b9f-4027-bd50-bab3528a30fe%2FPasted_image_20230209155039.png%3Fid%3D82534873-9a04-4914-904a-996da3771045%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3D-B4rycf7xEO2a39yzXRLBGOC-_pFxZBNCcBWDvQEvrM?table=block&amp;id=82534873-9a04-4914-904a-996da3771045&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-23f4922cd3cd4a3c97f5f3c0def5c118" data-id="23f4922cd3cd4a3c97f5f3c0def5c118"><span><div id="23f4922cd3cd4a3c97f5f3c0def5c118" class="notion-header-anchor"></div><a class="notion-hash-link" href="#23f4922cd3cd4a3c97f5f3c0def5c118" title="Only My Code 可以聚焦于用户代码"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Only My Code 可以聚焦于用户代码</span></span></h4><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-61cbf1cb4dee4af1a1a902731bdc2aca"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F6ed74e04-7843-405b-91cf-8e46321f2378%2FPasted_image_20230209153132.png%3Fid%3D61cbf1cb-4dee-4af1-a1a9-02731bdc2aca%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3Dhc0NO6PUacUEG8NvdaXPRNsy6gh3f_MNJaGlXPj5KRM?table=block&amp;id=61cbf1cb-4dee-4af1-a1a9-02731bdc2aca&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-56a944c7a6c14831bd112a0aaa4efd18"> </div><div class="notion-text notion-block-a3251afd1fdf4423b18260b0532ef4da">聚焦前</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-df84be5a47574ff1a968281d27c40e08"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F40bd239c-c278-41f1-b81f-07659d949145%2FPasted_image_20230209161309.png%3Fid%3Ddf84be5a-4757-4ff1-a968-281d27c40e08%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DJQVxQwLZVfzd0aJuriM7ojqQky3Q5Fvn8pp_dxXInl4?table=block&amp;id=df84be5a-4757-4ff1-a968-281d27c40e08&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-76583d7e5cc942c7b479b6c41cbda10e">聚焦后</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ce4525d48926433298c980382af68fae"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fe9f62ef1-da7f-4ee0-a7c0-a384c94cf72f%2FPasted_image_20230209161312.png%3Fid%3Dce4525d4-8926-4332-98c9-80382af68fae%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DfRhXNk8emyWylpp1SZSWj6Ww6ctRkIwXRMVxYbrD7sE?table=block&amp;id=ce4525d4-8926-4332-98c9-80382af68fae&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-6be2086592f947ad9a39f664cbd00cba" data-id="6be2086592f947ad9a39f664cbd00cba"><span><div id="6be2086592f947ad9a39f664cbd00cba" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6be2086592f947ad9a39f664cbd00cba" title="对比图表直观清晰"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">对比图表直观清晰</span></span></h4><div class="notion-text notion-block-05d48bad82094e39a91a2c1ef173bdad">对比视图，通过颜色能够清晰获取不同时间的代码内存申请的异同。火焰图表现：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-e357cd64c9ea4f5c89f215397a2b2ad1"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fa0575373-99e8-42b4-afcf-0dd78c65b4b1%2FPasted_image_20230209162221.png%3Fid%3De357cd64-c9ea-4f5c-89f2-15397a2b2ad1%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DHoX7avjOJyAbgkPQeIlWr3XnkGFUGv4FJrzV19dkQyI?table=block&amp;id=e357cd64-c9ea-4f5c-89f2-15397a2b2ad1&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-e429a496ce9e4014ac37fe95a77c287d">表格表现：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-3461c9b11c574bec91b344d2aee67f7e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F82b8c0ac-0516-4a8b-b09b-b0bf1fa7650a%2FPasted_image_20230209162359.png%3Fid%3D3461c9b1-1c57-4bec-91b3-44d2aee67f7e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3D2iCt5ZS_POaxkrmpGchQcAVU2Ac1nC-uECEY_IHifzI?table=block&amp;id=3461c9b1-1c57-4bec-91b3-44d2aee67f7e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-8b8b5ae4a8bd483092fd8bd09622f708" data-id="8b8b5ae4a8bd483092fd8bd09622f708"><span><div id="8b8b5ae4a8bd483092fd8bd09622f708" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8b8b5ae4a8bd483092fd8bd09622f708" title="常用的数据聚合快捷入口"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">常用的数据聚合快捷入口</span></span></h4><div class="notion-text notion-block-52903829b2e04913991e5f34fc31163b">在 CPU 数据上，已经根据不同纬度提供了聚合计算快捷入口。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d6be32cedf584312ab16bc40d0a7a85d"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F6b7742fe-f526-4231-b30a-158b52a32c2f%2FPasted_image_20230209161756.png%3Fid%3Dd6be32ce-df58-4312-ab16-bc40d0a7a85d%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DmObnp63z2R8u6s38QOT9s1nkPW_71azzbgTmRz7TB0Q?table=block&amp;id=d6be32ce-df58-4312-ab16-bc40d0a7a85d&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-f427825cc82d402a951d6bbc75022f29" data-id="f427825cc82d402a951d6bbc75022f29"><span><div id="f427825cc82d402a951d6bbc75022f29" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f427825cc82d402a951d6bbc75022f29" title="Elastic Profiler?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Elastic Profiler?</span></span></h4><div class="notion-text notion-block-c744f64c2bc14c55a785e406e8da5508">实话实说，实际上在本文写成的时候，笔者尚未体验过 Elastic Profiler ，这里就暂不置评，留空日后补充。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-8bb6b79be1494abd95fc05375e139b88" data-id="8bb6b79be1494abd95fc05375e139b88"><span><div id="8bb6b79be1494abd95fc05375e139b88" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8bb6b79be1494abd95fc05375e139b88" title="方案选型对抗赛"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方案选型对抗赛</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-729375fb46d2432a971f3de708f5fa8c" data-id="729375fb46d2432a971f3de708f5fa8c"><span><div id="729375fb46d2432a971f3de708f5fa8c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#729375fb46d2432a971f3de708f5fa8c" title="推 vs 拉"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">推 vs 拉</span></span></h3><div class="notion-text notion-block-388f9c2043f6486f9c7adc9ccdb3170f">在可观测领域，数据获取的方向一直是热议的话题，Profiling 也不例外。以下是概要性的对比：</div><table class="notion-simple-table notion-block-ea137915745a434bbb652864ecfde965"><tbody><tr class="notion-simple-table-row notion-block-82667e4945fb4f70b3d9f9ef238421ea"><td class="" style="width:120px"><div class="notion-simple-table-cell">对比特性</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">pull</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">push</div></td></tr><tr class="notion-simple-table-row notion-block-e9ae2ae75d1f4c10a77f52574fb72731"><td class="" style="width:120px"><div class="notion-simple-table-cell">配置方式</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">原生中心化配置</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">端上配置，通过配置中心支持中心化</div></td></tr><tr class="notion-simple-table-row notion-block-ea7924fe40b346ea8a717f8f229cb652"><td class="" style="width:120px"><div class="notion-simple-table-cell">监控对象发现</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">依赖服务发现机制</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">由应用、Agent自主上报，无需服务发现模块</div></td></tr><tr class="notion-simple-table-row notion-block-77257cf2d83b4d5ca698562af2ed67ad"><td class="" style="width:120px"><div class="notion-simple-table-cell">部署方式</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">应用暴露端口，接入服务发现，原生支持Pull协议</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">1. Agent 统一代理抓取 2. 应用主动推送到监控系统</div></td></tr><tr class="notion-simple-table-row notion-block-e078d02aa86d4c26971682754e03ad7f"><td class="" style="width:120px"><div class="notion-simple-table-cell">指标获取灵活性</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">On Demand按需获取</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">被动接受，需要一些过滤器额外支持</div></td></tr><tr class="notion-simple-table-row notion-block-cc1d665f152f41d9badf3845818e3216"><td class="" style="width:120px"><div class="notion-simple-table-cell">应用耦合性</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">应用与监控系统解耦，应用无需关心对端地址、错误处理等</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">与应用代码耦合</div></td></tr><tr class="notion-simple-table-row notion-block-d0a2485b01dd4219890271c7def50da1"><td class="" style="width:120px"><div class="notion-simple-table-cell">安全性保证</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">工作量大，需要保证应用暴露端口的安全性，容易被DDos攻击或者出现数据泄露</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">难度低，ingest 接口交互一般都有鉴权控制</div></td></tr></tbody></table><div class="notion-text notion-block-d621544513cb43a3820e4504d27ff671">与 Prometheus 稍有不同的是，Continuous Profiling 基本不存在短任务数据上报的场景——既然都是 <em><b>Continuous</b></em> 了，那肯定不短，所以 pull 场景中最大的短板——难以适配短任务——基本不存在了。同时，由于 Go 语言是该领域的绝对“第一公民”，其标准库就支持的 pprof 模块能够以极低的开发成本添加 pprof HTTP 端点，所以三大开源软件在 pull 方向的支持上都是完备的，而 push 方向除了 pyroscope，其他项目均有不同程度的“残缺”。<b>考虑到 OT 和其他语言工具转换 pprof 的进度，这种“重 pull 轻 push” 的现象仍将在 Profiling 领域持续一段时间。</b></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-492b9ded6ab74c859f1b670c85082431" data-id="492b9ded6ab74c859f1b670c85082431"><span><div id="492b9ded6ab74c859f1b670c85082431" class="notion-header-anchor"></div><a class="notion-hash-link" href="#492b9ded6ab74c859f1b670c85082431" title="存算分离 vs 存算一体"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">存算分离 vs 存算一体</span></span></h3><div class="notion-text notion-block-b848417ccee74127b14a99e0b1b45381">Profiling 项目最大的技术难点就是如何处理存储，这也是可观测领域一直以来的重点。其中存算分离和存算一体的选择，决定了存储引擎乃至整个产品的形态。</div><div class="notion-text notion-block-02a9cf6c699b49c08d89833a0dfe2d91">在我们上面分享的几个开源产品中，它们无一例外都选择了内嵌式——也就是存算一体的方式，无论是性能较好、灵活度较高、但缺少水平扩容的 BadgerDB，还是列存 FrostDB，存取逻辑都是和计算进程绑定在一起。</div><div class="notion-text notion-block-ccd3f17c24424a33909e5866f78bccaa">在我看来，产品的服务形态是存算分离与否的决定性因素。</div><table class="notion-simple-table notion-block-103b930472654b0f9fb20767b10bf256"><tbody><tr class="notion-simple-table-row notion-block-c66eb9f03c8744ca9be5f27287d5599d"><td class="" style="width:177px"><div class="notion-simple-table-cell">服务形态/存储类型</div></td><td class="" style="width:222.3671875px"><div class="notion-simple-table-cell">选择存算一体（内嵌存储引擎）</div></td><td class="" style="width:307px"><div class="notion-simple-table-cell">选择存算分离（分布式存储服务）</div></td></tr><tr class="notion-simple-table-row notion-block-6d6a9274483e4056b926d13283b0887d"><td class="" style="width:177px"><div class="notion-simple-table-cell">OSS</div></td><td class="" style="width:222.3671875px"><div class="notion-simple-table-cell">● 少依赖，易部署 👍<!-- -->
<!-- -->● 针对性优化灵活 👍</div></td><td class="" style="width:307px"><div class="notion-simple-table-cell">● 额外依赖，数据优化灵活度低 👎</div></td></tr><tr class="notion-simple-table-row notion-block-a23fb04728ea49a3b40222e9a59adaf4"><td class="" style="width:177px"><div class="notion-simple-table-cell">SaaS</div></td><td class="" style="width:222.3671875px"><div class="notion-simple-table-cell">● 扩展、灾备方案不完善 👎</div></td><td class="" style="width:307px"><div class="notion-simple-table-cell">● 将状态向存储侧转移，组件复杂度相对低 👍<!-- -->
<!-- -->● 针对性优化难度稍高 👎</div></td></tr></tbody></table><div class="notion-text notion-block-62231d19391d4f3296212a660cdba8dc">总而言之，产品的服务形态将很大程度上决定存储的模式。如果是偏向于 OSS 分发，选内嵌存储，如果是以 SaaS 服务为主，选专用的分布式 DBMS。当然，从具体的工程实现来说，完全可以在存储上加一个可插拔的抽象层，以适配不同的服务形态，类似<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/pyroscope/issues/169">这里的讨论</a>。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3b4160403f964f46818d70117d0dd1ec" data-id="3b4160403f964f46818d70117d0dd1ec"><span><div id="3b4160403f964f46818d70117d0dd1ec" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3b4160403f964f46818d70117d0dd1ec" title="块存储 vs 对象存储"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">块存储 vs 对象存储</span></span></h3><div class="notion-text notion-block-b43f05718b4344848f23b06d6607b0f5">在存储领域，块存储和对象存储都是非常常见的方式。</div><div class="notion-text notion-block-8d19018ac43d474f9362f09988de282f">块存储（Block Storage）是将存储数据分为固定大小的块进行存储，适合于需要低延迟、高性能、高可用的场景，如数据库、虚拟机、容器等。块存储一般使用本地存储或网络存储，操作系统可以使用块设备访问。<b>缺点在于扩展性差、价格相较于对象存储更贵，不适合存储海量数据。</b></div><div class="notion-text notion-block-d4b9131a579341c2bf44c7089c85d8f2">对象存储（Object Storage）则是将数据存储为对象，每个对象都有唯一的标识符（URI），将数据分散到多个节点上，通过分布式算法实现高可用和容错，适合于海量数据存储和分布式存储。<b>缺点在于读写性能较差，不适合要求低延迟和高性能的场景。</b></div><div class="notion-text notion-block-c53f4d3ed9774473be313ce3ed0167d6">在实际 Profiling 场景下，通常会有两部分数据：</div><ul class="notion-list notion-list-disc notion-block-74a5923f88d349b48cd321ea183f933d"><li>近期需要频繁访问的短期热数据</li></ul><ul class="notion-list notion-list-disc notion-block-d51f46b186184f60971be1e4f1b4a84c"><li>可能会存在较长时间的冷数据</li></ul><div class="notion-text notion-block-ea3ea48573b14580912e18fdf355f83e">从原理上来说，热、冷数据应该分别存放到块存储和对象存储中，类似上面提到的 Phlare 方案，而不是一股脑放到块存储（Pyroscope OSS 的做法）或者全部放到对象存储（好像也没人这么做）。</div><div class="notion-text notion-block-4e155dd05728429dbb54cf449f36f32a">即使 Phlare 的方案看起来很合理，但它依旧是内嵌型存储，目前还没有一个比较成熟的分布式 DBMS 支持这样的特性。Pyroscope 在其云服务中也放弃了原来的内嵌式 K-V 存储，而转向了借用 Parquet 的分布式存储 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/tempo">Tempo </a>方案（来自其 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://pyroscope.io/blog/introducing-pyroscope-cloud/#pyroscope-clouds-major-scaling-improvements">blog</a>），在保证后端存储针对性优化的同时，利用类似 Thanos objstore 的方案实现了利用对象存储的扩展能力，遗憾的是尚未将这部分代码开源，也无法研究其内部细节了。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-61ca23ded6ce4926892710f5dc7049d9" data-id="61ca23ded6ce4926892710f5dc7049d9"><span><div id="61ca23ded6ce4926892710f5dc7049d9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#61ca23ded6ce4926892710f5dc7049d9" title="eBPF vs Native Language Tools"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">eBPF vs N<b>ative Language Tools</b></span></span></h3><div class="notion-text notion-block-c74106429e6746d48c0d243219f77262">Profier 是 Profiling 数据来源的基础，上述不少产品中都采用了 eBPF 作为采集方案，那么是否只要使用了 eBPF 就代表着开销更小、数据更全呢？并不全是，Pyroscope 的<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://pyroscope.io/blog/ebpf-profiling-pros-cons/">这篇 blog</a> 给了我们一个比较客观的对比。首先从数据来源的层级来看，可以将 Profiler 分为两类：</div><ul class="notion-list notion-list-disc notion-block-2486291cacb54336a7b3d00c59ba61bb"><li>用户态: 流行的性能分析工具，如pprof，async-profiler，rbspy，py-spy，pprof-rs，dotnet-trace等，都在这个层面上运行。</li></ul><ul class="notion-list notion-list-disc notion-block-cc608e8d11a94510b0d85765738cc08d"><li>内核态: 基于 eBPF 的各种 Profiler 封装和 Linux perf 工具可以从内核获取整个系统的堆栈跟踪</li></ul><div class="notion-text notion-block-27b555bb81b74efbbbd319ee0956c182">由于数据来源的层级不同，它们各有长短。</div><div class="notion-text notion-block-a21e473e284143dc8f1e21e7f2898bce">对于用户态的工具而言：</div><ul class="notion-list notion-list-disc notion-block-e5f17aa7468e4e4cb1bd067e98010fb1"><li>可以非常灵活的标记用户的应用代码（例如 标记 spans, controllers, functions）👍</li></ul><ul class="notion-list notion-list-disc notion-block-60e8ba7403374f2f95b23dd1deda2d43"><li>能够分析代码的各个特定部分（例如 Lambda 函数、测试套件、脚本）👍</li></ul><ul class="notion-list notion-list-disc notion-block-6d8c92280f8c4f2c858252cceb2330cd"><li>有着更容易分析其他类型数据的能力（例如内存、goroutines）👍</li></ul><ul class="notion-list notion-list-disc notion-block-7185f4e5505040a9b70cbc9b6d0586b4"><li>本地开发十分便捷，容易使用 👍</li></ul><ul class="notion-list notion-list-disc notion-block-14f40af546844a22b9581691963d3dff"><li>复杂，如果一个系统是多语言的，很难获取一个全局视图 👎</li></ul><ul class="notion-list notion-list-disc notion-block-83f7faf9e12a46288737717d197ad0ca"><li>对于基建元信息的标识能力有限（例如 Kubernetes） 👎</li></ul><div class="notion-text notion-block-79a3017bebf8405b8f0be94e1d92e4be">对于内核态的工具而言：</div><ul class="notion-list notion-list-disc notion-block-1f1d13c96ca2484a8e078597707b2475"><li>非常容易就能获取到跨语言的全局视图 👍</li></ul><ul class="notion-list notion-list-disc notion-block-26ab1028fe7249a4a9e6504e3bf3c352"><li>很容易对基建元信息进行标识能力有限（例如 Kubernetes Pods） 👍</li></ul><ul class="notion-list notion-list-disc notion-block-f7463e7683aa4a21b51d345eac377ccc"><li>所有语言在符号化上都是一致的 👍</li></ul><ul class="notion-list notion-list-disc notion-block-19b0ebf4ad92472bb1fb6172b5f132bb"><li>对 Linux 内核版本有要求 👎</li></ul><ul class="notion-list notion-list-disc notion-block-a024146a8f434abca61e3ecbfa2e12a4"><li>用户层级的代码比较难标记 👎</li></ul><ul class="notion-list notion-list-disc notion-block-f6e331e183a04959bb90aae07cfbf1af"><li>内存、goroutines 很难获取对应数据 👎</li></ul><ul class="notion-list notion-list-disc notion-block-dd0cbd1001384d5d839250796d1e0c02"><li>开发者想在本地开发比较困难 👎</li></ul><ul class="notion-list notion-list-disc notion-block-4d8582b254cf4fc686ef241d0a9f906d"><li>解释器型的语言获取的信息较为有限 👎</li></ul><div class="notion-text notion-block-401e72b99a914b33b3e6ec8a90f21a9f">简单来说，这两种方案的方向是反的：自下而上和自上而下，它们的数据信息理应做到互相补充，现阶段仅有 Pyroscope 对它做了<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://pyroscope.io/blog/ebpf-profiling-pros-cons/#pyroscopes-solution-merge-ebpf-profiling-and-native-language-profiling">有限的整合优化</a>，需要进一步关注进展。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f9474cb377364a1faa740d5276deb613" data-id="f9474cb377364a1faa740d5276deb613"><span><div id="f9474cb377364a1faa740d5276deb613" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f9474cb377364a1faa740d5276deb613" title="pprof vs OT"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">pprof vs OT</span></span></h3><div class="notion-text notion-block-23659b2844e64076bc6ed9707a300a32">pprof 本身是一个开源的性能分析工具套件，它可以抓取并组装 CPU、内存、goroutine 等性能数据，并且通过配套的工具可以生成各种可视化视图，例如火焰图、调用图等。</div><div class="notion-text notion-block-75537ccbfc254c6bb85a51b392657ed4">同时 pprof 也定义了相关的 Profile 数据格式，<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/google/pprof/blob/main/proto/profile.proto">以 Protocol Buffers 呈现</a>。它由一系列的记录 Sample 组成：包含了函数调用堆栈以及相应的计数器值。</div><div class="notion-text notion-block-80509e2702df445ba67615834a7e3a04">以下讨论的 pprof 指的是<b>其代表的数据格式。</b></div><div class="notion-text notion-block-08845340169643afa381ddd55b7ec206">可以通过<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/DataDog/go-profiler-notes/blob/18fd7f410e681d4b43c9afb403a4bdf23af29f99/examples/cpu/pprof.samples.cpu.001.pprof.txt#L1">它的文本表达示例</a>或者下面这张图理解其中的关联关系（除了 Stacktrace 是额外抽象出来的中间表）</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-5e17dafb13e44533b6adeb6703c1e3e1"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fa436eddf-7b62-4cff-b8ed-d0b14037d1ca%2FUntitled.png%3Fid%3D5e17dafb-13e4-4533-b6ad-eb6703c1e3e1%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DfwFMy1S4bW1ZCpa9YQov9dmhRMquMbYqPsxFofFVLYQ?table=block&amp;id=5e17dafb-13e4-4533-b6ad-eb6703c1e3e1&amp;cache=v2" loading="lazy" alt="基本对齐 pprof 模型的列存数据表，来自 Phlare" decoding="async"/><figcaption class="notion-asset-caption">基本对齐 pprof 模型的列存数据表，来自 Phlare</figcaption></div></figure><div class="notion-text notion-block-1ebdfc01fc724957a1b66a2fd72a5c18">pprof 在设计上是跨语言的，它理应成为一个跨语言标准，但受限于历史的进程，大多数语言的采集工具比它的历史更久，各种工具和采集链已经较为成熟，所以，除了 Go 语言有着极好的 pprof 支持，其他语言都没有成熟的 pprof 格式转换方案（例如<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/timpalpant/pypprof"> Python 虽然有，但缺乏维护</a>）。这中间的沟壑既给了 Pyroscope 较多的对接工作量，也给 OT 的标准化留足了空间。</div><div class="notion-text notion-block-95b44f9d6fbd4bf59f4830ddf1943ab1">Open Telemetry <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/open-telemetry/oteps/blob/main/text/profiles/0212-profiling-vision.md">预期将 Profiling 格式做一个标准化</a>，包括了非常多的工作内容：</div><ul class="notion-list notion-list-disc notion-block-375bd97f20a8429a8707024d6ad2b625"><li>尽可能多兼容各种 Profiling 格式</li></ul><ul class="notion-list notion-list-disc notion-block-ce3ccec35cfd4635b51f7297c06ed255"><li>应尽可能高效地传输分析数据，并且制定一个无损的 Profiling 模型，重点在于解析、转码（与其他格式之间的转换）和分析的效率上</li></ul><ul class="notion-list notion-list-disc notion-block-bc9095b196c24f18acb8fba2a90aa6d3"><li>应该可以清晰地映射到标准数据模型（例如 collapsed、pprof、JFR 等）</li></ul><ul class="notion-list notion-list-disc notion-block-71b30cb94448430192956a7417b3b987"><li>应该包含表示其他 OT Signal 之间关系的机制（例如 span 中的调用链）</li></ul><ul class="notion-list notion-list-disc notion-block-af7918c09ff14612a1d645f8f93f5e2d"><li>对于已经流行的 Profiler，保持尽可能小的转换开销</li></ul><div class="notion-text notion-block-54325062d698464f80e678ac3943769a">OT 的愿景是非常美好的，但从可观察的<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/open-telemetry/opentelemetry-profiling">进展</a>来说，并不是非常顺利，至少距离上一次有效的更新已经过了几个月了。<b>所以，现阶段在没有 OT 标准化格式之前，pprof 仍旧是 Profiling 数据格式为数不多的选择。</b></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-e6f5bc4ccbe141c492231597ed30f5d1" data-id="e6f5bc4ccbe141c492231597ed30f5d1"><span><div id="e6f5bc4ccbe141c492231597ed30f5d1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e6f5bc4ccbe141c492231597ed30f5d1" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h2><div class="notion-text notion-block-6bbef891e4134069867bd3006d522efe">Continuous Profiling 是一个不新不旧的领域，有着不大不小的市场，伴随着可观测领域常见的问题。在 OT 标准化前，Pyroscope 算是领先了一个身位，但各产品仍处于百舸争流的阶段，需要 Continuous Focusing 。</div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[开发散文：使用 Python 以 UDP 协议发送 Prometheus 指标数据]]></title>
            <link>https://next.emergencyexit.xyz//python-udp-prom-aggregation-gateway</link>
            <guid>https://next.emergencyexit.xyz//python-udp-prom-aggregation-gateway</guid>
            <pubDate>Fri, 11 Nov 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[形散神不散，记录开发思路]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-3dd5dfcc005c49b59cca96ccded25899"><div class="notion-viewport"></div><blockquote class="notion-quote notion-block-3aa324746d59444eb61271b45a85531b">开发散文：以开发为主题的散文。基本完整复现了从遇到问题、分析问题、找到解决思路、编码实现思路的全流程，顺带着记录一些浅薄的知识点。</blockquote><div class="notion-table-of-contents notion-gray notion-block-6055afb634904637b8f05312f7ca0072"><a href="#5487dbcbe73e4255a606e967662777f6" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">UDP 包是多大？</span></a><a href="#ae23c961f05f4780a92c3f39333b5c5d" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">如何在 Python 计算数据大小？</span></a><a href="#db1b2b487e2548ae9c7f72d98039630f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">getsizeof 的疑惑</span></a><a href="#9b98bfa140374c349f20d945c33151cf" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">简单点， len()</span></a><a href="#b67d18dde98c415195169381e2614077" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">如何对 Prometheus 指标数据切片？</span></a><a href="#7d02e06069c941e6a29c7efd5fe6cbff" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">开码！</span></a><a href="#75801b17238343418b9a4e78c445242b" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">首先定义模型</span></a><a href="#66f231e03f964a7abdfe0baeee193ec2" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">递归寻找切分点</span></a><a href="#5ba741df599d4a9b82254cdb1e72d0db" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">切！</span></a><a href="#56f26d8ed4a642df97523fb39e7d6c68" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">收尾</span></a><a href="#458980559b0448cb95b4daaf741a3bb3" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">效果</span></a><a href="#05e4e0b063114e1b9081cb6f912af2dc" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">尾声</span></a><a href="#91d69515071d461dad6229600df974c4" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">进一步优化？</span></a><a href="#73f4e961d953411cae20a13e623fad7e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">参考</span></a></div><div class="notion-text notion-block-2be67e4c21354ccea5fe57f4856bd26a">先简述一下需求背景：为了实现可观测性，产品中的一些指标数据需要推送到 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/weaveworks/prom-aggregation-gateway">Prometheus 聚合网关</a>，出于不想对主体服务有更多干扰的原则，项目选择使用 UDP 协议发送数据（也对聚合网关做了简单的 UDP 数据接收改造）。但是在运行过程中，<b><span class="notion-red">发现上报数据量偏少</span></b>，经过日志排查，在数据发送端瞧出了点端倪：</div><pre class="notion-code language-bash"><code class="language-bash"><span class="token literal-property property">error</span><span class="token operator">:</span> <span class="token punctuation">[</span>Errno <span class="token number">90</span><span class="token punctuation">]</span> Message too long</code></pre><div class="notion-text notion-block-c056d5e07bad44ec888b5e7a9c90b4ab">问题非常简单明晰：<b>单次请求发送的数据包大小超过了网络数据包的上限</b>。</div><div class="notion-text notion-block-acd12bd91bd04f8e9b60aa9357bcb8bd">那么就有了第一个问题：<span class="notion-yellow"><b>UDP 协议规定的包大小究竟是多少呢？</b></span></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-5487dbcbe73e4255a606e967662777f6" data-id="5487dbcbe73e4255a606e967662777f6"><span><div id="5487dbcbe73e4255a606e967662777f6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5487dbcbe73e4255a606e967662777f6" title="UDP 包是多大？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">UDP 包是多大？</span></span></h3><div class="notion-text notion-block-949046901e7c435cab5cb1dca604fef4">先来看一下 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.ietf.org/rfc/rfc768.txt">UDP 协议</a> 的包长什么样子：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-3f9be8e5e7a04f06a8e28796d72822c1"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5443128d-3b3b-41b5-8761-7744128d4af8%2FUntitled.png?table=block&amp;id=3f9be8e5-e7a0-4f06-a8e2-8796d72822c1&amp;cache=v2" loading="lazy" alt="The UDP protocol header consists of 8 bytes of Protocol Control Information (PCI)" decoding="async"/><figcaption class="notion-asset-caption"><em>The UDP protocol header consists of 8 bytes of Protocol Control Information (PCI)</em></figcaption></div></figure><div class="notion-text notion-block-e13ff80581c649c2940c7582c2c11e31">如图所见，UDP 可能算是最简洁的传输层协议之一了，包的组成非常简单易懂：</div><ul class="notion-list notion-list-disc notion-block-60096d253a62426bb8ae8b82ae435dc7"><li><b>Source Port：</b>包来源端口信息。</li></ul><ul class="notion-list notion-list-disc notion-block-5b2b85e9e656430a9c78b48c5a047e45"><li><b>Destination Port：</b>包目的端口信息。</li></ul><ul class="notion-list notion-list-disc notion-block-5cb9b141df9045029d80446ade8b87da"><li><b>UDP Length：</b>UDP 头信息+ Payload 的总长度。</li></ul><ul class="notion-list notion-list-disc notion-block-dfee2b503adc42959ec5e1ba091f73a0"><li><b>UDP Checksum：</b>包的校验和，避免在数据在传输中被污染。</li></ul><div class="notion-text notion-block-4dbe32ced84a4efe9d6574fcf13f2467">以上四个部分称之为协议控制信息 PCI，又称协议头，每个部分 2 bytes，一共占 8 bytes。</div><div class="notion-text notion-block-1a53eb8855a74863a5ec92a5cb8a24be">同时由于网络层的 IP 头也需要占据一部分空间，所以在计算 Payload 大小时需要先来看看 IP 层的情况。首先来看 IPv4：</div><pre class="notion-code language-plain text"><code class="language-plain text"># IPv4
<span class="token number">0xffff</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token constant">IP</span> Header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token constant">UDP</span> Header<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">65535</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">65507</span></code></pre><div class="notion-text notion-block-8f74c9299f88462d9b1d673c589f00bd">总的来说符合预期，在算上 IP 头的情况下，IPv4 UDP 包 Payload 最大不能超过 <b><span class="notion-teal">65507 bytes。</span></b></div><div class="notion-text notion-block-803b9eeaa0a54208ab5a5563ebfb9345">但是在 IPv6 的情况有了一点点复杂：由于 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://datatracker.ietf.org/doc/html/rfc2675">Jumbogram</a>（超大包） 的存在，超过 65535 bytes 的包是可以在调整过 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">MTU</a> 的节点中传输的，所以理论上的最大体积为：</div><pre class="notion-code language-plain text"><code class="language-plain text"># IPv6
<span class="token number">0xffff</span> <span class="token operator">-</span> <span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token constant">UDP</span> Header<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">65535</span><span class="token operator">-</span><span class="token number">8</span> <span class="token operator">=</span> <span class="token number">65527</span></code></pre><div class="notion-text notion-block-1e0435c4d5864df7ae84246c473eb4e2">也就是在你的基建完全支持 IPv6 并且能够设置超大 MTU 时，IPv6 UDP 包 Payload 包最大不能超过 <b><span class="notion-teal">65527 bytes。</span></b></div><div class="notion-callout notion-gray_background_co notion-block-78d076e9d06449c2941e5bb93730b7a4"><span class="notion-page-icon" role="img" aria-label="⚠️">⚠️</span><div class="notion-callout-text">注意：不同操作系统限值也可能会不同，例如 macOS 下最大包默认值为 9216 bytes。本文仅从协议角度讨论。</div></div><div class="notion-text notion-block-ecb053b3b0374038b2bc161b24b50901">以上分析的都是理论最大值，而在真实传输中，如果想尽可能保证 UDP 包的安全，不得不考虑 MTU 在其中的影响：当数据包大小比 MTU 值大的越多，传输时被切分的段数就越多，由于 UDP 本身协议的不可靠性，数据包的安全性就越低。</div><div class="notion-text notion-block-f0bd74013ace4c6ca827f04448b26c29">而 MTU 的最小值为 576 bytes，在 IPv4 的情况下，减去上面提到的 IP Header 和 UDP Header ，还剩下 <b><span class="notion-red">548 bytes</span></b> 。这也是为什么很多公网服务都会限制 UDP 包的最大不能超过 512 bytes （例如 DNS）。同时在 IP Options 存在的情况，IP Header 可能会占据 60 bytes。所以，如果你的 UDP 包想要<b><em>穿越复杂的公网</em></b>，最安全的最大值是 <span class="notion-red"><b>508 bytes</b></span>。</div><div class="notion-text notion-block-c32e0712b5a1440db082f7ced0894624">考虑当前面对的网络环境——接发双方都处于同一个容器集群内，属于没有太多干扰的私有网络——<b>可以酌情适当加大限制，只要小于 65507 bytes 即可</b>。</div><div class="notion-text notion-block-79f8ec24afdd444d8e5090a43b3d2bb5">搞清楚了最大能发送多少数据，自然会想<b>将超限的数据进行切片处理，</b>那么迎来了第二个问题：<span class="notion-yellow"><b>如何在 Python 计算数据大小？</b></span></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-ae23c961f05f4780a92c3f39333b5c5d" data-id="ae23c961f05f4780a92c3f39333b5c5d"><span><div id="ae23c961f05f4780a92c3f39333b5c5d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ae23c961f05f4780a92c3f39333b5c5d" title="如何在 Python 计算数据大小？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">如何在 Python 计算数据大小？</span></span></h3><div class="notion-text notion-block-377bdb352eb24bb0945f005eae892d44">我的第一反应是使用 <code class="notion-inline-code">getsizeof</code> ，虽然稍有经验的 Python 程序员会想到，它对于<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://code.activestate.com/recipes/577504/">容器类的对象是没法精准统计的</a>，好在当前场景里只是用来统计 bytes，并没有这个困扰。</div><div class="notion-text notion-block-0b6e0e86b8a141ca8c22137ca78b099c">但简单测试了一下，却发现了新的疑惑。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-db1b2b487e2548ae9c7f72d98039630f" data-id="db1b2b487e2548ae9c7f72d98039630f"><span><div id="db1b2b487e2548ae9c7f72d98039630f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#db1b2b487e2548ae9c7f72d98039630f" title="getsizeof 的疑惑"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><code class="notion-inline-code">getsizeof</code> 的疑惑</span></span></h4><pre class="notion-code language-python"><code class="language-python">from sys <span class="token keyword">import</span> getsizeof

<span class="token function">getsizeof</span><span class="token punctuation">(</span>b<span class="token string">""</span><span class="token punctuation">)</span>        👉 <span class="token number">33</span>
<span class="token function">getsizeof</span><span class="token punctuation">(</span>b<span class="token string">"abcd"</span><span class="token punctuation">)</span>    👉 <span class="token number">37</span></code></pre><div class="notion-text notion-block-0bf58ff0d9a44a0bb5e7fc0e04bf78ac">有意思的是，就算空 bytes，为什么也有 33 bytes 的空间占用？稍有经验的程序员就能立马反应过来，这就是对象本身的大小，一窥 Python 内置数据类型的大小（64-bit Python 3.6）：</div><pre class="notion-code language-python"><code class="language-python">Empty
Bytes  type        scaling notes
<span class="token number">28</span>     int         <span class="token operator">+</span><span class="token number">4</span> bytes about every <span class="token number">30</span> powers <span class="token keyword">of</span> <span class="token number">2</span>
<span class="token number">37</span>     bytes       <span class="token operator">+</span><span class="token number">1</span> byte per additional byte
<span class="token number">49</span>     str         <span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">4</span> per additional <span class="token function">character</span> <span class="token punctuation">(</span>depending on max width<span class="token punctuation">)</span>
<span class="token number">48</span>     tuple       <span class="token operator">+</span><span class="token number">8</span> per additional item
<span class="token number">64</span>     list        <span class="token operator">+</span><span class="token number">8</span> <span class="token keyword">for</span> each additional
<span class="token number">224</span>    <span class="token keyword">set</span>         5th increases to <span class="token number">736</span><span class="token punctuation">;</span> 21nd<span class="token punctuation">,</span> <span class="token number">2272</span><span class="token punctuation">;</span> 85th<span class="token punctuation">,</span> <span class="token number">8416</span><span class="token punctuation">;</span> <span class="token number">341</span><span class="token punctuation">,</span> <span class="token number">32992</span>
<span class="token number">240</span>    dict        6th increases to <span class="token number">368</span><span class="token punctuation">;</span> 22nd<span class="token punctuation">,</span> <span class="token number">1184</span><span class="token punctuation">;</span> 43rd<span class="token punctuation">,</span> <span class="token number">2280</span><span class="token punctuation">;</span> 86th<span class="token punctuation">,</span> <span class="token number">4704</span><span class="token punctuation">;</span> 171st<span class="token punctuation">,</span> <span class="token number">9320</span>
<span class="token number">136</span>    func def    does not include <span class="token keyword">default</span> args and other attrs
<span class="token number">1056</span>   <span class="token keyword">class</span> <span class="token class-name">def</span>   no slots 
<span class="token number">56</span>     <span class="token keyword">class</span> <span class="token class-name">inst</span>  has a __dict__ attr<span class="token punctuation">,</span> same scaling <span class="token keyword">as</span> dict above
<span class="token number">888</span>    <span class="token keyword">class</span> <span class="token class-name">def</span>   <span class="token keyword">with</span> slots
<span class="token number">16</span>     __slots__   seems to store <span class="token keyword">in</span> mutable tuple<span class="token operator">-</span>like structure
                   first slot grows to <span class="token number">48</span><span class="token punctuation">,</span> and so on<span class="token punctuation">.</span></code></pre><div class="notion-text notion-block-07b97df3d82c42dbb809b46d1e8468ac">虽然我们在代码中传入的是对象，但实际上传输的数据需要刨除语言附加的存储空间，所以不能通过 <code class="notion-inline-code">getsizeof</code> 拿到的数据本身的大小，这算是一条走错的思路 xD。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-9b98bfa140374c349f20d945c33151cf" data-id="9b98bfa140374c349f20d945c33151cf"><span><div id="9b98bfa140374c349f20d945c33151cf" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9b98bfa140374c349f20d945c33151cf" title="简单点， len()"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">简单点， <code class="notion-inline-code">len()</code></span></span></h4><div class="notion-text notion-block-345fd26989864fcba6b488a6b4a2dfa6">让我们回到问题本身，对于 bytes 数据，最简单统计大小的方式就是直接使用 <code class="notion-inline-code">len()</code> 。</div><pre class="notion-code language-python"><code class="language-python"><span class="token literal-property property">big_bytes</span><span class="token operator">:</span> bytes
size <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>big_bytes<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-d6cd5738d9084b3c86482af69cf19e21">确定了如何计算数据大小，下一步的思路就是：<span class="notion-yellow"><b>如何对 Prometheus 指标数据切片？</b></span></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-b67d18dde98c415195169381e2614077" data-id="b67d18dde98c415195169381e2614077"><span><div id="b67d18dde98c415195169381e2614077" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b67d18dde98c415195169381e2614077" title="如何对 Prometheus 指标数据切片？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">如何对 Prometheus 指标数据切片？</span></span></h3><div class="notion-text notion-block-c516ed34b62745639d72b6dc0f3d503d">正如标题提到的， UDP 传输的是 Prometheus 的指标数据，它是由一个有字面值的字符串转换而来的二进制，它还是字符串的时候一般长这样：</div><pre class="notion-code language-plain text"><code class="language-plain text"># <span class="token constant">HELP</span> sample_metric_foo_count 示例解释
# <span class="token constant">TYPE</span> sample_metric_foo_count gauge
sample_metric_foo_count<span class="token punctuation">{</span>foo<span class="token operator">=</span><span class="token string">"aa"</span><span class="token punctuation">,</span>bar<span class="token operator">=</span><span class="token string">"bb"</span><span class="token punctuation">}</span> <span class="token number">14.0</span>
sample_metric_foo_count<span class="token punctuation">{</span>foo<span class="token operator">=</span><span class="token string">"cc"</span><span class="token punctuation">,</span>bar<span class="token operator">=</span><span class="token string">"dd"</span><span class="token punctuation">}</span> <span class="token number">27.0</span>
sample_metric_foo_count<span class="token punctuation">{</span>foo<span class="token operator">=</span><span class="token string">"ee"</span><span class="token punctuation">,</span>bar<span class="token operator">=</span><span class="token string">"ff"</span><span class="token punctuation">}</span> <span class="token number">12.0</span>

# <span class="token constant">HELP</span> sample_metric_bar_count 示例解释
# <span class="token constant">TYPE</span> sample_metric_bar_count gauge
sample_metric_bar_count<span class="token punctuation">{</span>baz<span class="token operator">=</span><span class="token string">"gg"</span><span class="token punctuation">}</span> <span class="token number">660.0</span>
sample_metric_bar_count<span class="token punctuation">{</span>baz<span class="token operator">=</span><span class="token string">"hh"</span><span class="token punctuation">}</span> <span class="token number">660.0</span></code></pre><div class="notion-text notion-block-e2eae7b4510249bdbfd982229e1082e0">它本身需要符合一定的<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://prometheus.io/docs/concepts/data_model/">格式</a>， <code class="notion-inline-code">#</code> 开头的两行作为指标信息的元信息，</div><pre class="notion-code language-python"><code class="language-python"># <span class="token constant">HELP</span> sample_metric_foo_count 示例解释
# <span class="token constant">TYPE</span> sample_metric_foo_count gauge</code></pre><div class="notion-text notion-block-6d0d7fa7602347778c9886ca19110564">可以先看看 Prometheus 是<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/prometheus/common/blob/8c9cb3fa6d01832ea16937b20ea561eed81abd2f/expfmt/text_parse.go#L142">如何解析它的</a>：</div><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// 以下为摘抄内容</span>
<span class="token function">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>TextParser<span class="token punctuation">)</span> <span class="token function">startOfLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> stateFn <span class="token punctuation">{</span>
  <span class="token operator">...</span>
	<span class="token keyword">switch</span> p<span class="token punctuation">.</span>currentByte <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token string">'#'</span><span class="token operator">:</span>
		<span class="token keyword">return</span> p<span class="token punctuation">.</span>startComment
	<span class="token keyword">case</span> <span class="token string">'\n'</span><span class="token operator">:</span>
		<span class="token keyword">return</span> p<span class="token punctuation">.</span>startOfLine <span class="token comment">// Empty line, start the next one.</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> p<span class="token punctuation">.</span>readingMetricName
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>TextParser<span class="token punctuation">)</span> <span class="token function">startComment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> stateFn <span class="token punctuation">{</span>
  <span class="token operator">...</span>
	<span class="token literal-property property">keyword</span> <span class="token operator">:</span><span class="token operator">=</span> p<span class="token punctuation">.</span>currentToken<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> keyword <span class="token operator">!=</span> <span class="token string">"HELP"</span> <span class="token operator">&amp;&amp;</span> keyword <span class="token operator">!=</span> <span class="token string">"TYPE"</span> <span class="token punctuation">{</span>
		<span class="token comment">// Generic comment, ignore by fast forwarding to end of line.</span>
		<span class="token keyword">for</span> p<span class="token punctuation">.</span>currentByte <span class="token operator">!=</span> <span class="token string">'\n'</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> p<span class="token punctuation">.</span>currentByte<span class="token punctuation">,</span> p<span class="token punctuation">.</span>err <span class="token operator">=</span> p<span class="token punctuation">.</span>buf<span class="token punctuation">.</span><span class="token function">ReadByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token punctuation">.</span>err <span class="token operator">!=</span> nil <span class="token punctuation">{</span>
				<span class="token keyword">return</span> nil <span class="token comment">// Unexpected end of input.</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> p<span class="token punctuation">.</span>startOfLine
	<span class="token punctuation">}</span>
	<span class="token operator">...</span>
	<span class="token keyword">switch</span> keyword <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token string">"HELP"</span><span class="token operator">:</span>
		<span class="token keyword">return</span> p<span class="token punctuation">.</span>readingHelp
	<span class="token keyword">case</span> <span class="token string">"TYPE"</span><span class="token operator">:</span>
		<span class="token keyword">return</span> p<span class="token punctuation">.</span>readingType
	<span class="token punctuation">}</span>
	<span class="token function">panic</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"code error: unexpected keyword %q"</span><span class="token punctuation">,</span> keyword<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-e75fff1bacda4ed082721e74809d3b5e">可以看到：如果直接粗暴地切分会导致接收端无法解析从而丢弃整个请求数据。所以需要针对数据的开头和结尾特征值来决定具体的切分点。</div><pre class="notion-code language-plain text"><code class="language-plain text"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> # <span class="token constant">HELP</span> 作为开头，尽量作为数据包的开头 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
# <span class="token constant">HELP</span> sample_metric_foo_count 示例解释
# <span class="token constant">TYPE</span> sample_metric_foo_count gauge
sample_metric_foo_count<span class="token punctuation">{</span>foo<span class="token operator">=</span><span class="token string">"aa"</span><span class="token punctuation">,</span>bar<span class="token operator">=</span><span class="token string">"bb"</span><span class="token punctuation">}</span> <span class="token number">14.0</span>
sample_metric_foo_count<span class="token punctuation">{</span>foo<span class="token operator">=</span><span class="token string">"cc"</span><span class="token punctuation">,</span>bar<span class="token operator">=</span><span class="token string">"dd"</span><span class="token punctuation">}</span> <span class="token number">27.0</span>
sample_metric_foo_count<span class="token punctuation">{</span>foo<span class="token operator">=</span><span class="token string">"ee"</span><span class="token punctuation">,</span>bar<span class="token operator">=</span><span class="token string">"ff"</span><span class="token punctuation">}</span> <span class="token number">12.0</span>

# <span class="token constant">HELP</span> sample_metric_bar_count 示例解释
# <span class="token constant">TYPE</span> sample_metric_bar_count gauge
sample_metric_bar_count<span class="token punctuation">{</span>baz<span class="token operator">=</span><span class="token string">"gg"</span><span class="token punctuation">}</span> <span class="token number">660.0</span>\n
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> \n 作为单行数据结尾，能够保证包数据被正常解析，最差情况作为数据包的结尾 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
sample_metric_bar_count<span class="token punctuation">{</span>baz<span class="token operator">=</span><span class="token string">"hh"</span><span class="token punctuation">}</span> <span class="token number">660.0</span>  由于缺少 <span class="token constant">HELP</span><span class="token operator">/</span><span class="token constant">TYPE</span> 元信息，将无法被聚合处理</code></pre><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-7d02e06069c941e6a29c7efd5fe6cbff" data-id="7d02e06069c941e6a29c7efd5fe6cbff"><span><div id="7d02e06069c941e6a29c7efd5fe6cbff" class="notion-header-anchor"></div><a class="notion-hash-link" href="#7d02e06069c941e6a29c7efd5fe6cbff" title="开码！"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">开码！</span></span></h3><div class="notion-text notion-block-2ec98a98ed394b4d8717392adf3a6d51">既然准备好了思路，那么就开始正式编码吧。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-75801b17238343418b9a4e78c445242b" data-id="75801b17238343418b9a4e78c445242b"><span><div id="75801b17238343418b9a4e78c445242b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#75801b17238343418b9a4e78c445242b" title="首先定义模型"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">首先定义模型</span></span></h4><div class="notion-text notion-block-e4c19888dcc0454bad31beae9110fd8b">好的模型能够清楚地展示编码思路，为了更方便切分定义了如下模型：</div><pre class="notion-code language-python"><code class="language-python">@dataclass
<span class="token keyword">class</span> <span class="token class-name">SlicedIndex</span><span class="token operator">:</span>
    <span class="token string">""</span><span class="token string">"数据切分索引"</span><span class="token string">""</span>
    <span class="token literal-property property">start</span><span class="token operator">:</span> int
    <span class="token literal-property property">end</span><span class="token operator">:</span> int
    # 如果不是以 # <span class="token constant">HELP</span> 开头，会导致 metric 无法被识别合并
    <span class="token literal-property property">valid_start</span><span class="token operator">:</span> bool <span class="token operator">=</span> True
    # 如果不是以 metric 内容完结，会让下一个分片包没有有效开头
    <span class="token literal-property property">valid_end</span><span class="token operator">:</span> bool <span class="token operator">=</span> True

    def <span class="token function">to_tuple</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> tuple<span class="token operator">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>start<span class="token punctuation">,</span> self<span class="token punctuation">.</span>end

    def <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>end <span class="token operator">-</span> self<span class="token punctuation">.</span>start


@dataclass
<span class="token keyword">class</span> <span class="token class-name">SlicedIndexList</span><span class="token operator">:</span>
    <span class="token literal-property property">indexes</span><span class="token operator">:</span> List<span class="token punctuation">[</span>SlicedIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">field</span><span class="token punctuation">(</span>default_factory<span class="token operator">=</span>list<span class="token punctuation">)</span>

    def <span class="token function">append</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token literal-property property">start</span><span class="token operator">:</span> int<span class="token punctuation">,</span> <span class="token literal-property property">end</span><span class="token operator">:</span> int<span class="token punctuation">,</span> <span class="token literal-property property">valid_end</span><span class="token operator">:</span> bool <span class="token operator">=</span> True<span class="token punctuation">)</span><span class="token operator">:</span>
        valid_start <span class="token operator">=</span> True
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>indexes and not self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>valid_end<span class="token operator">:</span>
            valid_start <span class="token operator">=</span> False

        self<span class="token punctuation">.</span>indexes<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token function">SlicedIndex</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> valid_start<span class="token punctuation">,</span> valid_end<span class="token punctuation">)</span><span class="token punctuation">)</span>

    def <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token keyword">for</span> elem <span class="token keyword">in</span> self<span class="token punctuation">.</span>indexes<span class="token operator">:</span>
            <span class="token keyword">yield</span> elem

    def <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ii<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token string">""</span><span class="token string">"Get a list item"</span><span class="token string">""</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>ii<span class="token punctuation">]</span></code></pre><div class="notion-text notion-block-b0e4940f7fb84cc583211d354c7912c8">由于网络环境较为良好，这里更倾向于单次尽可能提交足够多的数据而减少网络发送次数。所以尽量贴近最大限制做数据切分，由于每次查找逻辑类同，采用递归会更简单。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-66f231e03f964a7abdfe0baeee193ec2" data-id="66f231e03f964a7abdfe0baeee193ec2"><span><div id="66f231e03f964a7abdfe0baeee193ec2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#66f231e03f964a7abdfe0baeee193ec2" title="递归寻找切分点"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">递归寻找切分点</span></span></h4><pre class="notion-code language-python"><code class="language-python">def <span class="token function">find_sliced_indexes</span><span class="token punctuation">(</span>data<span class="token operator">:</span> bytes<span class="token punctuation">,</span> <span class="token literal-property property">start</span><span class="token operator">:</span> int<span class="token punctuation">,</span> <span class="token literal-property property">udp_package_max_size</span><span class="token operator">:</span> int<span class="token punctuation">,</span> <span class="token literal-property property">sliced_index_list</span><span class="token operator">:</span> SlicedIndexList<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token string">""</span><span class="token string">"递归找寻指标开头标志"</span><span class="token string">""</span>
    <span class="token keyword">if</span> start <span class="token operator">+</span> udp_package_max_size <span class="token operator">>=</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">:</span>
        sliced_index_list<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>

    valid_start_index <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">rfind</span><span class="token punctuation">(</span>b<span class="token string">"# HELP"</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> start <span class="token operator">+</span> udp_package_max_size<span class="token punctuation">)</span>
    <span class="token keyword">if</span> valid_start_index <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> or valid_start_index <span class="token operator">==</span> start<span class="token operator">:</span>
        # 当某个 metrics 数据大小大于 <span class="token constant">UDP</span> 协议最大包限制时，原则上我们无法通过 <span class="token constant">UDP</span> 发送该数据
        # 但这里我们尝试以最大限制发送该数据，以一个超过最大限制的数据为例
        # <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> 协议最大长度
        # <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
        # 有效            <span class="token function">有效</span>  <span class="token punctuation">(</span>缺失元信息部分丢弃<span class="token punctuation">)</span> 有效  有效              有效
        # 可以看到中间段数据会被丢弃，因为没有有效的 metrics 开头，但是我们尽可能保证了后续的包是有效开头和有效结尾
        # 所以当前的做法更利于我们单 metrics 数据比 <span class="token number">65535</span> 稍大的场景，这样丢弃的内容少，保留的内容多
        # 反之，当单个 metrics 的数据比最大限制大的越多，丢弃的越多

        # sample 肯定会转行，只要有转行就能保证起码前一个包的内容格式有效
        valid_end_index <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">rfind</span><span class="token punctuation">(</span>b<span class="token string">"\n"</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> start <span class="token operator">+</span> udp_package_max_size<span class="token punctuation">)</span>
        new_start <span class="token operator">=</span> valid_end_index <span class="token operator">+</span> <span class="token number">1</span>
        sliced_index_list<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> new_start<span class="token punctuation">,</span> valid_end<span class="token operator">=</span>False<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token operator">:</span>
        sliced_index_list<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> valid_start_index<span class="token punctuation">)</span>
        new_start <span class="token operator">=</span> valid_start_index

    # 尝试继续向后查找
    <span class="token function">find_sliced_indexes</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> new_start<span class="token punctuation">,</span> udp_package_max_size<span class="token punctuation">,</span> sliced_index_list<span class="token punctuation">)</span>
    <span class="token keyword">return</span></code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-5ba741df599d4a9b82254cdb1e72d0db" data-id="5ba741df599d4a9b82254cdb1e72d0db"><span><div id="5ba741df599d4a9b82254cdb1e72d0db" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5ba741df599d4a9b82254cdb1e72d0db" title="切！"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">切！</span></span></h4><div class="notion-text notion-block-2c78da288e01456e8ea80ef5a485096c">当拿到了想要切入点后，就可以对原数据进行切分了。这里可以使用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.python.org/zh-cn/3/c-api/memoryview.html">memoryview</a>，节省一次大数据拷贝，切片的速度也会更快一点：</div><pre class="notion-code language-python"><code class="language-python">def <span class="token function">slice_metrics_udp_data</span><span class="token punctuation">(</span>data<span class="token operator">:</span> bytes<span class="token punctuation">,</span> <span class="token literal-property property">sliced_indexes</span><span class="token operator">:</span> SlicedIndexList<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Generator<span class="token punctuation">[</span>memoryview<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">]</span><span class="token operator">:</span>
    <span class="token string">""</span><span class="token string">"拆分 metrics UDP data"</span><span class="token string">""</span>
    # <span class="token constant">Q</span><span class="token operator">:</span> 为什么不直接切分<span class="token operator">?</span>
    # <span class="token constant">A</span><span class="token operator">:</span> 直接按照大小切分会降 bytes 中的字面值切断，让服务端对于指标无法理解，所以要按照字面值的内容做切分

    # memoryview 无需额外拷贝
    mview <span class="token operator">=</span> <span class="token function">memoryview</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token keyword">for</span> index <span class="token keyword">in</span> <span class="token literal-property property">sliced_indexes</span><span class="token operator">:</span>
        <span class="token keyword">if</span> not index<span class="token punctuation">.</span>valid_start<span class="token operator">:</span>
            logger<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">"data&lt;len:%s> has no valid start, may not be parsed"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span> mview<span class="token punctuation">[</span>index<span class="token punctuation">.</span>start <span class="token operator">:</span> index<span class="token punctuation">.</span>end<span class="token punctuation">]</span></code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-56f26d8ed4a642df97523fb39e7d6c68" data-id="56f26d8ed4a642df97523fb39e7d6c68"><span><div id="56f26d8ed4a642df97523fb39e7d6c68" class="notion-header-anchor"></div><a class="notion-hash-link" href="#56f26d8ed4a642df97523fb39e7d6c68" title="收尾"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">收尾</span></span></h4><div class="notion-text notion-block-122aac50d321402e858702653cb64287">针对一些特殊场景做最后的善后处理</div><pre class="notion-code language-python"><code class="language-python">def <span class="token function">find_udp_data_sliced_indexes</span><span class="token punctuation">(</span>data<span class="token operator">:</span> bytes<span class="token punctuation">,</span> <span class="token literal-property property">udp_package_max_size</span><span class="token operator">:</span> int <span class="token operator">=</span> <span class="token number">65507</span><span class="token punctuation">,</span> <span class="token literal-property property">mtu</span><span class="token operator">:</span> int <span class="token operator">=</span> <span class="token number">1500</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> SlicedIndexList<span class="token operator">:</span>
    <span class="token string">""</span>"对 <span class="token constant">UDP</span> <span class="token literal-property property">发送数据进行切片处理，保证每次发送成功</span>
    <span class="token operator">:</span>param data<span class="token operator">:</span> 预发送数据
    <span class="token operator">:</span>param udp_package_max_size<span class="token operator">:</span> 当前系统支持的最大 <span class="token constant">UDP</span> 发送包大小，以 bytes 计算，默认为 <span class="token number">65535</span> <span class="token punctuation">(</span>在 macOS 下默认为 <span class="token number">9126</span><span class="token punctuation">)</span>
    <span class="token operator">:</span>param mtu<span class="token operator">:</span> Maximum Transmission Unit

    udp_package_max_size <span class="token operator">=</span> <span class="token number">0xffff</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token constant">IP</span> Header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sizeof</span><span class="token punctuation">(</span><span class="token constant">UDP</span> Header<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">65535</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">65507</span>
    ref to<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>en<span class="token punctuation">.</span>wikipedia<span class="token punctuation">.</span>org<span class="token operator">/</span>wiki<span class="token operator">/</span>User_Datagram_Protocol
    <span class="token string">""</span>"
    length <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token keyword">if</span> length <span class="token operator">></span> mtu<span class="token operator">:</span>
        # <span class="token constant">TODO</span><span class="token operator">:</span> 当前我们暂不考虑处理 <span class="token constant">MTU</span> 的问题，先解决 <span class="token constant">UDP</span> 包过大的情况
        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"UDP packages is larger than MTU, not safe for single push."</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> length <span class="token operator">&lt;=</span> udp_package_max_size<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token function">SlicedIndexList</span><span class="token punctuation">(</span>indexes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token function">SlicedIndex</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    sliced_index_list <span class="token operator">=</span> <span class="token function">SlicedIndexList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token operator">:</span>
        <span class="token function">find_sliced_indexes</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> udp_package_max_size<span class="token punctuation">,</span> sliced_index_list<span class="token punctuation">)</span>
    except RecursionError<span class="token operator">:</span>
        logger<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">"data has no valid format, drop it..."</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> sliced_index_list</code></pre><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-458980559b0448cb95b4daaf741a3bb3" data-id="458980559b0448cb95b4daaf741a3bb3"><span><div id="458980559b0448cb95b4daaf741a3bb3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#458980559b0448cb95b4daaf741a3bb3" title="效果"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">效果</span></span></h4><pre class="notion-code language-python"><code class="language-python"># 原来的 <span class="token constant">UDP</span> 直接发送
# 将抛出 error<span class="token operator">:</span> <span class="token punctuation">[</span>Errno <span class="token number">90</span><span class="token punctuation">]</span> Message too long
udp_socket<span class="token punctuation">.</span><span class="token function">sendto</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>

# 循环调用 <span class="token constant">UDP</span> 请求
<span class="token keyword">for</span> sliced_data <span class="token keyword">in</span> <span class="token function">slice_metrics_udp_data</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token function">find_udp_data_sliced_indexes</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>
	  # 所有 <span class="token constant">UDP</span> 包都可以发送出去
    # 同时取决于数据特性，绝大多数的 <span class="token constant">UDP</span> 数据都能在服务端得到解析
    udp_socket<span class="token punctuation">.</span><span class="token function">sendto</span><span class="token punctuation">(</span>sliced_data<span class="token punctuation">,</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><div class="notion-blank notion-block-cc9839ec71544fca859bb2a5d393654f"> </div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-05e4e0b063114e1b9081cb6f912af2dc" data-id="05e4e0b063114e1b9081cb6f912af2dc"><span><div id="05e4e0b063114e1b9081cb6f912af2dc" class="notion-header-anchor"></div><a class="notion-hash-link" href="#05e4e0b063114e1b9081cb6f912af2dc" title="尾声"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">尾声</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-91d69515071d461dad6229600df974c4" data-id="91d69515071d461dad6229600df974c4"><span><div id="91d69515071d461dad6229600df974c4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#91d69515071d461dad6229600df974c4" title="进一步优化？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">进一步优化？</span></span></h4><div class="notion-text notion-block-cd36daaebf0b4627b5543b1c1f5b0b5d">正如我们上面实现的逻辑，仍旧无法保证所有数据都能被解析成功，主要的原因就是我们没有对缺失元信息的指标进行处理，而我们在解析其中内容的时候是可以通过 <code class="notion-inline-code">bytes.index()</code> 找到元信息位置的，可以将元信息暂存起来，在 <code class="notion-inline-code">valid_start</code> 时直接补充上去，这样就能保证所有数据都有合适的格式。</div><div class="notion-blank notion-block-0df3835b491f4a4da4285c30a7a9a702"> </div><div class="notion-text notion-block-364256dc3d344b519606336988bdc22c">Prometheus UDP 数据切分是一个在开发中普通的不能再普通的小问题。在这里写这么多并不是为了展现该问题本身的解决方案，而是用来描述一种完备的开发思路。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-73f4e961d953411cae20a13e623fad7e" data-id="73f4e961d953411cae20a13e623fad7e"><span><div id="73f4e961d953411cae20a13e623fad7e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#73f4e961d953411cae20a13e623fad7e" title="参考"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考</span></span></h4><ul class="notion-list notion-list-disc notion-block-830397c52a294702ae130f5d04b519fd"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.ietf.org/rfc/rfc768.txt">https://www.ietf.org/rfc/rfc768.txt</a></li></ul><ul class="notion-list notion-list-disc notion-block-fd3df686f5b043df85a23537d5ab1e82"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://erg.abdn.ac.uk/users/gorry/course/inet-pages/udp.html">https://erg.abdn.ac.uk/users/gorry/course/inet-pages/udp.html</a></li></ul><ul class="notion-list notion-list-disc notion-block-0e7afdae4077446d8acde3a365ef7310"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.rfc-editor.org/rfc/rfc2675.html">https://www.rfc-editor.org/rfc/rfc2675.html</a></li></ul><ul class="notion-list notion-list-disc notion-block-f4ecc82a58c8423eb92169c49f10e2f8"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://stackoverflow.com/questions/1098897/what-is-the-largest-safe-udp-packet-size-on-the-internet">https://stackoverflow.com/questions/1098897/what-is-the-largest-safe-udp-packet-size-on-the-internet</a></li></ul><ul class="notion-list notion-list-disc notion-block-6a59c5ca28614f0cad1801fc9a7e5abc"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python</a></li></ul><ul class="notion-list notion-list-disc notion-block-db259695817844739eee93f65fcb4234"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.python.org/zh-cn/3/c-api/memoryview.html">https://docs.python.org/zh-cn/3/c-api/memoryview.html</a></li></ul></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[从 奇思乱想 到 妙想天开]]></title>
            <link>https://next.emergencyexit.xyz//upgrade-blog</link>
            <guid>https://next.emergencyexit.xyz//upgrade-blog</guid>
            <pubDate>Thu, 20 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[打怪→获得经验→升级⤴️]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-0c0d5bfd8642460aaedc5a8277725196"><div class="notion-viewport"></div><div class="notion-text notion-block-9efc17fbe87e4de6ad5d5a5d436b1798">两年前我在 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://emergencyexit.xyz/use-notion-as-blog.html"><b><b>使用 Notion 搭建个人静态 Blog</b></b></a><b><b> </b></b>一文中描述了本博客站点的搭建方式，实现了个人博客 从零到一。随着这两年笔耕不辍，近二十篇水文陆续问世，对站点的功能有了更高的要求，于是决定对博客方案进行全新升级，也希望能从“奇思乱想“的水文时代，向”妙想天开“的高质量博客站点迈进。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-d392edb8b7d347e2888253c38532259a" data-id="d392edb8b7d347e2888253c38532259a"><span><div id="d392edb8b7d347e2888253c38532259a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d392edb8b7d347e2888253c38532259a" title="升级"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">升级</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-5c2185d8eed04a749ca5c7e185a1966d" data-id="5c2185d8eed04a749ca5c7e185a1966d"><span><div id="5c2185d8eed04a749ca5c7e185a1966d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5c2185d8eed04a749ca5c7e185a1966d" title="工具的局限"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">工具的局限</span></span></h4><div class="notion-text notion-block-d25f1d7885324fbcacb9a01f38f59d70">两年前工具选型时并未有太多的调研，看到 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/dragonman225/notablog">notablog</a> 渲染出的站点样式好看、功能基本能满足需求，就立马实施上马。经过这两年的体验，总结了一些该工具功能上的缺失：</div><ul class="notion-list notion-list-disc notion-block-f24064939e314b83be63aa0c3c608038"><li>缺少 RSS 支持</li></ul><ul class="notion-list notion-list-disc notion-block-a9a5d4316b40445688341d9c0da249c9"><li>不支持分页，文章越来越多，页面越来越长</li></ul><ul class="notion-list notion-list-disc notion-block-0e21fd7104274547a614fe080cbc763a"><li>不支持搜索，和分页类似，文章越多越不友好，我还想多写几篇</li></ul><ul class="notion-list notion-list-disc notion-block-55a32294c9854e6b974c811f91470100"><li>缺少持续的更新（例如不支持 Simple Table/Mermaid 等 Notion 新特性、Go 代码块样式异常）</li></ul><ul class="notion-list notion-list-disc notion-block-6f9d79ac53ca4f4798c2965411e1cacc"><li>缺少切换黑暗模式主题</li></ul><div class="notion-text notion-block-a1a63700fd6e4f7fa09d8ec8f66b5bfe">部分功能缺失<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/dragonman225/notablog/issues/created_by/IMBlues">我在 issue 中向作者提出了feature request</a> ，虽然都有回应，但也都束之高阁，很长时间都没见到开工的样子。</div><div class="notion-text notion-block-ed30d1362b6f49ac9039150d202bc0cd">于是我对其他 Notion 博客生成工具进行调研，表中列举了一些我关注的功能点（在这里更多考察的开箱即用的能力）</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-e7292203bcfc409388611eade09fdecd" data-id="e7292203bcfc409388611eade09fdecd"><span><div id="e7292203bcfc409388611eade09fdecd" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e7292203bcfc409388611eade09fdecd" title="其他 Notion 工具"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">其他 Notion 工具</span></span></h4><table class="notion-simple-table notion-block-63aec3fa6b3d4004946ea82835465111"><tbody><tr class="notion-simple-table-row notion-block-de185efa57014549a7f3bb61a9b3f33a"><td class="" style="width:96px"><div class="notion-simple-table-cell">名称</div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">概述</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">RSS</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">评论</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">分析</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">搜索</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">sitemap</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">黑暗模式</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">响应式</div></td></tr><tr class="notion-simple-table-row notion-block-668fd43e9c454083b10fa74afb1fa743"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/ijjk/notion-blog">Notion Blog</a> </div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">Next.js 维护者，Vercel 公司工程师开发</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-21834e4eabcc47259f69b4477b63487f"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/craigary/nobelium">Nobelium</a> </div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">和 notablog 类似的静态构建工具：功能支持更多，使用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://nextjs.org/">Next.js</a> 原生支持 Vercel</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-1c47c1a7fdb343e4b3b3f317b76761c0"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/tangly1024/NotionNext">NotionNext</a> </div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">在 Nobelium 的基础上支持了更多主题</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-6ccdd9d739274290b391e93964d28490"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/transitive-bullshit/nextjs-notion-starter-kit"><b><b>Next.js Notion Starter Kit</b></b></a></div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">非常完善的构建工具，支持全文搜索</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-52d0defa838c426790f77806c6f0cd07"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/samuelkraft/notion-blog-nextjs"><b>notion-blog-nextjs</b></a></div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">Next.js + Notion 原生 API</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-e1e67c6f70284b87803e3f190655f0d0"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/leoncvlt/loconotion">Loconotion</a> </div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">一个用 Python 编写的 Notion 静态页面生成器，与其他通过 Next.js 生成页面不同，它让 Notion 自己渲染，然后将页面抓取出来，理论上能最大程度上还原 Notion 的样式。默认并不能生成一个站点。</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">❌</div></td></tr></tbody></table><div class="notion-text notion-block-f7359f80c0984650974258fab805fbc1">经过功能的简单筛选，优胜的工具有三个：Nobelium \ NotionNext \ Next.js Notion Starter Kit。</div><div class="notion-text notion-block-27b2dd050f50487bbd89289f84ecb57e">个人更偏向于 Nobelium，原因如下：</div><ul class="notion-list notion-list-disc notion-block-bf3afcc36f9e41df9548422d169bef73"><li>默认支持的样式符合我的审美</li></ul><ul class="notion-list notion-list-disc notion-block-7e5100e1ec174961b1a82b3e3ea4698a"><li>在基本功能都支持的前提下，代码足够简单，作为后端开发我能够比较轻松的修改和维护</li></ul><div class="notion-text notion-block-10c836a08bca48b5a4678fe58f9986c2">另外两个工具：</div><ul class="notion-list notion-list-disc notion-block-6c1f111d6c41499ebde5f77a89afc546"><li>Next.js Notion Starter Kit 本身非常推荐，功能齐全，样式好看，比 Nobelium 稍微复杂一些，最大优势是仍旧在积极维护中。</li></ul><ul class="notion-list notion-list-disc notion-block-8d27c6597026432189cd00c01bf9071a"><li>NotionNext 支持了更多主题，是否足够好看见仁见智，有一些类似<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.tangly1024.com/zh/features/articleLock">“文章锁”</a>的功能用不上。</li></ul><div class="notion-text notion-block-956d2a2e4eb1414f8939102abc9bb71c">秉承着 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zen-of-python.info/simple-is-better-than-complex.html">Simple is better than complex</a> 的原则，“妙想天开” 将选用 Nobelium 作为生成工具。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-206c876337c24a27b17124de4f472c47" data-id="206c876337c24a27b17124de4f472c47"><span><div id="206c876337c24a27b17124de4f472c47" class="notion-header-anchor"></div><a class="notion-hash-link" href="#206c876337c24a27b17124de4f472c47" title="工具改造"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">工具改造</span></span></h4><div class="notion-text notion-block-d91cdbb7f16f464b9653147511dd5361">虽然 Nobelium 已经支持了我所有的需求，但我仍旧需要对它进行一些改造，因为它原生是面向 Vercel 部署构建的，而我想要一个纯静态站点部署在 Github Pages，而非 Next.js 所推崇的 SSR 服务端渲染。那么为啥不用 Vercel ？最直接的原因：墙。本身访问量就不多，进一步提高访问门槛只会更加门可罗雀。</div><div class="notion-text notion-block-33456e9e0f874fedaf7f8c534f28cea0">所以第一步就是如何通过 Action 将 Next.js 应用在 Github Pages 上。具体的做法可以参考<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://gregrickaby.com/2020/03/21/next-js-github-pages">这篇文章</a>和<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/gregrickaby/nextjs-github-pages">这个项目</a>。最后的效果就是，只需要将源码推到主分支，既可以自动执行 <code class="notion-inline-code">npm build</code> 和 <code class="notion-inline-code">npm export</code> 到 <code class="notion-inline-code">gh-pages</code> 分支，然后 Pages 相关配置使用 <code class="notion-inline-code">gh-pages</code> 即可。</div><div class="notion-text notion-block-9f3f2403e07a41c19d1fc13065ad6d02">同时又因为我将动态渲染改成了静态站点，其中一些 <code class="notion-inline-code">getserverSideProps</code> 动态部分（如 RSS）就需要改造成构建时生成，相关的步骤可以参考：</div><ul class="notion-list notion-list-disc notion-block-d414208fa6d343628e7277a716d9991f"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://dev.to/kendalmintcode/create-a-next-js-rss-feed-for-your-static-website-210p">https://dev.to/kendalmintcode/create-a-next-js-rss-feed-for-your-static-website-210p</a></li></ul><ul class="notion-list notion-list-disc notion-block-c916a7dccac74c12aba44c60a4c0930a"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://sreetamdas.com/blog/rss-for-nextjs">https://sreetamdas.com/blog/rss-for-nextjs</a></li></ul><div class="notion-text notion-block-7fff25642c254a8bb943ca5aedfbe548">也可以直接参考<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/IMBlues/nobelium">我已经改造好的项目</a>。</div><div class="notion-text notion-block-d74f07cfccc046e08d1b2e42ed218752">然后就可以开始对文章列表进行迁移了（完全手动的，一点点复制，还好写的文章不算特别多），其中有两点需要额外注意：</div><ul class="notion-list notion-list-disc notion-block-64ea5c50cdae47ef83b39cfabd0cfc37"><li>尽量保证原文的 URL 一致。由于 notablog 默认会在 slug 后面多加一个 <code class="notion-inline-code">.html</code> ，所以在新工具中旧文章的 <code class="notion-inline-code">slug</code> 中需要额外加上 <code class="notion-inline-code">.html</code> 后缀，来保证更换站点后，原文 URL 不变。</li></ul><ul class="notion-list notion-list-disc notion-block-5ff81815b54e41eaab5fca7888b32a99"><li>由于我使用了 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://utteranc.es/"><b><b>utterances</b></b></a><b><b> </b></b>作为评论系统，需要保证文章迁移前后能够有同样的评论 (issueTerm → “pathname”)</li></ul><div class="notion-text notion-block-e0652f4ff4914bb3b6064914a3f2d089">最后对站点整体样式进行一些个人化的样式微调，大功告成：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://next.emergencyexit.xyz/">布鲁斯鱼的妙想天开</a> 🎊</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-bee3460432c1434992c51d60e73afa29" data-id="bee3460432c1434992c51d60e73afa29"><span><div id="bee3460432c1434992c51d60e73afa29" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bee3460432c1434992c51d60e73afa29" title="后续可能的升级点——传播的局限"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">后续可能的升级点——传播的局限</span></span></h3><div class="notion-text notion-block-157eb8b2bb82492082968f1c0caac8ce">由于之前并未有太多博客建站的经验，所以很多问题考虑不周，也大大制约了本博客的传播能力<s>（当然，主要是文章水分过高，价值不够）。</s></div><div class="notion-text notion-block-eb92abd737624bcda31e0fe935775293">主要有以下几个方面：</div><ul class="notion-list notion-list-disc notion-block-fd8f579588534f86901c6b4408180aa4"><li>缺少国内 CDN 加速。本站是中文站点，却经常引用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://unsplash.com/">Upslash</a> 的大图，丝毫没有把国内用户访问体验放在心上。</li></ul><ul class="notion-list notion-list-disc notion-block-da796d97a9d1444ca84534a96bc18988"><li>搜索绝缘体。虽然我也不太看重百度搜索，也不想让自己的文章出现在一堆 CSDN、百度百家的文章中，但是由于未备案和 Github Pages 的部署性质，基本和国内的搜索说拜拜了。</li></ul><ul class="notion-list notion-list-disc notion-block-9b0a600c91fc4c1bb356cc5ab4806efa"><li><s>文章太水了，没有让人阅读和分享的欲望（这个暂时解决不了，能力一般，水平有限）</s></li></ul><div class="notion-blank notion-block-3b179dae9f0642728723e4d618872937"> </div><div class="notion-callout notion-gray_background_co notion-block-04cccd37d615495eae7a70da01f5fa6b"><span class="notion-page-icon" role="img" aria-label="🤪">🤪</span><div class="notion-callout-text">我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cloud.tencent.com/developer/support-plan?invite_code=34ky79072xmo4">https://cloud.tencent.com/developer/support-plan?invite_code=34ky79072xmo4</a></div></div><div class="notion-blank notion-block-b690c655c4af4fc7a431e8e44cabeefd"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[WTF Go: Constants]]></title>
            <link>https://next.emergencyexit.xyz//wtf-go-constants.html</link>
            <guid>https://next.emergencyexit.xyz//wtf-go-constants.html</guid>
            <pubDate>Tue, 11 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[ WTF Go: 初看反直觉，仔细研究却大有设计]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-f6ba5dfd50004e1580b47d3456bc676a"><div class="notion-viewport"></div><pre class="notion-code language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"time"</span>
	<span class="token string">"math/rand"</span>
<span class="token punctuation">)</span>

<span class="token comment">// invalid operation: rand.Intn(10) * 1000 * time.Millisecond (mismatched types int and time.Duration)</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> ❌

<span class="token comment">// 🤔 make sense.</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> ✅

<span class="token comment">// wtf ?!</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> ✅ </code></pre><div class="notion-text notion-block-c39aa2c506de4a38884207f6cc0666f4">看看上面这个简单的例子：</div><ul class="notion-list notion-list-disc notion-block-94339645b11c4208ac1de17ef66e21d6"><li>第一个错误很容易理解： 整型不能和 <code class="notion-inline-code">time.Duration</code> 相乘</li></ul><ul class="notion-list notion-list-disc notion-block-90a7e274dd4740ac97bd29e4c8b56822"><li>第二个例子修正了这一问题，符合预期</li></ul><ul class="notion-list notion-list-disc notion-block-f1ecf287e16c4698bfa18a71b4789179"><li>第三个例子带来了疑问，为什么 <code class="notion-inline-code">1000 * time.Millisecond</code> 却没有问题？明明 <code class="notion-inline-code">1000</code> 也是个整型？编译器戴了有色眼镜？</li></ul><div class="notion-text notion-block-2aa15d50137b414bb6ed5569ce63f326">别慌，仔细看看 <code class="notion-inline-code">rand.Intn(10) * 1000</code> 和 <code class="notion-inline-code">1000</code> 的区别在于：前者是变量，类型已经确定了，通不过编译是情理之中；而后者是常量，类型并不是 <code class="notion-inline-code">int</code> ，属于 <code class="notion-inline-code">untyped constants</code> ，编译器会尝试将它转换成 <code class="notion-inline-code">time.Duration</code> 。</div><div class="notion-text notion-block-4b6e7022ba1c41dc9dec86be35016e6a">这就勾起了我的好奇心，那如果我写个一个 <code class="notion-inline-code">float</code> 常量会怎样呢？</div><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// (untyped float constant) truncated to int64</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000.1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> ❌</code></pre><div class="notion-text notion-block-5581a723f1c9437da180b271dde64dfb">果然是不行的。那么究竟这个无类型常量的类型转换是依照什么规则进行的呢？</div><div class="notion-text notion-block-fda4059895d742c18a5c11fcd2834e98">首先每一种常量的<b>写法</b>都会对应着一种默认类型：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-bead2efbe82d41e6a20ac11ad6d2aa44"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:540px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F4841bfb7-5a0d-42ae-ba4c-55881d39feec%2FUntitled.png%3Fid%3Dbead2efb-e82d-41e6-a20a-c11ad6d2aa44%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1694577600000%26signature%3DsiVDhzl139AIQXiaXbSEAaYEW3Zpyr3J3CkfrS7qpnw?table=block&amp;id=bead2efb-e82d-41e6-a20a-c11ad6d2aa44&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-fd185c5379f34f0a8f0cafca86305977"> </div><div class="notion-text notion-block-b39975e4a04d40b4b8693d417031d653">然后，看看 <code class="notion-inline-code">time.Duration</code> 的定义：</div><pre class="notion-code language-go"><code class="language-go">type Duration int64

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    Nanosecond  Duration <span class="token operator">=</span> <span class="token number">1</span>
    Microsecond          <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Nanosecond
    Millisecond          <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Microsecond
    Second               <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Millisecond
    Minute               <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> Second
    Hour                 <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> Minute
<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-b8de09386e5b45e7a5f0ae8bfc054707">也就是说 <code class="notion-inline-code">1000</code> 的写法默认类型为 <code class="notion-inline-code">int</code> ，编译器会尝试做一次类型转换 <code class="notion-inline-code">int</code> → <code class="notion-inline-code">time.Duration</code> ，而 <code class="notion-inline-code">int64</code> 和 <code class="notion-inline-code">int</code> 又能做到完全兼容，所以编译通过。</div><div class="notion-blank notion-block-bb978502225d458d8ea95627d61232a4"> </div><div class="notion-text notion-block-73679d6edd4946938e9b7e3de693eee1">WTF，Go…</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-387dcc99be4b4d9bb32787dccb641d7b" data-id="387dcc99be4b4d9bb32787dccb641d7b"><span><div id="387dcc99be4b4d9bb32787dccb641d7b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#387dcc99be4b4d9bb32787dccb641d7b" title="参考："><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考：</span></span></h3><ul class="notion-list notion-list-disc notion-block-ba5cdf07de3944ea84183d9fab8c5efb"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://go.dev/blog/constants">https://go.dev/blog/constants</a> （本文主要搬运来源）</li></ul><ul class="notion-list notion-list-disc notion-block-f7b45bfc8bf8475193cb2ae92d69b169"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://blog.learngoprogramming.com/learn-golang-typed-untyped-constants-70b4df443b61">https://blog.learngoprogramming.com/learn-golang-typed-untyped-constants-70b4df443b61</a></li></ul><div class="notion-blank notion-block-3554b88ab160438cae51c7eecbae9b14"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google 软件工程 读后感 Part I]]></title>
            <link>https://next.emergencyexit.xyz//software-engineering-at-google-impression.html</link>
            <guid>https://next.emergencyexit.xyz//software-engineering-at-google-impression.html</guid>
            <pubDate>Tue, 20 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[有趣的比喻集合]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-3927ece3993146e88e7e91d5e0b5c326"><div class="notion-viewport"></div><div class="notion-text notion-block-ec27187857af4dd7909a8b90936e43ea">总的来说，这本书值得所有软件开发从业者阅读。一些观点可能不至于奉之圭臬，但也可以提供另一种处理问题的视角。</div><div class="notion-text notion-block-897150010d224de4ba48d1ff6f8b1392">它将很多<b>存在于意识而尚未落成语言的软件工程共识</b>，用简单易读的方式总结表达了出来，相信对于大多数软件工程师都会有帮助。</div><div class="notion-text notion-block-c2ba7cfd50b3425084f45603fcbff89f">分享书中一些有趣的说法，如果你也觉得有意思，那么就买来读一读吧。</div><div class="notion-text notion-block-39594e9a3fce41e49b9a5210fdf01fa3">（如果你的「洋文🤓」够好，也可以直接<span class="notion-teal"><b>免费</b></span>阅读 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://abseil.io/resources/swe-book/html/toc.html">英文原版</a>）</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-07d4b358fcd44b0b90fb5a295bd4b1dd" data-id="07d4b358fcd44b0b90fb5a295bd4b1dd"><span><div id="07d4b358fcd44b0b90fb5a295bd4b1dd" class="notion-header-anchor"></div><a class="notion-hash-link" href="#07d4b358fcd44b0b90fb5a295bd4b1dd" title="海勒姆定律（Hyrum’s Law）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">海勒姆定律（Hyrum’s Law）</span></span></h3><blockquote class="notion-quote notion-block-57a7a82e02e64c1ca392536ae1ba3027">当一个 API 有足够多的用户时，在约定中你所承诺的已不重要：所有在你系统里面被观察到的行为都会被一些用户所依赖。</blockquote><div class="notion-text notion-block-4a142d26df674781897ce80fd220c487">我从中读出来的关键点：拒绝侥幸心理。当用户体量足够大时，任何改动都需要通过测试来收尾，侥幸心理自认为某些逻辑人畜无害，一两次可能可以省事儿，但总有一天会翻船。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-78bb3c9293c94075b5e2d2754f376ba1" data-id="78bb3c9293c94075b5e2d2754f376ba1"><span><div id="78bb3c9293c94075b5e2d2754f376ba1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#78bb3c9293c94075b5e2d2754f376ba1" title="巴士系数（Truck Factor）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">巴士系数（<b>Truck Factor</b>）</span></span></h3><blockquote class="notion-quote notion-block-c067d91017c642edaf839e01370db824">指多少关键开发者被巴士撞了会让项目停摆。</blockquote><div class="notion-text notion-block-11cde37630c343f0a75319a674254b53">开发者被巴士撞了虽然有点残忍，但确实是一个很形象的表述——当成员突然不参与工作或失去通讯能力。可能在很多团队中，开发者的<b>突然离职</b>是更贴近这种场景的情况。想要尽量避免因为关键人物的离开而导致项目停摆，书中也列举了基础的预防措施：备份或者结对编程，“每一个人在工作时都需要第二双眼睛的监督”，最重要的是 “拒绝隐藏”。</div><div class="notion-text notion-block-33bed20e701b40cb81c0322f955c84b9">就我个人的经验而言，在项目开发过程中保持良好的文档记录习惯是一种“美德”，在一些更有追求的团队，更应该是“义务”。良好的文档可以一定程度上保持当“巴士”袭来时，团队能够依靠文档维持相当程度的稳定。</div><div class="notion-text notion-block-ec305ffabbeb455098df8f3d02b657c0">当然以上都是从 <b>“团队最优” </b>的角度来说，并不是所有公司都有 Google 的优秀风气，我还在别的团队听过”教会徒弟，饿死师傅“的说法。</div><div class="notion-text notion-block-e4707ad77bbc4cafb4441ddf3eba5912">这其中孰对孰错，是分享还是私藏，很难在这篇读后感中用几百字讨论清楚。</div><div class="notion-text notion-block-6898e8ff30cf46638d1d72ec2c563dad">我们需要保持清醒：互联网从业有它的特殊性——知识获取门槛极低，任何领域都可以通过网络资源轻松入门，但同时也有其他行业相似的普遍性——在资本逐利的背景下，行业失去高增长，更低成本的人力总是会更有竞争力。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-0f50d6ae1c1e4bf4a295cb1abb100879" data-id="0f50d6ae1c1e4bf4a295cb1abb100879"><span><div id="0f50d6ae1c1e4bf4a295cb1abb100879" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0f50d6ae1c1e4bf4a295cb1abb100879" title="左移思想（Left Shift）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">左移思想（Left Shift）</span></span></h3><blockquote class="notion-quote notion-block-8864520720f8419ab3d1ea039198f93d">在开发人员工作流的早期发现问题通常会降低成本。</blockquote><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-64e5a128d5ba4638a1c92360e5482d1a"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:432px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F33295efc-1f2c-441e-8829-fb516edd724c%2FUntitled.png?table=block&amp;id=64e5a128-d5ba-4638-a1c9-2360e5482d1a&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-12c690895f02451998de285e999ba4b5">配合此图，还是非常容易理解的。从开发人员的角度来看，可能存在的问题在越前端解决付出的成本肯定是越小的。举个小例子，陶文在 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zhuanlan.zhihu.com/p/357411780">《不要以 DRY 之名，发明低代码 DSL 去残害你的同事》</a>提到过，缺乏与上游（比如产品、策划）的沟通，只是在开发侧 “一厢情愿” 的抽象可能是一个误区：“先要把需求的源头给按住了。而不是在需求的下游，用可复用抽象代码来兜底”。</div><div class="notion-text notion-block-aac58e9671844d35ad0ccc013e987983">类似地，在敏捷开发和 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://devops.com/devops-shift-left-avoid-failure/">DevOps 开发理论中也提到过</a> ，同时还有一个 “<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://devops.com/shift-right-testing-the-emergence-of-testops/">测试右移</a>” 的概念，在测试或者是性能检查时，尽量从贴近用户端出发来保证整个产品流程的质量。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-0d9a2e22b9e049a8bac1ff5ca37930de" data-id="0d9a2e22b9e049a8bac1ff5ca37930de"><span><div id="0d9a2e22b9e049a8bac1ff5ca37930de" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0d9a2e22b9e049a8bac1ff5ca37930de" title="经理人炎症（Manageritis）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">经理人炎症（Manageritis）</span></span></h3><blockquote class="notion-quote notion-block-0fe7688ff117426b89f4240ba74b020c">对于处于进步边缘的有抱负的或者那些刚刚晋升的领导者，存在一种高度危险的自我炎症，称为“管理炎”。</blockquote><div class="notion-text notion-block-f6c396005f6a40a086d0c1750da40ca2">更简单说法是 “刻意管理”，这种症状多数出现在从个人贡献者 → 管理者身份转变期。很大的原因是，作为技术开发者，我们已经很习惯于在专业技能上投资，并有着合适的回报预期：比如定期在某个领域深入学习，你就能立马获得该领域的技能提升。但是转变到“经理”时，这个回报周期变得不一样了（通常会更长），带领团队向上提升，个体的技能成长反而不容易被感知，会导致做出更高频次的“投资”动作，更加”努力管理”，更容易显得刻意。</div><div class="notion-text notion-block-5dee97aa820d411fbc7f0b9e60bcc51b">还有一个方面的原因，从个人贡献者到管理者后，将会面临很多抉择的场景：<em>自己动手，快速解决问题 </em>vs <em>交给他人，更慢更困难地解决问题</em>，及时从更长尺度上来看，后者收益会更高，但在这个抉择面前，没有经验的管理者还是会显得非常犹豫。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-af607e49d1ed49c0ad3bb362bf92ffbe" data-id="af607e49d1ed49c0ad3bb362bf92ffbe"><span><div id="af607e49d1ed49c0ad3bb362bf92ffbe" class="notion-header-anchor"></div><a class="notion-hash-link" href="#af607e49d1ed49c0ad3bb362bf92ffbe" title="碧昂丝规则（Beyoncé Rule）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">碧昂丝规则（Beyoncé Rule）</span></span></h3><blockquote class="notion-quote notion-block-08f7f47edaa44f40a7387935ba510099">“如果你喜欢它，你就应该测试它”。</blockquote><div class="notion-text notion-block-06be070f5c2f4fe29ec84970faf12195">原型是：&quot;If you liked it then you shoulda put a ring on it”，来自于碧昂斯 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.youtube.com/watch?v=4m1EFMoRFvY">Single Lady(Put a Ring on It)</a> 歌词（我感觉关联性不大，我猜是碧昂斯粉丝的私货 🤣）。</div><div class="notion-text notion-block-b55310de83394d8a8578c751aa107df5">意思是“所有不想被破坏的东西”都应该被测试。当你的项目依赖于某些外部系统时，如果想确保一些特性能够符合预期，那么唯一的办法就是在自己的项目编写测试。</div><div class="notion-text notion-block-7b582dc921d64925af13c234ff261fe9">这一点容易被泛化到外部系统的所有特性，我的理解是需要妥善处理依赖的外部系统<b>常见的重点场景</b>出现异常的情况，而不是全部，也不应该关注全部。</div><div class="notion-text notion-block-140a4fcfb666460b9428f70357693cbd">在 Google 内部常有一种说法：“如果一个产品由于基础设施的变更出现中断或其它问题，但是在我们的持续集成(CI)系统中的自动化测试用例并没有发现这个问题，那么就不应该由负责基础设施的团队承担责任。”</div><div class="notion-text notion-block-c0789386a8ff49b3941623f22c3334df">在我们日常的工作场景中，大家普遍是没有这个意识的，如果基础设施出问题，无论我们是否有预料，黑锅都可以毫无负担的甩下去，也造成基础设施部门普遍承受了过多压力 xD。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-42d3995b003b481b880565f8f241d6b8" data-id="42d3995b003b481b880565f8f241d6b8"><span><div id="42d3995b003b481b880565f8f241d6b8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#42d3995b003b481b880565f8f241d6b8" title="Fin"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Fin</span></span></h3><div class="notion-text notion-block-f4922f38c9ce4edc8ea1d08ddecb407b">书中还有一些更大值得讨论的话题，以后或许有机会可以结合自己的项目经历写出来聊聊<em><s>（典型的挖坑不埋）</s></em>。</div><div class="notion-blank notion-block-161f0f3cd34d432493910405685342ba"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Django ORM：天使与魔鬼 II]]></title>
            <link>https://next.emergencyexit.xyz//django-orm-best-practice-II.html</link>
            <guid>https://next.emergencyexit.xyz//django-orm-best-practice-II.html</guid>
            <pubDate>Fri, 09 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[CRUD boy 回来了]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-6ad26f7b18284d64a9483cc6367f6901"><div class="notion-viewport"></div><div class="notion-text notion-block-917f169ee9c34019a62c5f85892e3620">最近重操 CRUD 旧业，又有一些新的发现，故增加一篇 <a class="notion-link" href="https://www.notion.so/982e294cabb247aa878134d8bb6fd6ce">Django ORM：天使与魔鬼</a> Part II。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-4d19de6795b04c9f89f8e3a758d0954c" data-id="4d19de6795b04c9f89f8e3a758d0954c"><span><div id="4d19de6795b04c9f89f8e3a758d0954c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4d19de6795b04c9f89f8e3a758d0954c" title="利用 batch_size 控制数据库单次提交的大小"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">利用 batch_size 控制数据库单次提交的大小</span></span></h3><div class="notion-text notion-block-4441855d1bb34da0aed6aa17fcf05202"><code class="notion-inline-code">bulk_create</code> 和 <code class="notion-inline-code">bulk_update</code> 是我们常用的批量创建、更新的方法，但批量提速一时爽，提交过长会直接导致任务失败。</div><div class="notion-text notion-block-5c409ae54dae4b2b882909acbbeec43c">之前没有细致查阅文档，想当然 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/TencentBlueKing/bk-user/blob/cd3d14b72d92de0cf687e9466a797b9fd07e0daf/src/api/bkuser_core/common/db_sync.py#L140">手写了批量提交分片的逻辑</a> ，虽然也完全实现了功能，但终究多了一份需要维护的逻辑，实际上直接用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/querysets/#bulk-create">Django 默认提供的 </a><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/querysets/#bulk-create"><code class="notion-inline-code">batch_size</code></a> 即可。</div><pre class="notion-code language-python"><code class="language-python">from itertools <span class="token keyword">import</span> islice

batch_size <span class="token operator">=</span> <span class="token number">100</span>
objs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">Entry</span><span class="token punctuation">(</span>headline<span class="token operator">=</span><span class="token string">'Test %s'</span> <span class="token operator">%</span> i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token literal-property property">True</span><span class="token operator">:</span>
    batch <span class="token operator">=</span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token function">islice</span><span class="token punctuation">(</span>objs<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> not batch<span class="token operator">:</span>
        <span class="token keyword">break</span>
    Entry<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">bulk_create</span><span class="token punctuation">(</span>batch<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span></code></pre><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-4560c1f2cdc34fc8b26c830584140494" data-id="4560c1f2cdc34fc8b26c830584140494"><span><div id="4560c1f2cdc34fc8b26c830584140494" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4560c1f2cdc34fc8b26c830584140494" title="通过 Prefetch 控制预取的查询"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">通过 Prefetch 控制预取的查询</span></span></h3><div class="notion-text notion-block-942fb49c92dd440eacbde16315aa4e4c"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping">N + 1 问题</a>是非常常见的查询效率杀手。在 Django 中我们通常会使用 <code class="notion-inline-code">selected_related</code> 或<code class="notion-inline-code">prefetch_related</code> 来预取关联对象，来减少和 DB 之间的交互，但是在使用上也需要有一些注意的地方。</div><div class="notion-text notion-block-29fd3c9a717c4acaa7d4af894c3bf0e7">首先，预取需要精确控制到字段。</div><div class="notion-text notion-block-e116a47ba91e4fe3a33d9bbd54be8429">Django 默认的查询方式都是粗放的，例如普通查询不使用 <code class="notion-inline-code">values</code> 或者 <code class="notion-inline-code">only</code> 时都是 <code class="notion-inline-code">select *</code> ，而预取也不例外，看看下面这个例子。</div><pre class="notion-code language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	<span class="token operator">...</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	foo <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">ForeignKey</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>
	<span class="token operator">...</span>

<span class="token keyword">class</span> <span class="token class-name">Baz</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
  <span class="token string">""</span><span class="token string">"A very large table"</span><span class="token string">""</span>
	foo <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">ForeignKey</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-844a600b3a5c44fb806ca38269fa0a16">我们在查询 <code class="notion-inline-code">Foo</code> 时，会尝试预取关联字段以加速后续数据读取，但如果我们在调用时不加任何参数：<code class="notion-inline-code">Foo.objects.all().prefetch_related()</code> ，<b>默认地 Django 会将所有关联字段都取出来</b>，加入 <code class="notion-inline-code">Baz</code> 表无比巨大，本来用作性能优化的 <code class="notion-inline-code">prefetch_related</code> 就会摇身变成耗时怪兽。</div><div class="notion-text notion-block-05eabf30586c4efd84335bcd09602fed">此外，我们还会遇到级联预取的场景。</div><pre class="notion-code language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	<span class="token operator">...</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	foo <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">ForeignKey</span><span class="token punctuation">(</span>Foo<span class="token punctuation">,</span> related_name<span class="token operator">=</span><span class="token string">"bars"</span><span class="token punctuation">)</span>
	<span class="token operator">...</span>

<span class="token keyword">class</span> <span class="token class-name">Baz</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	bar <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">ForeignKey</span><span class="token punctuation">(</span>Bar<span class="token punctuation">,</span> related_name<span class="token operator">=</span><span class="token string">"bazs"</span><span class="token punctuation">)</span>
	large_config <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">JSONField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">...</span></code></pre><div class="notion-text notion-block-f2e6729bc91346c6ad21fd1a2bcd4ff4">此时在后续的循环处理中，我们需要通过 <code class="notion-inline-code">Foo</code> 对象查询到 <code class="notion-inline-code">Baz</code> 的数据，为了避免 N + 1 我们也会多级预取:</div><pre class="notion-code language-python"><code class="language-python">Foo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">select_related</span><span class="token punctuation">(</span><span class="token string">"bars"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prefetch_related</span><span class="token punctuation">(</span><span class="token string">"bars__bazs"</span><span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-e7a383c89d8a47d98bb03ea1215373c5">此时二级预取也是默认获取全部字段，倘若 <code class="notion-inline-code">Baz</code> 表中有一个需要额外耗时序列化的字段，同样会使优化适得其反。这时可以考虑引入 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/querysets/#prefetch-objects"><code class="notion-inline-code">Prefetch</code></a> 对象，做更细致的查询控制。</div><pre class="notion-code language-python"><code class="language-python">Foo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">select_related</span><span class="token punctuation">(</span><span class="token string">"bars"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">prefetch_related</span><span class="token punctuation">(</span>
	<span class="token function">Prefetch</span><span class="token punctuation">(</span><span class="token string">"bars__bazs"</span><span class="token punctuation">,</span> queryset<span class="token operator">=</span>Baz<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token string">"large_config"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span></code></pre><div class="notion-blank notion-block-49ad21cac56745f889392cedcb9e5b71"> </div><div class="notion-text notion-block-744cc7796009402fab94db362da28356">是不是觉得 ORM 查询本身也挺繁杂的？用 SQL 有时会更直接清晰地多。所以也会有一些完全<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://dev.solita.fi/2021/06/01/why-avoid-an-orm.html">不使用 ORM 的观点</a>。在我看来，ORM 能让 90% 的查询都变得结构化更清晰、更易维护、甚至更安全，但剩下的 10% 也许会耗费更多的精力，所以何时使用 ORM 是根据具体项目场景来定的，不能因噎废食。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-b5a4d66ac57a4ca8b13e1028109b39c7" data-id="b5a4d66ac57a4ca8b13e1028109b39c7"><span><div id="b5a4d66ac57a4ca8b13e1028109b39c7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b5a4d66ac57a4ca8b13e1028109b39c7" title="小广告"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">小广告</span></span></h3><div class="notion-text notion-block-f88ddea20edb497b87e46b9377a818d2">是不是觉得 Part II 内容有点少？没关系，更多的内容我都放在了这里。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-11be5a01c4ec4b2abb68cbf4b3bc73dc" href="https://github.com/TencentBlueKing/python-best-practices"><div><div class="notion-bookmark-title">GitHub - TencentBlueKing/python-best-practices</div><div class="notion-bookmark-description">Contribute to TencentBlueKing/python-best-practices development by creating an account on GitHub.</div><div class="notion-bookmark-link"><img src="https://github.com/favicon.ico" alt="GitHub - TencentBlueKing/python-best-practices" loading="lazy"/><div>https://github.com/TencentBlueKing/python-best-practices</div></div></div><div class="notion-bookmark-image"><img src="https://opengraph.githubassets.com/e9d11601584d87c0fbb4092264f7ab23a33987f8d05dfb8b0e0c57157aecc9b3/TencentBlueKing/python-best-practices" alt="GitHub - TencentBlueKing/python-best-practices" loading="lazy"/></div></a></div><div class="notion-text notion-block-c4cb7b9d7d92463eb7dd154161269031">我和团队小伙伴整理了很多 Python\Django\DRF 的最佳实践经验，项目会持续更新，欢迎一起探讨维护，希望每一个 CRUD 男孩/女孩都能少踩坑。</div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ReDoS：正则也许会让你的系统更脆弱]]></title>
            <link>https://next.emergencyexit.xyz//redos-and-why.html</link>
            <guid>https://next.emergencyexit.xyz//redos-and-why.html</guid>
            <pubDate>Tue, 01 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[“充数的文章描述”]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-9d18b689cdc24d3f81daa690c700caee"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-71c5c2ad3a0042a5854d1ffd540fb85b"><a href="#16167b014e884180872922c343d81f2f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">引</span></a><a href="#06a24e1d70ff4b4d8890c4411ad92c88" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Evil Regex 大敌当前</span></a><a href="#11ab27b4d2ec4f7399a9aecafa750e00" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">知己知彼，百战不殆</span></a><a href="#1596c45ca40b4f4998f3be993530b2ee" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">NFA vs DFA</span></a><a href="#b0f1e34a5f0242bb83f7f49d56c2621f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Thompson NFA 构造 vs DFA</span></a><a href="#ddeb7f785eb14d7b868a6917822d6ab5" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">为什么主流编程语言这么慢？</span></a><a href="#6e320bb2c4334d31af6172db35ede111" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">正面对抗 Evil Regex</span></a><a href="#8a414c655d0842eb9a242a88266b28e7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">pyre2</span></a><a href="#12c4a78bedf14dcf8397441db47e3f36" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">regex</span></a><a href="#8ef69d8b54184936a684009d1c35948e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-16167b014e884180872922c343d81f2f" data-id="16167b014e884180872922c343d81f2f"><span><div id="16167b014e884180872922c343d81f2f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#16167b014e884180872922c343d81f2f" title="引"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">引</span></span></h3><div class="notion-text notion-block-64a4a303b845467c8de321306c3fee84">这里有一段看起来稀松平常、人畜无害的 Python 代码，你可以试着执行一下：</div><pre class="notion-code language-python"><code class="language-python"><span class="token keyword">import</span> re
<span class="token keyword">import</span> time


value <span class="token operator">=</span> <span class="token string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaabs"</span>
strange_regex <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"(a+)+s"</span><span class="token punctuation">)</span>

start <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
re<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>strange_regex<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
end <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">print</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-6bb9397fa1ab4801b7edd5bff3e9243b">不知道大家执行了多久，在我开发机上使用 Python 3.6+（包括 3.10.x）<b>需要耗费20秒以上</b>，即使 CPU ——Apple M1 Pro 的性能已经相当强悍了。</div><div class="notion-text notion-block-e33e99798c1f48bd897156f2a344cbf3">可以试想一下，如果在生产环境服务的关键请求链路中存在这样正则匹配，加上不可控的用户输入，很容易落入“性能陷阱”，轻则拖慢系统，重则直接让服务暴露在 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/ReDoS">ReDoS</a> (Regual Expression Denial-of-Service) 的风险之下。</div><div class="notion-text notion-block-429048f3ea3c4f989258b2e1a3aa81c4">随手一搜，已经有不少相关的案例发生：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23343">CVE-2021-23343</a> 、<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41817">CVE-2021-41817</a>。所以，它值得我们格外重视。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-06a24e1d70ff4b4d8890c4411ad92c88" data-id="06a24e1d70ff4b4d8890c4411ad92c88"><span><div id="06a24e1d70ff4b4d8890c4411ad92c88" class="notion-header-anchor"></div><a class="notion-hash-link" href="#06a24e1d70ff4b4d8890c4411ad92c88" title="Evil Regex 大敌当前"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Evil Regex 大敌当前</span></span></h3><div class="notion-text notion-block-421e347965f04238accb85b4748a20b0">先来看一些和上面例子类似的、典型的邪恶正则：</div><ul class="notion-list notion-list-disc notion-block-98d8301372354699a816e8fd5bc08002"><li><code class="notion-inline-code">(a+)+</code></li></ul><ul class="notion-list notion-list-disc notion-block-0d6cd58d075b49089d85ceaf2ab1753e"><li><code class="notion-inline-code">([a-zA-Z]+)*</code></li></ul><ul class="notion-list notion-list-disc notion-block-51804104983f4c3981f8d0f152a88f9f"><li><code class="notion-inline-code">(a|aa)+</code></li></ul><ul class="notion-list notion-list-disc notion-block-d0d2e591195a4ac8b863524a9b98eba7"><li><code class="notion-inline-code">(a|a?)+</code></li></ul><ul class="notion-list notion-list-disc notion-block-c6b2c4201dcd4463b918ba3275a4887b"><li><code class="notion-inline-code">(a|a)+$</code></li></ul><ul class="notion-list notion-list-disc notion-block-b4e5e7f0f44740ff8b09a30eb3ab254a"><li> <code class="notion-inline-code">(.*a){x} for x \&gt; 10</code></li></ul><div class="notion-text notion-block-95a16b9277c84bd788ffad18af9382a9">它们都有共同的一些特点：</div><ul class="notion-list notion-list-disc notion-block-eb56bd6f90c74deaaf58989c90b25b0a"><li>存在子表达重复——形如 <code class="notion-inline-code">()+</code> 、 <code class="notion-inline-code">()*</code></li></ul><ul class="notion-list notion-list-disc notion-block-0f99c854d6a74797b1fb0c53db1de6a8"><li>在重复的子表达中：</li><ul class="notion-list notion-list-disc notion-block-0f99c854d6a74797b1fb0c53db1de6a8"><li>存在重复项—— <code class="notion-inline-code">(a+)+</code></li><li>存在交替重复—— <code class="notion-inline-code">(a|aa)+</code></li></ul></ul><ul class="notion-list notion-list-disc notion-block-481496a757be470f9f6e511dc06659e9"><li>在重复的子表达的末尾，存在一个子表达式无法匹配的内容，例如 <code class="notion-inline-code">(a|a)+$</code></li></ul><div class="notion-text notion-block-a492ebc689144979995324686ba5ca7f">那么为什么这些重复会导致匹配速度如此之慢呢？我们要看看正则的具体实现思路。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-11ab27b4d2ec4f7399a9aecafa750e00" data-id="11ab27b4d2ec4f7399a9aecafa750e00"><span><div id="11ab27b4d2ec4f7399a9aecafa750e00" class="notion-header-anchor"></div><a class="notion-hash-link" href="#11ab27b4d2ec4f7399a9aecafa750e00" title="知己知彼，百战不殆"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">知己知彼，百战不殆</span></span></h3><div class="notion-text notion-block-492dbeb1cfc1451b95d0a1dbecd70d7a">当前主流语言的正则实现机制都是构建<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton"><b>非确定有限状态自动机(NFA)</b></a><b> </b>，相较于<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton"><b>确定有限状态自动机(DFA)</b></a>，前者会使用<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Backtracking">回溯法(backtracking)</a>，这也是导致邪恶正则存在的根因。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-1596c45ca40b4f4998f3be993530b2ee" data-id="1596c45ca40b4f4998f3be993530b2ee"><span><div id="1596c45ca40b4f4998f3be993530b2ee" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1596c45ca40b4f4998f3be993530b2ee" title="NFA vs DFA"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">NFA vs DFA</span></span></h4><div class="notion-text notion-block-3f9b78a623b0451c9cf0799a903fdc0b">（该章节中的图例均来自<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://swtch.com/~rsc/regexp/regexp1.html">这篇文章</a>，我在这里做了内容简化，建议有兴趣的同学阅读英文原文）</div><div class="notion-text notion-block-620943d008c0426da775e5a82b0f2f74">FA 有限自动机，又称 FSM 有限状态机，在当前的语境下，我们统一都是用 FA 来描述。这种计算模型比较常见，所以我们就着重关注 NFA 和 DFA 的对比。</div><div class="notion-text notion-block-36f538b5c08e41df94547097e1490efd">首先，来看一个简单的正则表达式—— <code class="notion-inline-code">a(bb)+a</code> ，它可以转换成以下两种表达：</div><div class="notion-row notion-block-8b914cd473c64b568ab10330ec59c60f"><div class="notion-column notion-block-9cbe557272fc42eb982c33bdfb7972bd" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-64d3af5c94464206883ad1543abd6203"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:54px"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe41cc1a4-ae04-422e-8a4d-22e77e03d496%2FUntitled.png?table=block&amp;id=64d3af5c-9446-4206-883a-d1543abd6203&amp;cache=v2" loading="lazy" alt="DFA" decoding="async"/><figcaption class="notion-asset-caption">DFA</figcaption></div></figure></div><div class="notion-spacer"></div><div class="notion-column notion-block-3a10ae26ed6b4fee9b000d4e03623deb" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-6fdf1be8b201455488080f316c0cea35"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:54px"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F18765429-1c82-4046-9afe-21a3a68d505d%2FUntitled.png?table=block&amp;id=6fdf1be8-b201-4554-8808-0f316c0cea35&amp;cache=v2" loading="lazy" alt="NFA" decoding="async"/><figcaption class="notion-asset-caption">NFA</figcaption></div></figure></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-351ce2ee5b03445fa5e21f10c9d4c8f5">上面两张图能够很清晰地表现出二者的不同：</div><ul class="notion-list notion-list-disc notion-block-0f74de50e44b48628c88eb34d668addd"><li>DFA 中，每一个状态在接收到输入时，下一个状态都是确定的。</li></ul><ul class="notion-list notion-list-disc notion-block-6db506c14054421eb3826a97952bf93c"><li>NFA 中，存在某些状态在接收到输入时，无法确定下一个状态：例如图中的 S2 接收到字符 b，S1 和 S3 都是可能的下一个状态。所以系统在分支选择时，需要进行猜测。</li></ul><div class="notion-text notion-block-1b2eff3ae49e4c19b23519afe1033bfd">理论上，每一条正则表达式都可以等同转换成一个 NFA 状态机，那么如果使用 NFA 进行匹配，如何处理猜测分支就很重要了。下面我们来看一个简单遍历猜测的例子。</div><div class="notion-text notion-block-61de96581b8649f9a63000513ca7458b">根据正则 <code class="notion-inline-code">abab|abbb</code> 我们可以建立如下的 NFA：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-a81212ec0de24ed5befc71a01610d802"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:364px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F100299f6-ef9d-41f6-b77c-dfbcb1644614%2FUntitled.png?table=block&amp;id=a81212ec-0de2-4ed5-befc-71a01610d802&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-9d8ec084d55741759e4c296c58045065">模拟计算机匹配输入 <code class="notion-inline-code">abbb</code>，可以有如下两种路径：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-e4c28ba34b134c6ca5a9a0d69c02ed8f"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2d01c07f-0cde-40f3-8ad1-837137c1d9d8%2FUntitled.png?table=block&amp;id=e4c28ba3-4b13-4c6c-a5a9-a0d69c02ed8f&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-0fd8ce7c02894191b05b1c13de3bf6d6">以 Step 0 开始的路径，在匹配到第三个字符时出错，此时不得不采用回溯，再次从一开始进行匹配，即 Step 4 → Step 8。</div><div class="notion-text notion-block-98ec072a50a04ad68c2e3b7317d2b355">通过这个回溯方法，我们来思考正则表达式 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span> 与字符串 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span> 匹配：</div><div class="notion-text notion-block-50124f3a5808418c8ce289482e7c3f29">如果每一次判断 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span> 是否存在时，都会尝试匹配“存在”的情况，再匹配不存在的情况，而整个字符串长度为 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，也就是时间复杂度为  <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>。</div><div class="notion-text notion-block-d65ba5a0c9b140f9a94c6fd9c0987fce">当前主流的语言（Perl, PCRE, Python, Ruby等）采用了<b>递归</b>来实现深度优先回溯，相较于 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Thompson%27s_construction">Thompson NFA</a>，最终实现的效果都是惊人的糟糕。</div><div class="notion-row notion-block-4088dc8fdb2b46e39e930be62fcd58b6"><div class="notion-column notion-block-cf952c80f58d42c494f54b20d578f2b2" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-08040b98a5b94de2945d4247f370a6ec"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:301px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F62d6c97a-651f-4dae-9157-3711b51864ef%2FUntitled.png?table=block&amp;id=08040b98-a5b9-4de2-945d-4247f370a6ec&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></div><div class="notion-spacer"></div><div class="notion-column notion-block-98b4b7afbadd4ca487963dc17f121754" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-46b7fb61de5e43cda2bb4539a1289ce4"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:302px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc1b2f543-8d54-4deb-be08-868bc57b76b6%2FUntitled.png?table=block&amp;id=46b7fb61-de5e-43cd-a2bb-4539a1289ce4&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></div><div class="notion-spacer"></div></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-b0f1e34a5f0242bb83f7f49d56c2621f" data-id="b0f1e34a5f0242bb83f7f49d56c2621f"><span><div id="b0f1e34a5f0242bb83f7f49d56c2621f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b0f1e34a5f0242bb83f7f49d56c2621f" title="Thompson NFA 构造 vs DFA"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Thompson NFA 构造 vs DFA</span></span></h4><div class="notion-text notion-block-afff615182dc435797079cc33b8aefd7">为什么使用了 Thompson NFA 构造出的正则匹配会快这么多呢？主要的原因是：通过划分多个子表达式，合并相同的内容，从而减少了回溯次数。</div><div class="notion-text notion-block-6cdd0a3f42c640deb1ff811859b6d99d"><span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span> 可以转换成 Thompson 构造，图示：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-bd7f13b291b6492a8f8a5d6ca6538309"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F72c2591d-be7f-4f93-b93b-30904f2f6b6c%2FUntitled.png?table=block&amp;id=bd7f13b2-91b6-492a-8f8a-5d6ca6538309&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4adb904d36044ce89832ec563f19787d">稍微做一些解释：</div><ul class="notion-list notion-list-disc notion-block-294f0999d9db457992ec78d4fcf9fe15"><li>q 是开始，f 是结束，白圈是状态，连线是流转</li></ul><ul class="notion-list notion-list-disc notion-block-c912429971304c0ca8c14ebace72871d"><li>ε 代表着无输入</li></ul><div class="notion-text notion-block-9e2bbaa903264df6abc8ed9da0294974">通过以上的结构，Thompson NFA 匹配的时间复杂度为  <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，空间复杂度为<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>。</div><div class="notion-blank notion-block-260ec4a9ed5046938614b4ab45ae7d56"> </div><div class="notion-text notion-block-bd241b5ae0bf4d23b71a7cdd8c3e8648">而 DFA 更容易理解，因为它是典型的空间换时间。</div><div class="notion-row notion-block-8b5cf75e5a9943e0899a0d186eb3497b"><div class="notion-column notion-block-acc05c036d394d77997d269693990926" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-dd9acf4affef4e29a77df33a9f6ee061"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:424px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7febb121-726d-47a6-80c5-9351397addd6%2FUntitled.png?table=block&amp;id=dd9acf4a-ffef-4e29-a77d-f33a9f6ee061&amp;cache=v2" loading="lazy" alt="NFA" decoding="async"/><figcaption class="notion-asset-caption">NFA</figcaption></div></figure></div><div class="notion-spacer"></div><div class="notion-column notion-block-c621a865b06447f4b2fd833d81b688d3" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d8d60f096b0f4e069dc8b2409811f5ac"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:496px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F903b942f-49b7-4953-923c-55fb6d520bd5%2FUntitled.png?table=block&amp;id=d8d60f09-6b0f-4e06-9dc8-b2409811f5ac&amp;cache=v2" loading="lazy" alt="DFA" decoding="async"/><figcaption class="notion-asset-caption">DFA</figcaption></div></figure></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-323df8cbfe25433eba3d392eb38f2e8b">可以看到每一个 DFA 的状态都等同于某一时刻 NFA 状态列表，所以 DFA 在最坏情况下，空间复杂度 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，也会在构建阶段消耗更多时间。同时没有了回溯，整个匹配时间就是字符串长度，复杂度为 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>。为了保证 DFA 的空间消耗，一般都会额外对构建出的 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/DFA_minimization">DFA 做简化</a>，减少图的大小。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-ddeb7f785eb14d7b868a6917822d6ab5" data-id="ddeb7f785eb14d7b868a6917822d6ab5"><span><div id="ddeb7f785eb14d7b868a6917822d6ab5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ddeb7f785eb14d7b868a6917822d6ab5" title="为什么主流编程语言这么慢？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">为什么主流编程语言这么慢？</span></span></h4><div class="notion-text notion-block-556cfad12c9a4e90bc6a5aa982a85b89">说来有趣，Thompson NFA 构造法应该是编译原理的基础概念，DFA 方法从概念上也是比较简单，为什么当前的主流语言没有采用，反而采用了一个带有回溯的、效果远逊的版本？</div><div class="notion-text notion-block-4b68cbc5f2e14f5bbff6d29e174812aa">经过一番冲浪搜索，简单概括我找到的结论：<b>历史的局限</b>。</div><blockquote class="notion-quote notion-block-f0186a0b42784296a704da19665a61ff"><em>While writing the text editor sam [6] in the early 1980s, Rob Pike wrote a new regular expression implementation, which Dave Presotto extracted into a library that appeared in the Eighth Edition. Pike&#x27;s implementation incorporated submatch tracking into an efficient NFA simulation but, like the rest of the Eighth Edition source, was not widely distributed. Pike himself did not realize that his technique was anything new. </em><span class="notion-red"><em>Henry Spencer reimplemented the Eighth Edition library interface from scratch, but using backtracking, and released his implementation into the public domain.</em></span><em> </em><span class="notion-red"><em>It became very widely used, eventually serving as the basis for the slow regular expression implementations mentioned earlier: Perl, PCRE, Python, and so on.</em></span></blockquote><div class="notion-text notion-block-7f091f2eb6e74c62bbd877d83c1d92a8">可以从上文得知，正则匹配的实现首先需要兼容原来的使用方式，而当时开发者并未了解 NFA 模拟方法，而是自己从零实现了一个回溯方法，并且被广泛地传播开了。即使这个实现很慢，但是由于已经被大规模采用，且能满足大多数的使用场景，各个主流语言也没有替换它。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-6e320bb2c4334d31af6172db35ede111" data-id="6e320bb2c4334d31af6172db35ede111"><span><div id="6e320bb2c4334d31af6172db35ede111" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6e320bb2c4334d31af6172db35ede111" title="正面对抗 Evil Regex"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">正面对抗 Evil Regex</span></span></h3><div class="notion-text notion-block-ed1e3a4cebbf4d4689dc02e9e576134b">既然当前主流语言的实现肯定会存在性能陷阱，我们是否有办法检测邪恶正则呢？答案是肯定的。</div><div class="notion-text notion-block-787a7eab4c8143eea147b25f34efb1c4">在社区里有不少相关项目，例如：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/doyensec/regexploit">regexploit</a> 、<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/olivo/redos-detector">redos-detector</a> 、<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/davisjam/vuln-regex-detector">vuln-regex-detector</a> 等，它们都可以扫描出有风险的正则，就像这样：</div><pre class="notion-code language-shell"><code class="language-shell">$ echo <span class="token string">"(a+)+s"</span> <span class="token operator">|</span> regexploit
<span class="token literal-property property">Pattern</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token punctuation">)</span><span class="token operator">+</span>s
<span class="token operator">--</span><span class="token operator">-</span>
<span class="token function">Redos</span><span class="token punctuation">(</span>starriness<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> prefix_sequence<span class="token operator">=</span><span class="token constant">SEQ</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> redos_sequence<span class="token operator">=</span><span class="token constant">SEQ</span><span class="token punctuation">{</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">+</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">+</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> repeated_character<span class="token operator">=</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> killer<span class="token operator">=</span>None<span class="token punctuation">)</span>
Worst<span class="token operator">-</span><span class="token keyword">case</span> <span class="token literal-property property">complexity</span><span class="token operator">:</span> <span class="token number">11</span> <span class="token function">⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐</span> <span class="token punctuation">(</span>exponential<span class="token punctuation">)</span>
Repeated character<span class="token operator">:</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>
<span class="token literal-property property">Example</span><span class="token operator">:</span> <span class="token string">'a'</span> <span class="token operator">*</span> <span class="token number">3456</span></code></pre><div class="notion-text notion-block-1e6c9924ca8148c2adbe7335b9bf6c62">但是它们局限于静态的正则扫描，对于我们开发者而言，静态防御并不能完全清除风险。更好的思路是直接替换语言的默认实现。以 Python 举例，我们也找到了一些替换库：</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-8a414c655d0842eb9a242a88266b28e7" data-id="8a414c655d0842eb9a242a88266b28e7"><span><div id="8a414c655d0842eb9a242a88266b28e7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8a414c655d0842eb9a242a88266b28e7" title="pyre2"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">pyre2</span></span></h4><pre class="notion-code language-shell"><code class="language-shell">pip install pyre2</code></pre><div class="notion-text notion-block-efda542abaf5447f92a67e6709475006">来自 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/google/re2/">Google re2</a> 模块的 Python 封装 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/facebook/pyre2">pyre2</a>，使用了 DFA 的构造方式。可以替换原生 <code class="notion-inline-code">re</code> 模块，大多数场景都可以得到速度的稳步提升，不存在性能陷阱。</div><div class="notion-text notion-block-289140745a58440b96faea1ec82f6395">但对于 DFA 模拟来说，都是自古华山一条道，比如 <code class="notion-inline-code">(?P=&lt;name&gt;)</code> 这样的属于 <code class="notion-inline-code">backreference</code> 的捕获组语法就无法支持了。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-12c4a78bedf14dcf8397441db47e3f36" data-id="12c4a78bedf14dcf8397441db47e3f36"><span><div id="12c4a78bedf14dcf8397441db47e3f36" class="notion-header-anchor"></div><a class="notion-hash-link" href="#12c4a78bedf14dcf8397441db47e3f36" title="regex"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">regex</span></span></h4><pre class="notion-code language-shell"><code class="language-shell">pip install regex</code></pre><div class="notion-text notion-block-1f35e9047a1c4d47a37d67ce17ed1e04"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/mrabarnett/mrab-regex">regex</a> 模块<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/mrabarnett/mrab-regex/issues/136">并未使用 DFA 构造</a>，在完全兼容 <code class="notion-inline-code">re</code> 模块的同时，支持了一些<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/mrabarnett/mrab-regex#old-vs-new-behaviour">新特性</a>。由于实现方案的不同，也没有很明确的文档阐述，尚不清楚它具体的算法（<em>有待进一步从代码层面解读</em>），但是从效果上，它的性能要<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/mrabarnett/mrab-regex/issues/320">略好于原生模块</a>，仅从文中里例子测试看来，也规避了性能陷阱，可以谨慎采用。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-8ef69d8b54184936a684009d1c35948e" data-id="8ef69d8b54184936a684009d1c35948e"><span><div id="8ef69d8b54184936a684009d1c35948e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8ef69d8b54184936a684009d1c35948e" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h3><ul class="notion-list notion-list-disc notion-block-4c31a30c7e0e4ba19ea2a53dafd478c5"><li>和很多其他场景一样，程序需要时刻警惕用户的输入，任何不经过校验的内容都可能将程序拖垮。</li></ul><ul class="notion-list notion-list-disc notion-block-18e7ee68eda94a45b67b4c11dffeb5a7"><li>理论和实际存在各种各样的鸿沟，在面临现实场景时，理想的想法落地总是困难的。</li></ul><ul class="notion-list notion-list-disc notion-block-a5f4f5f11c0843a7b1ab7a3cbee60843"><li>原生不代表就是最优秀的。有特殊需求时可以使用社区方案进行替换。</li></ul><div class="notion-blank notion-block-3672e91b6a7c4125b6980f6f543b1536"> </div><div class="notion-text notion-block-b38fb92df2184f5096ca8ac1e6c65b00">参考：</div><ul class="notion-list notion-list-disc notion-block-2d5c165011ab41b7950ff02c9a393e88"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://swtch.com/~rsc/regexp/regexp1.html">https://swtch.com/~rsc/regexp/regexp1.html</a></li></ul><ul class="notion-list notion-list-disc notion-block-67c19c430a1c49d1ac8563f6f162c2ef"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS</a></li></ul><ul class="notion-list notion-list-disc notion-block-b05ea5bd8ae540baa38b654a5b723fac"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://shivankaul.com/blog/nfa-dfa-and-regexes">https://shivankaul.com/blog/nfa-dfa-and-regexes</a></li></ul><ul class="notion-list notion-list-disc notion-block-0049a5a2d6d54dae964b80639ecb4144"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://arstechnica.com/civis/viewtopic.php?f=20&amp;t=1195549">https://arstechnica.com/civis/viewtopic.php?f=20&amp;t=1195549</a></li></ul><ul class="notion-list notion-list-disc notion-block-237dd0aa005e4059a61b62f30bed7dc0"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://news.ycombinator.com/item?id=466957">https://news.ycombinator.com/item?id=466957</a></li></ul><ul class="notion-list notion-list-disc notion-block-9da5e5cb8a684f21bd2f67051397c140"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://medium.com/swlh/visualizing-thompsons-construction-algorithm-for-nfas-step-by-step-f92ef378581b">https://medium.com/swlh/visualizing-thompsons-construction-algorithm-for-nfas-step-by-step-f92ef378581b</a></li></ul><div class="notion-blank notion-block-3f8d2e743c47466294fb92ded6f58558"> </div></main>]]></content:encoded>
        </item>
    </channel>
</rss>