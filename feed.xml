<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>布鲁斯鱼的妙想天开</title>
        <link>https://next.emergencyexit.xyz//</link>
        <description>此间的博文大抵有两类，一种是水的，另一种仍是水的罢。 —— 鲁迅</description>
        <lastBuildDate>Wed, 12 Apr 2023 09:36:49 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-CN</language>
        <copyright>All rights reserved 2023, bluesyu</copyright>
        <item>
            <title><![CDATA[Continuous Profiling 持续分析漫谈]]></title>
            <link>https://next.emergencyexit.xyz//continuous-profiling</link>
            <guid>https://next.emergencyexit.xyz//continuous-profiling</guid>
            <pubDate>Wed, 12 Apr 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[漫谈就是什么都谈，又好像什么都没谈]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-9faa9c16825a40c0898f7b9f31c30722"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-5baa35ba29014df78acc535c25618622"><a href="#1d5116a24dda4e10baf5b2bd60951ecb" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">What ?</span></a><a href="#face42b936b945b49f132f1b07d05168" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Profiling vs Continuous Profiling</span></a><a href="#206bb88933be49679f368558bcc606e7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">来龙</span></a><a href="#ed9e1ca699764d0eb6deedd2e8828630" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">去脉</span></a><a href="#ff8aa8cb27304cf9b83c7ba73db89db4" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Why ?</span></a><a href="#75952cf6b2114d39b3854bae190044c4" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">开源方案</span></a><a href="#3314794fb53c45d5a3a2c663c6c31feb" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Pyroscope</span></a><a href="#2d043ca42a0a4a579def0858bbd3bd05" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">语言支持</span></a><a href="#08786eb20478421a81fb47dd7bf5b366" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">存储优化</span></a><a href="#37e40bbda9a749daa1a67892cc97d832" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">总结</span></a><a href="#076bbf9997b94a71ab23682052568fc4" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Parca</span></a><a href="#88491eadc7ff407a9a64160c71a85044" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">eBPF Agent</span></a><a href="#a60e62ba31514a2d899cfa999592dc00" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">Meta Sample 分离存储</span></a><a href="#4c1de643193b4a2fbd6f04e44ebf9978" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">总结</span></a><a href="#f2770103f80e4810bf88b50be6f34f55" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Phlare</span></a><a href="#bd78b2d100614fbf9dc9dd151a176579" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">水平扩展</span></a><a href="#6418d4f2c11e4b0d9c50138a28b47cc0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">分级存储</span></a><a href="#8e4d8ade7820401ebdcf474902336cc0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">总结</span></a><a href="#617226dac0924b34adb5c589ea30c6d9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Pixie</span></a><a href="#e00ee34fb0844b0d989297233c5e626e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">商业软件</span></a><a href="#6de913a222044b2496063feb21c4ff9e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Datadog Continuous Profiler</span></a><a href="#05c52ae909e04cf1899de9f07940e7f1" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">可以细粒度控制 function 展示内容</span></a><a href="#23f4922cd3cd4a3c97f5f3c0def5c118" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">Only My Code 可以聚焦于用户代码</span></a><a href="#6be2086592f947ad9a39f664cbd00cba" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">对比图表直观清晰</span></a><a href="#8b8b5ae4a8bd483092fd8bd09622f708" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">常用的数据聚合快捷入口</span></a><a href="#f427825cc82d402a951d6bbc75022f29" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:48px">Elastic Profiler?</span></a><a href="#8bb6b79be1494abd95fc05375e139b88" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">方案选型对抗赛</span></a><a href="#729375fb46d2432a971f3de708f5fa8c" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">推 vs 拉</span></a><a href="#492b9ded6ab74c859f1b670c85082431" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">存算分离 vs 存算一体</span></a><a href="#3b4160403f964f46818d70117d0dd1ec" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">块存储 vs 对象存储</span></a><a href="#61ca23ded6ce4926892710f5dc7049d9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">eBPF vs Native Language Tools</span></a><a href="#f9474cb377364a1faa740d5276deb613" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">pprof vs OT</span></a><a href="#e6f5bc4ccbe141c492231597ed30f5d1" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-1d5116a24dda4e10baf5b2bd60951ecb" data-id="1d5116a24dda4e10baf5b2bd60951ecb"><span><div id="1d5116a24dda4e10baf5b2bd60951ecb" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1d5116a24dda4e10baf5b2bd60951ecb" title="What ?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">What ?</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-face42b936b945b49f132f1b07d05168" data-id="face42b936b945b49f132f1b07d05168"><span><div id="face42b936b945b49f132f1b07d05168" class="notion-header-anchor"></div><a class="notion-hash-link" href="#face42b936b945b49f132f1b07d05168" title="Profiling vs Continuous Profiling"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Profiling vs Continuous Profiling</span></span></h3><div class="notion-text notion-block-3cd4891367c4492b84d0108e79327646">相信各位开发老司机都给自己的程序“号过脉”，所以对于 Profiling 一定不陌生，在这里我还是搬一下 Profiling 的定义: </div><blockquote class="notion-quote notion-block-7c482f03931a47a3a6acabc2bf6fdc76">Profiling 是一种性能分析工具，用于确定程序或系统中哪些部分消耗了最多的资源（例如 CPU、内存、磁盘和网络）。它可以帮助开发人员找到性能瓶颈并改进代码。</blockquote><div class="notion-text notion-block-96dd4b4e95ca4598832c12ddeb6ae405">而 Continuous Profiling 就是在这个基础上，增加一个“持续”，也就是在生产环境里定期跑 Profiling 并将数据上报。</div><div class="notion-text notion-block-449915989c90440c869c46c0e8aefbf1">通常开发者手动跑 Profiling 往往是发现了线上代码性能瓶颈后，用工具<b>尝试复现瓶颈</b>，而 Continuous 最大的优势就是：持续意味着贯穿整个程序的完整生命周期，不会漏掉任何一个历史上产生过的异常，能直接从数据中找到“现场”，而不是尝试复现。</div><div class="notion-text notion-block-abb00b4c6d0d41c38afc4fab94df4e48">用一个非常直观的比较就能迅速理解二者的差异：如果 Profiling 最有代表性展示方式是火焰图的话，那么 Continuous Profiling 的表现形式就是带有时序功能的火焰图，你可以在拖动展示、对比不同时刻的火焰图，找到代码在时间维度上的性能变迁。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-12cfaf12fa4049b599e8333b9af2abac"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F63089862-ccda-4eda-bc70-c6b6b63e3f29%2FUntitled.png%3Fid%3D12cfaf12-fa40-49b5-99e8-333b9af2abac%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607212%26signature%3DuBImuiM4S29NzjATbO3TGmeNQL5fJpy9raEoCevYoi8?table=block&amp;id=12cfaf12-fa40-49b5-99e8-333b9af2abac&amp;cache=v2" loading="lazy" alt="一个典型的例子" decoding="async"/><figcaption class="notion-asset-caption">一个典型的例子</figcaption></div></figure><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-206bb88933be49679f368558bcc606e7" data-id="206bb88933be49679f368558bcc606e7"><span><div id="206bb88933be49679f368558bcc606e7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#206bb88933be49679f368558bcc606e7" title="来龙"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">来龙</span></span></h3><div class="notion-text notion-block-dfe8cabb47ec4bb5b63c62b5c96c614c">Continuous Profiling 这个概念最早出自 Google 2010 年的研究文章： <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://research.google/pubs/pub36575/">Google-Wide Profiling</a> 。它虽然没有直接输出可用的工具，但是却给这个理念“打了样”：以较低的开销（～0.01% Overhead) 换取了大量对生产有用的代码状态数据，并且通过类 SQL 的方式查询以定位问题。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-ed9e1ca699764d0eb6deedd2e8828630" data-id="ed9e1ca699764d0eb6deedd2e8828630"><span><div id="ed9e1ca699764d0eb6deedd2e8828630" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ed9e1ca699764d0eb6deedd2e8828630" title="去脉"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">去脉</span></span></h3><div class="notion-text notion-block-dd03b69112404d01b0b226abdfc55d61">转眼到了十多年后，这期间有不少开源或商业软件涌现，但 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/open-telemetry/oteps/issues/139">OpenTelemetry 的加入</a>给了 Continuous Profiling 领域一个确定的未来。</div><blockquote class="notion-quote notion-block-635a88233c1445e2afedf2315c50b516">&quot;Four pillars&quot; </blockquote><div class="notion-text notion-block-11cf641a9e2d463c8fca31c7c45ab36e">在 Monitoring, Logging, Tracing 三大支柱的工具链逐渐完善后，Profiling 将成为可观测领域新的支柱。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-ff8aa8cb27304cf9b83c7ba73db89db4" data-id="ff8aa8cb27304cf9b83c7ba73db89db4"><span><div id="ff8aa8cb27304cf9b83c7ba73db89db4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ff8aa8cb27304cf9b83c7ba73db89db4" title="Why ?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Why ?</span></span></h2><div class="notion-text notion-block-7f1458051efa42e085e7b6771209e858">借用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/open-telemetry/oteps/blob/main/text/profiles/0212-profiling-vision.md#profiling-use-cases">OT Profiling Vision</a> 里列举的一些场景：</div><ul class="notion-list notion-list-disc notion-block-cbc020f0094c4bba8ece9c29b911a3bc"><li>跟踪应用程序的资源利用情况，以了解代码更改、硬件配置更改和临时环境问题如何影响性能</li></ul><ul class="notion-list notion-list-disc notion-block-fa770be690a34f3a8cb6b11545b435e9"><li>理解哪些代码负责消耗资源（例如 CPU、内存、磁盘、网络）</li></ul><ul class="notion-list notion-list-disc notion-block-7dcb3a9eeb364513926b0fb7b1f10ebf"><li>为在生产中运行的一组服务规划资源分配</li></ul><ul class="notion-list notion-list-disc notion-block-211ac4b4a1644bcab9f3e8d5523795bc"><li>比较不同代码版本的配置文件，了解代码如何随时间改进或退化</li></ul><ul class="notion-list notion-list-disc notion-block-498c3037f7224b47a5b0c66fd8e69177"><li>在生产中检测经常使用的和“死”代码</li></ul><ul class="notion-list notion-list-disc notion-block-c7854492820e4509a70e05fe7c870d52"><li>将跟踪跨度分解为代码级粒度（例如函数调用和代码行），以了解该特定单元的性能</li></ul><div class="notion-text notion-block-c93e9981143c48cf96a2d8ec8b784443">简而言之，Continue Profiling 可以帮助开发者掌握代码的“持续生产状态”。对于 DevOps 团队而言，它应该是 CD 后进行持续分析的一部分。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-43e2167daba84f9fadeec2a1df9e27be"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:641px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fd7c357f0-60a3-4143-99d7-8bb5e48c4d3c%2Fci_cd_cp.png%3Fid%3D43e2167d-aba8-4f9f-adee-c2a1df9e27be%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607211%26signature%3Dd-nGxJVIW0-Rr9BoDbH-nLholtXTA8j9jHgfqJEcvpE?table=block&amp;id=43e2167d-aba8-4f9f-adee-c2a1df9e27be&amp;cache=v2" loading="lazy" alt="CI → CD → CP" decoding="async"/><figcaption class="notion-asset-caption">CI → CD → CP</figcaption></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-75952cf6b2114d39b3854bae190044c4" data-id="75952cf6b2114d39b3854bae190044c4"><span><div id="75952cf6b2114d39b3854bae190044c4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#75952cf6b2114d39b3854bae190044c4" title="开源方案"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">开源方案</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3314794fb53c45d5a3a2c663c6c31feb" data-id="3314794fb53c45d5a3a2c663c6c31feb"><span><div id="3314794fb53c45d5a3a2c663c6c31feb" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3314794fb53c45d5a3a2c663c6c31feb" title="Pyroscope"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Pyroscope</span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-a80d3ca9d6bf432d8af5b230ce8e316e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fcbb841eb-f3d2-4eb5-96d9-dbd145229387%2FUntitled.png%3Fid%3Da80d3ca9-d6bf-432d-8af5-b230ce8e316e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607198%26signature%3DA_1ird6Ndpa1iXnQfzVCR24PDyRMx0uXPh9NYYYPXdA?table=block&amp;id=a80d3ca9-d6bf-432d-8af5-b230ce8e316e&amp;cache=v2" loading="lazy" alt="架构图" decoding="async"/><figcaption class="notion-asset-caption">架构图</figcaption></div></figure><div class="notion-text notion-block-fd6ad36920ce4430b2d066a3d12a09e9"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/pyroscope">Pyroscope</a> 项目算是这个领域中最热门的种子选手了。相较于其他几个项目有这么几个显著的优势：</div><ul class="notion-list notion-list-disc notion-block-6a16796c51eb45e5b44fd9e272ba3863"><li>UI 清晰美观，功能齐全，可以从官方提供的 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://demo.pyroscope.io/">demo</a> 窥见一二</li></ul><ul class="notion-list notion-list-disc notion-block-87f47658ccc64b75bca769bb413ffaad"><li>支持的语言广泛</li></ul><ul class="notion-list notion-list-disc notion-block-e694bbd59cbb4dc288836b8b6e22b6a9"><li>支持<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/pyroscope-io/otel-profiling-go"> Go\Java 的 Tracer 整合方案</a></li></ul><ul class="notion-list notion-list-disc notion-block-92b2af7fada54185a701bfc665d76ee8"><li>对存储有着额外的优化</li></ul><div class="notion-blank notion-block-6457ad46132e40518094645d0c94e2e0"> </div><div class="notion-text notion-block-a09a185df8f648df83cfd8e98e36473e">下面会针对一些有特点的优势展开说说：</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-2d043ca42a0a4a579def0858bbd3bd05" data-id="2d043ca42a0a4a579def0858bbd3bd05"><span><div id="2d043ca42a0a4a579def0858bbd3bd05" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2d043ca42a0a4a579def0858bbd3bd05" title="语言支持"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">语言支持</span></span></h4><div class="notion-text notion-block-e09cda5a8d6d4ec3afc15f038c6bfd37">上面有提到，Pyroscope 对于 pull 和 push 模型都有着完备的支持，最大的原因就是它针对各个语言的采集工具上都做了适配，并封装成了 SDK：</div><ul class="notion-list notion-list-disc notion-block-64ce02c0d80f4c1eb01a3416d04a88ef"><li>Go: pprof</li></ul><ul class="notion-list notion-list-disc notion-block-8aea834ea1b846ab9f572023b699122c"><li>ruby: rbspy</li></ul><ul class="notion-list notion-list-disc notion-block-8d2876d7fc8b451bb9c0ecfb7c873a8e"><li>python: py-spy</li></ul><ul class="notion-list notion-list-disc notion-block-3f1641beb763490f84533125077ae361"><li>Java: async-profiler</li></ul><ul class="notion-list notion-list-disc notion-block-a29951416c6f441c8ba66c56356018ac"><li>php: phpspy</li></ul><ul class="notion-list notion-list-disc notion-block-8d064bb078c14a71bd96dd08a7a7867b"><li>.NET: dotnet trace</li></ul><ul class="notion-list notion-list-disc notion-block-0296b97b1cfa4a8db27265d372f617fc"><li>Rust: pprof-rs</li></ul><div class="notion-text notion-block-00852e1981984a5e9200f1988a79b716">即使部分语言的支持并不完美（例如 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/pyroscope/issues/316">Python 不支持 Memory 数据上报</a>），但鉴于其他项目基本都只支持 Go + pprof，在面临多语言环境时，Pyroscope 基本是开源的唯一选择。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-08786eb20478421a81fb47dd7bf5b366" data-id="08786eb20478421a81fb47dd7bf5b366"><span><div id="08786eb20478421a81fb47dd7bf5b366" class="notion-header-anchor"></div><a class="notion-hash-link" href="#08786eb20478421a81fb47dd7bf5b366" title="存储优化"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title"><b>存储优化</b></span></span></h4><div class="notion-text notion-block-e178846c8fc64ba5a937b10aa103dc65">与其他几个项目还有一个很大的不同，pyroscope 在 profiling 数据的存储上做了额外的优化，开发者专门写了<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://pyroscope.io/docs/storage-design/">一篇 Blog 介绍了思路</a>。在这里做下简要的介绍并分析。</div><div class="notion-text notion-block-81436e3f7d3e416aae5769ef6d67ed44">首先是借助树和字典树，它针对 Profiling 的重复数据做了压缩。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-9338f096d1654d938c521f62f398c4bd"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F9e702fd3-af76-4d02-8c0a-a63492cc01aa%2Fstorage.gif%3Fid%3D9338f096-d165-4d93-8c52-1f62f398c4bd%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607198%26signature%3DZeSK9ZXSqYMgO--gpO6_gvjllTqgAgW8JXFIKYbKHMM?table=block&amp;id=9338f096-d165-4d93-8c52-1f62f398c4bd&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-59e4348f998e4206bf7bd0023e8a8e87">其次，为了解决长时间跨度数据的查询延迟问题，利用线段树对数据进行了预合并。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-5a0fd51dfc174e8ab3be79d680bc26a5"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F933febec-2e5c-44e4-ad8a-d18c952064d6%2Fsegment.gif%3Fid%3D5a0fd51d-fc17-4e8a-b3be-79d680bc26a5%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607212%26signature%3DziWrB2FOo-s5Pt0Kkww3kdM_Sc6k4hTW8YV4quNViFA?table=block&amp;id=5a0fd51d-fc17-4e8a-b3be-79d680bc26a5&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4e7f4491b1fd4bd0a7c9d949749fa38e">虽然和其他项目一样，它的存储逻辑模型基本依照 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/google/pprof/blob/main/proto/profile.proto">pprof 定义</a>，得益于这些优化，它在存储空间和读取延迟上都有更好的表现。但也带来了一些其他的问题：</div><ul class="notion-list notion-list-disc notion-block-dfcfa7b637974d1a8f5e8e0fc601ed68"><li>为了更容易实现这些优化，存储引擎选择了灵活的 K-V 结构内嵌引擎 BadgerDB，也因此失去了更好的水平扩展能力。</li></ul><ul class="notion-list notion-list-disc notion-block-bb062c71c23948d98d568f80d64fabae"><li>在结构落库时需要消耗更多的 CPU 计算，压测时 CPU 更容易出现瓶颈。</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-37e40bbda9a749daa1a67892cc97d832" data-id="37e40bbda9a749daa1a67892cc97d832"><span><div id="37e40bbda9a749daa1a67892cc97d832" class="notion-header-anchor"></div><a class="notion-hash-link" href="#37e40bbda9a749daa1a67892cc97d832" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h4><div class="notion-text notion-block-e976ec5fe5fe45c585fb7ee41d1746db">Pyroscope 绝对是 Profiling 领域的开源种子选手，它的长板很长（语言支持、存储优化等），同时考虑到最近被 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://grafana.com/blog/2023/03/15/pyroscope-grafana-phlare-join-for-oss-continuous-profiling/">Grafana Labs 收购</a>，原来的短板恰好是 Grafana 团队擅长处理的，相信等待一段时间的发展，Pyroscope 有潜力成为该领域的<b>开源标准答案</b>。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-076bbf9997b94a71ab23682052568fc4" data-id="076bbf9997b94a71ab23682052568fc4"><span><div id="076bbf9997b94a71ab23682052568fc4" class="notion-header-anchor"></div><a class="notion-hash-link" href="#076bbf9997b94a71ab23682052568fc4" title="Parca"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Parca</span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-220a046a390c49569d06210dbaaf21db"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:150px"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fce81fb64-8a5f-4466-8745-857180009084%2FParca_Overview.svg%3Fid%3D220a046a-390c-4956-9d06-210dbaaf21db%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607201%26signature%3DGNd31pf4QI9leQDHTrf-_2wh7OxOl6k1HrUHl-GqdGM?table=block&amp;id=220a046a-390c-4956-9d06-210dbaaf21db&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-d81dc4adb7ba4611bea062f04f74ff7f"> </div><div class="notion-text notion-block-1a3c33f64c9e4a63b1e996674a74f62b"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/parca-dev/parca/">Parca</a> 项目是由原 Prometheus 团队的开发者开发，带有浓浓的 Prometheus 的味道。相较于其他项目，它也有几个显著的特点：</div><ul class="notion-list notion-list-disc notion-block-67b2a209de734b0dac7aa1615518435f"><li>Agent 完全采用了 ebpf  作为采集方案</li></ul><ul class="notion-list notion-list-disc notion-block-0804f542fd8a45429a71579962335f5b"><li>Profile Meta 和 Profile Sample 使用了两种不同的引擎存储，其中 Sample 存储采用了自研的内嵌列存 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/polarsignals/frostdb">FrostDB</a></li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-88491eadc7ff407a9a64160c71a85044" data-id="88491eadc7ff407a9a64160c71a85044"><span><div id="88491eadc7ff407a9a64160c71a85044" class="notion-header-anchor"></div><a class="notion-hash-link" href="#88491eadc7ff407a9a64160c71a85044" title="eBPF Agent"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">eBPF Agent</span></span></h4><div class="notion-text notion-block-d7cc5e3f224d4df29528e14ea39e56fd">近几年 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://ebpf.io/">eBPF</a> 在云原生、可观测领域讨论度很高，相信紧跟热点的各位读者也是早有耳闻，我在这里就不做多的赘述。Parca 最显著的一个特点就是在 Agent 上完全使用 eBPF 来解决问题。以下是一个简化的处理流程：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-2feb672e1a784431a03fcaa90749554e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fc0197489-56d8-4b57-8710-f6b517f8fcba%2FPasted_image_20230113174652.png%3Fid%3D2feb672e-1a78-4431-a03f-caa90749554e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607198%26signature%3DPDCVFiQ9qyAOhnEC3pm5_aoOcX-JfgNe5UaRXPU0Dyw?table=block&amp;id=2feb672e-1a78-4431-a03f-caa90749554e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-fcbebe65025c41548496140149b36e9e">在 Profiling 领域，eBPF 的优劣我们会在后面的章节谈到，这里就一笔带过了。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-a60e62ba31514a2d899cfa999592dc00" data-id="a60e62ba31514a2d899cfa999592dc00"><span><div id="a60e62ba31514a2d899cfa999592dc00" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a60e62ba31514a2d899cfa999592dc00" title="Meta Sample 分离存储"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Meta Sample 分离存储</span></span></h4><div class="notion-text notion-block-2f3a7263aabc473bb644365009281f93">Parca 和其他项目一样，存储的逻辑模型也是依照 pprof 的数据定义，而 pprof 逻辑模型中，按照其不同的特性，可以划分为两类数据：<b>Meta 和 Sample</b>。所谓的分离存储，实际上是讨论：<b>这两类数据是否使用不同的存储引擎。</b></div><table class="notion-simple-table notion-block-12da01c5a71b44e989025837ba513115"><tbody><tr class="notion-simple-table-row notion-block-e7c505e720604348851134b3e8737e6f"><td class="" style="width:120px"><div class="notion-simple-table-cell">类型/特性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">具体内容</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">是否需要计算</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">数据量级</div></td></tr><tr class="notion-simple-table-row notion-block-e83d4d870fe64139ad9f8afa128ac8e4"><td class="" style="width:120px"><div class="notion-simple-table-cell">Metadata</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">Function/Mapping/Location 等</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">很少</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">较小</div></td></tr><tr class="notion-simple-table-row notion-block-89fa559f828f4751a31052b880e6f8a6"><td class="" style="width:120px"><div class="notion-simple-table-cell">Sample</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">时序的 Stacktrace</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">大量合并计算</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">大</div></td></tr></tbody></table><div class="notion-text notion-block-46e77f4d1a8a4bf2a8b1e8d915ad3311">由于以上特性，二者的读写需求也不同，所以顺其自然的想法就是将其分成不同的引擎存储。</div><table class="notion-simple-table notion-block-17365db1ff864361bf2545e52b8392a6"><tbody><tr class="notion-simple-table-row notion-block-13051b7e3fe24afb9f0f30f9d09ccacd"><td class="" style="width:120px"><div class="notion-simple-table-cell">方式/特性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">开发便捷性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">后期存储维护性</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">存储引擎选择空间</div></td></tr><tr class="notion-simple-table-row notion-block-f56ed814e806402a8e05eefd3b153340"><td class="" style="width:120px"><div class="notion-simple-table-cell">统一存放</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">高</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">一般</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">一般</div></td></tr><tr class="notion-simple-table-row notion-block-f8816f65d78846c7bef7c60baf91c49d"><td class="" style="width:120px"><div class="notion-simple-table-cell">分离存放</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">较低</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">高</div></td><td class="" style="width:120px"><div class="notion-simple-table-cell">高</div></td></tr></tbody></table><div class="notion-text notion-block-9b3122f2d68544ccb5e4045187dbe25f">相较于后期的维护性，开发便捷性的损失是一次性且短期的，且不分离的情况是不太方便针对二者特性做针对性优化的。所以 Meta / Sample 分离存储，对于服务的“长治久安”有着更好的积极意义。<em>当然 Parca 目前在 Sample 存储上使用的 FrostDB 还未到可以直接生产的阶段，目前仅是 Parca 专用内嵌引擎。</em></div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-4c1de643193b4a2fbd6f04e44ebf9978" data-id="4c1de643193b4a2fbd6f04e44ebf9978"><span><div id="4c1de643193b4a2fbd6f04e44ebf9978" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4c1de643193b4a2fbd6f04e44ebf9978" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h4><div class="notion-text notion-block-eb594843a6c64160bc81dddc4ca6bca3">Parca 项目在 Agent 选择和存储设计上有独到之处，虽然在语言支持上比较少（Go 和有限的 Java），但仍旧可以作为方案设计上的重要参考。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f2770103f80e4810bf88b50be6f34f55" data-id="f2770103f80e4810bf88b50be6f34f55"><span><div id="f2770103f80e4810bf88b50be6f34f55" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f2770103f80e4810bf88b50be6f34f55" title="Phlare"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Phlare</span></span></h3><div class="notion-row notion-block-9da5ce52ec33408a920005e785402e04"><div class="notion-column notion-block-9c6db133b2f54cad9f644e16783bd111" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.25)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-246d23ebb5b340fdb8c534f8b2dbffe6"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:192px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fcb2d83a7-b7b5-4e45-8d72-0ac07fce9042%2FUntitled.png%3Fid%3D246d23eb-b5b3-40fd-b8c5-34f8b2dbffe6%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607204%26signature%3DlRk9UUEgk59vfzbZAOaptADIvoajOxhQmjHXMMORjMM?table=block&amp;id=246d23eb-b5b3-40fd-b8c5-34f8b2dbffe6&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></div><div class="notion-spacer"></div><div class="notion-column notion-block-526b9dadc3e4407a997e91102bf5e51d" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.75)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-727db1ff238b48a4831d8797ccfa555e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F87cd1ef9-8c30-4c64-8e0f-c2c6aa20da27%2FUntitled.png%3Fid%3D727db1ff-238b-48a4-831d-8797ccfa555e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607206%26signature%3Dhksf1gSKByRPnFUUBaAK70Ss_FLwN_OcCERMBIZG1L8?table=block&amp;id=727db1ff-238b-48a4-831d-8797ccfa555e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-b2293d9a71bc457d8827a793da2c3445"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/phlare">Phlare</a> 是 Grafana Labs 出品的 Profiling 产品，随着 Pyroscope 被收购，Phlare 项目很可能会被直接揉碎，合并到 Pyroscope 中去。即便如此，Phlare 项目仍旧有着不少有意思的亮点：</div><ul class="notion-list notion-list-disc notion-block-0232149f3a7a4cb384aa7e3ae1746c2c"><li>支持 monolithic/microservices 两种启动模式，既能满足快速验证，又能在大规模部署中轻易水平扩展</li></ul><ul class="notion-list notion-list-disc notion-block-23ce3432c80946d493d2262ffc13ff25"><li>数据存储分层，热数据存放在 ingster 的本地块存储中，冷数据发送到远端的对象存储中，总占有成本 TCO 较低（当然是存储空间的，没有考量到对象存储发送带来的带宽成本）</li></ul><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-bd78b2d100614fbf9dc9dd151a176579" data-id="bd78b2d100614fbf9dc9dd151a176579"><span><div id="bd78b2d100614fbf9dc9dd151a176579" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bd78b2d100614fbf9dc9dd151a176579" title="水平扩展"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">水平扩展</span></span></h4><div class="notion-text notion-block-b11bc31a057e44b7a5572a0844f3b0c1">相较于 Parca 和 Pyroscope，Phlare 总算把工程的扩展能力当作重要考量了。要知道前面二者想要水平扩展，无论是想扩展读或者写的能力，都只能将整个进程跑起来，存储走 remote write 的方式，既笨拙又浪费资源，难称优雅。而 Phlare 具备以微服务部署的能力，qureier 和 distrubutor 可以较轻松地水平扩展。</div><ul class="notion-list notion-list-disc notion-block-6ad656e2dd1d402e99076d562540f7d9"><li>在存储上通过一致性哈希解决分片问题</li></ul><ul class="notion-list notion-list-disc notion-block-f642c64176f94b1aa709966cfa0d891b"><li>通过 Gossip 解决分布式选主问题</li></ul><div class="notion-text notion-block-79b9e13d7c284eb78e5005bc2c016d8f">为了更好地理解它是如何工作的，以四个 ingester 和一个位于0和9之间的令牌空间为例（<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://grafana.com/docs/phlare/latest/operators-guide/architecture/hash-ring/#a-practical-example">来源</a>）：</div><ul class="notion-list notion-list-disc notion-block-0abb44d9585a4ccc824b5ddf30c97fb7"><li>ingester#1在令牌环中注册令牌<code class="notion-inline-code">2</code></li></ul><ul class="notion-list notion-list-disc notion-block-c07c3761d32047ad8eb3adb0487e7652"><li>ingester#2在令牌环中注册令牌<code class="notion-inline-code">4</code></li></ul><ul class="notion-list notion-list-disc notion-block-baa45b6b8f6148cba4455c18a7f7eb4d"><li>ingester#3在令牌环中注册令牌<code class="notion-inline-code">6</code></li></ul><ul class="notion-list notion-list-disc notion-block-eaf4410a5f0b4d5193e5cdf5d2657eb9"><li>ingester#4在令牌环中注册令牌<code class="notion-inline-code">9</code></li></ul><div class="notion-text notion-block-b894ea0988e449af8745088af1efa4a8">当它接收到一个带有 label <code class="notion-inline-code">{</code><code class="notion-inline-code"><b>name</b></code><code class="notion-inline-code">=&quot;process_cpu&quot;, instance=&quot;1.1.1.1&quot;}</code> 的 Profile 数据时，它会将 label 内容进行哈希计算，假如这次计算后的结果是 <code class="notion-inline-code">3</code> 。为了找到对应的 ingester，将会尝试寻找哈希环上 token 值上大于 <code class="notion-inline-code">3</code> 最靠近的一个，即 ingester#2，并认为它将是这份 Profile 的权威数据拥有者。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-418f8f28c28d431c9066d18a902fc56c"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fa9b13bb1-7174-46a7-ba2e-98d9804ae94c%2FUntitled.png%3Fid%3D418f8f28-c28d-431c-9066-d18a902fc56c%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607202%26signature%3DQuZkkYrH4O9BaYgALKicFK20oqNtuiTjfwxA7TIvFks?table=block&amp;id=418f8f28-c28d-431c-9066-d18a902fc56c&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-1f2d089073794a2c961af4aafb4d2eeb">此时， Ingester 的副本数设置如果是 3 个，在 ingester#2 被选主后，将继续向后寻找接下来的两个实例，即 ingester#3 &amp; ingester#4，并将数据复制分摊到他们的存储中，以保证数据能够均匀地被复制成多副本来保证高可用。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-b63c5b803d2d46998fd3fc48ed2674f0"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fa86cc56a-1126-4d9d-984c-3d1ebd31c01a%2FUntitled.png%3Fid%3Db63c5b80-3d2d-4699-8fd3-fc48ed2674f0%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607199%26signature%3D_2SpRLOXdCLXvM9mVd_iQbk2bOvC8aM0dWuryuHY-Bo?table=block&amp;id=b63c5b80-3d2d-4699-8fd3-fc48ed2674f0&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-6418d4f2c11e4b0d9c50138a28b47cc0" data-id="6418d4f2c11e4b0d9c50138a28b47cc0"><span><div id="6418d4f2c11e4b0d9c50138a28b47cc0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6418d4f2c11e4b0d9c50138a28b47cc0" title="分级存储"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">分级存储</span></span></h4><div class="notion-text notion-block-1499e616f1614485a163a068227e4b8c">phlare 的存储流程较为复杂，主要分成了三个部分：</div><ul class="notion-list notion-list-disc notion-block-d1982325a2e143df85159efe7f5d819f"><li>head block，ingester 模块获取到数据后不会立即写入到长期存储中，而是首先放在内存</li></ul><ul class="notion-list notion-list-disc notion-block-4098b0b3a6e242e09baa0c03e48c3251"><li>当 head block 大小超限或者超时，会将这些数据写到 ingester 本地磁盘</li></ul><ul class="notion-list notion-list-disc notion-block-2a79cae4a8f74c0ead71e87ac1532eb8"><li>内存和磁盘的数据都将会周期上报到 Long term storage</li></ul><div class="notion-text notion-block-d54af76f9e3540568914ee603bd3f859">这样做的好处显而易见：</div><ul class="notion-list notion-list-disc notion-block-226d9fce607249a896978d3c694c006b"><li>最热的数据将在内存中被访问，速度最快</li></ul><ul class="notion-list notion-list-disc notion-block-a8f0029cb20a4ba3b36156f7b145d2fc"><li>大量的冷数据放到了对象存储，成本更低</li></ul><div class="notion-text notion-block-77b99172e84b45318da712e7b41575f7">但也有些问题，就像上面 <code class="notion-inline-code">read path</code> 中表述的，对象存储中冷数据的读取问题会存在延迟问题，后面在对象存储和块存储的对比环节会稍微展开。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-8e4d8ade7820401ebdcf474902336cc0" data-id="8e4d8ade7820401ebdcf474902336cc0"><span><div id="8e4d8ade7820401ebdcf474902336cc0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8e4d8ade7820401ebdcf474902336cc0" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h4><div class="notion-text notion-block-cd1e02de1ac640358de6201ae337a5b5">Phlare 相较于 Parca 和 Pyroscope 增加了更多工程上的探索，它比后两者都更容易在大集群中部署和扩展，但它只支持 pprof Http 端点数据拉取，仅有 Go 能够被较好的支持，这也成了它没法被大规模采用的最大障碍。在 Pyroscope 被收购后，Phlare 的这些工程特点也许会被整合到前者里去，就让我们继续关注接下来会发生什么吧。 </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-617226dac0924b34adb5c589ea30c6d9" data-id="617226dac0924b34adb5c589ea30c6d9"><span><div id="617226dac0924b34adb5c589ea30c6d9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#617226dac0924b34adb5c589ea30c6d9" title="Pixie"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Pixie</span></span></h3><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-df187fd9c3d64b68803fe7015fb83b79"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F04cb20ca-0d39-4887-90b1-b156b1c5e266%2FPasted_image_20230106143708.png%3Fid%3Ddf187fd9-c3d6-4b68-803f-e7015fb83b79%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607198%26signature%3D4Fc_uV-4nu_tjxfQaR8fU25p141g0ySQ3alqtV4MufY?table=block&amp;id=df187fd9-c3d6-4b68-803f-e7015fb83b79&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-32aa0517a8c648a586437c1bd3cd8a4a"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/pixie-io/pixie">pixie</a> 实际上并不是一个 Profiling 专用软件，而是一个 K8S 应用的观测工具。除了 Profiling 以外，它还包括了Service 映射、集群资源、应用流量等能力。我们这里仅关注它的 Continuous Profiling 能力。</div><div class="notion-text notion-block-cf8de9121c9649d786a77600dbc8fc13">相较于以上其他开源软件，它又有一些不同的特点：</div><ul class="notion-list notion-list-disc notion-block-e876d5c1fd4f42c9992cdc75dc106cc7"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.px.dev/reference/pxl/">PxL</a>，用于查询 SQL 不再是 PromQL like 而是 Python 风格</li></ul><ul class="notion-list notion-list-disc notion-block-78fe8bc96a2c4353987bfea9ef58a589"><li>与 K8S 集群绑定较强，不适合部署在物理机的服务</li></ul><ul class="notion-list notion-list-disc notion-block-e49581c5d352403caae0ebd5f1eacb11"><li>底层使用 eBPF 采集数据，编译型语言支持更好</li></ul><ul class="notion-list notion-list-disc notion-block-66c292295b0e4d02b6114870c302d564"><li>仅限于 CPU Profiling</li></ul><div class="notion-text notion-block-1b1638fc5f1a46c09c79c08a66ded20b">由于它在 Profiling 领域着墨不多，功能也相对简单，这里就不做过多展开了。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-e00ee34fb0844b0d989297233c5e626e" data-id="e00ee34fb0844b0d989297233c5e626e"><span><div id="e00ee34fb0844b0d989297233c5e626e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e00ee34fb0844b0d989297233c5e626e" title="商业软件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">商业软件</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-6de913a222044b2496063feb21c4ff9e" data-id="6de913a222044b2496063feb21c4ff9e"><span><div id="6de913a222044b2496063feb21c4ff9e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6de913a222044b2496063feb21c4ff9e" title="Datadog Continuous Profiler"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Datadog Continuous Profiler</span></span></h3><div class="notion-text notion-block-6d22ce30e1e14355b971b895fa8e3775">Datadog 作为可观测的商业 SaaS 产品巨头，推出的 Profiler 产品质量非常高，由于它的闭源性，我们很难分析它具体的技术架构，仅从它产品表现来窥见一二。</div><div class="notion-text notion-block-bb9bbc619d7d45a28291756594c5d74b">以下是一些 Datadog 有别于开源产品的亮眼功能。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-05c52ae909e04cf1899de9f07940e7f1" data-id="05c52ae909e04cf1899de9f07940e7f1"><span><div id="05c52ae909e04cf1899de9f07940e7f1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#05c52ae909e04cf1899de9f07940e7f1" title="可以细粒度控制 function 展示内容"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">可以细粒度控制 function 展示内容</span></span></h4><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-825348739a044914904a996da3771045"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F4c5de3f5-8b9f-4027-bd50-bab3528a30fe%2FPasted_image_20230209155039.png%3Fid%3D82534873-9a04-4914-904a-996da3771045%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607213%26signature%3Du3Qicsxeda1i4kLan5K4YmHyipBnJ3Eh22lzrlc4ETA?table=block&amp;id=82534873-9a04-4914-904a-996da3771045&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-23f4922cd3cd4a3c97f5f3c0def5c118" data-id="23f4922cd3cd4a3c97f5f3c0def5c118"><span><div id="23f4922cd3cd4a3c97f5f3c0def5c118" class="notion-header-anchor"></div><a class="notion-hash-link" href="#23f4922cd3cd4a3c97f5f3c0def5c118" title="Only My Code 可以聚焦于用户代码"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Only My Code 可以聚焦于用户代码</span></span></h4><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-61cbf1cb4dee4af1a1a902731bdc2aca"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F6ed74e04-7843-405b-91cf-8e46321f2378%2FPasted_image_20230209153132.png%3Fid%3D61cbf1cb-4dee-4af1-a1a9-02731bdc2aca%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607198%26signature%3Dzd1rGo5IlOfZSfpXxJMLLgWpI80VpObHvMSCdl7sh8c?table=block&amp;id=61cbf1cb-4dee-4af1-a1a9-02731bdc2aca&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-56a944c7a6c14831bd112a0aaa4efd18"> </div><div class="notion-text notion-block-a3251afd1fdf4423b18260b0532ef4da">聚焦前</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-df84be5a47574ff1a968281d27c40e08"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F40bd239c-c278-41f1-b81f-07659d949145%2FPasted_image_20230209161309.png%3Fid%3Ddf84be5a-4757-4ff1-a968-281d27c40e08%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607198%26signature%3DDt55YYar_RoOodk_jSaLzi2S69RfSIjkIGm7q6_YTx8?table=block&amp;id=df84be5a-4757-4ff1-a968-281d27c40e08&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-76583d7e5cc942c7b479b6c41cbda10e">聚焦后</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-ce4525d48926433298c980382af68fae"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fe9f62ef1-da7f-4ee0-a7c0-a384c94cf72f%2FPasted_image_20230209161312.png%3Fid%3Dce4525d4-8926-4332-98c9-80382af68fae%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607205%26signature%3DGOWMw6f8qFLW1fgKV2UgWMnc0xhQkGcJRw7YD27SqpQ?table=block&amp;id=ce4525d4-8926-4332-98c9-80382af68fae&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-6be2086592f947ad9a39f664cbd00cba" data-id="6be2086592f947ad9a39f664cbd00cba"><span><div id="6be2086592f947ad9a39f664cbd00cba" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6be2086592f947ad9a39f664cbd00cba" title="对比图表直观清晰"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">对比图表直观清晰</span></span></h4><div class="notion-text notion-block-05d48bad82094e39a91a2c1ef173bdad">对比视图，通过颜色能够清晰获取不同时间的代码内存申请的异同。火焰图表现：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-e357cd64c9ea4f5c89f215397a2b2ad1"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fa0575373-99e8-42b4-afcf-0dd78c65b4b1%2FPasted_image_20230209162221.png%3Fid%3De357cd64-c9ea-4f5c-89f2-15397a2b2ad1%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607207%26signature%3DG80_7fgOj4UEQPZtOno78u9kfN3n3zNWEwHIxP-pFyM?table=block&amp;id=e357cd64-c9ea-4f5c-89f2-15397a2b2ad1&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-e429a496ce9e4014ac37fe95a77c287d">表格表现：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-3461c9b11c574bec91b344d2aee67f7e"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F82b8c0ac-0516-4a8b-b09b-b0bf1fa7650a%2FPasted_image_20230209162359.png%3Fid%3D3461c9b1-1c57-4bec-91b3-44d2aee67f7e%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607204%26signature%3DYdCOS3bh3fKJRB_5YJIfOPLvTOeHdEMW8Kavd17Gc50?table=block&amp;id=3461c9b1-1c57-4bec-91b3-44d2aee67f7e&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-8b8b5ae4a8bd483092fd8bd09622f708" data-id="8b8b5ae4a8bd483092fd8bd09622f708"><span><div id="8b8b5ae4a8bd483092fd8bd09622f708" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8b8b5ae4a8bd483092fd8bd09622f708" title="常用的数据聚合快捷入口"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">常用的数据聚合快捷入口</span></span></h4><div class="notion-text notion-block-52903829b2e04913991e5f34fc31163b">在 CPU 数据上，已经根据不同纬度提供了聚合计算快捷入口。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d6be32cedf584312ab16bc40d0a7a85d"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F6b7742fe-f526-4231-b30a-158b52a32c2f%2FPasted_image_20230209161756.png%3Fid%3Dd6be32ce-df58-4312-ab16-bc40d0a7a85d%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607199%26signature%3D1byd-s67FlOSAZqvYEwOk_49sXLLNcpTymzg7GWZRFs?table=block&amp;id=d6be32ce-df58-4312-ab16-bc40d0a7a85d&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-f427825cc82d402a951d6bbc75022f29" data-id="f427825cc82d402a951d6bbc75022f29"><span><div id="f427825cc82d402a951d6bbc75022f29" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f427825cc82d402a951d6bbc75022f29" title="Elastic Profiler?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Elastic Profiler?</span></span></h4><div class="notion-text notion-block-c744f64c2bc14c55a785e406e8da5508">实话实说，实际上在本文写成的时候，笔者尚未体验过 Elastic Profiler ，这里就暂不置评，留空日后补充。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-8bb6b79be1494abd95fc05375e139b88" data-id="8bb6b79be1494abd95fc05375e139b88"><span><div id="8bb6b79be1494abd95fc05375e139b88" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8bb6b79be1494abd95fc05375e139b88" title="方案选型对抗赛"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">方案选型对抗赛</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-729375fb46d2432a971f3de708f5fa8c" data-id="729375fb46d2432a971f3de708f5fa8c"><span><div id="729375fb46d2432a971f3de708f5fa8c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#729375fb46d2432a971f3de708f5fa8c" title="推 vs 拉"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">推 vs 拉</span></span></h3><div class="notion-text notion-block-388f9c2043f6486f9c7adc9ccdb3170f">在可观测领域，数据获取的方向一直是热议的话题，Profiling 也不例外。以下是概要性的对比：</div><table class="notion-simple-table notion-block-ea137915745a434bbb652864ecfde965"><tbody><tr class="notion-simple-table-row notion-block-82667e4945fb4f70b3d9f9ef238421ea"><td class="" style="width:120px"><div class="notion-simple-table-cell">对比特性</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">pull</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">push</div></td></tr><tr class="notion-simple-table-row notion-block-e9ae2ae75d1f4c10a77f52574fb72731"><td class="" style="width:120px"><div class="notion-simple-table-cell">配置方式</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">原生中心化配置</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">端上配置，通过配置中心支持中心化</div></td></tr><tr class="notion-simple-table-row notion-block-ea7924fe40b346ea8a717f8f229cb652"><td class="" style="width:120px"><div class="notion-simple-table-cell">监控对象发现</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">依赖服务发现机制</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">由应用、Agent自主上报，无需服务发现模块</div></td></tr><tr class="notion-simple-table-row notion-block-77257cf2d83b4d5ca698562af2ed67ad"><td class="" style="width:120px"><div class="notion-simple-table-cell">部署方式</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">应用暴露端口，接入服务发现，原生支持Pull协议</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">1. Agent 统一代理抓取 2. 应用主动推送到监控系统</div></td></tr><tr class="notion-simple-table-row notion-block-e078d02aa86d4c26971682754e03ad7f"><td class="" style="width:120px"><div class="notion-simple-table-cell">指标获取灵活性</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">On Demand按需获取</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">被动接受，需要一些过滤器额外支持</div></td></tr><tr class="notion-simple-table-row notion-block-cc1d665f152f41d9badf3845818e3216"><td class="" style="width:120px"><div class="notion-simple-table-cell">应用耦合性</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">应用与监控系统解耦，应用无需关心对端地址、错误处理等</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">与应用代码耦合</div></td></tr><tr class="notion-simple-table-row notion-block-d0a2485b01dd4219890271c7def50da1"><td class="" style="width:120px"><div class="notion-simple-table-cell">安全性保证</div></td><td class="" style="width:333px"><div class="notion-simple-table-cell">工作量大，需要保证应用暴露端口的安全性，容易被DDos攻击或者出现数据泄露</div></td><td class="" style="width:355px"><div class="notion-simple-table-cell">难度低，ingest 接口交互一般都有鉴权控制</div></td></tr></tbody></table><div class="notion-text notion-block-d621544513cb43a3820e4504d27ff671">与 Prometheus 稍有不同的是，Continuous Profiling 基本不存在短任务数据上报的场景——既然都是 <em><b>Continuous</b></em> 了，那肯定不短，所以 pull 场景中最大的短板——难以适配短任务——基本不存在了。同时，由于 Go 语言是该领域的绝对“第一公民”，其标准库就支持的 pprof 模块能够以极低的开发成本添加 pprof HTTP 端点，所以三大开源软件在 pull 方向的支持上都是完备的，而 push 方向除了 pyroscope，其他项目均有不同程度的“残缺”。<b>考虑到 OT 和其他语言工具转换 pprof 的进度，这种“重 pull 轻 push” 的现象仍将在 Profiling 领域持续一段时间。</b></div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-492b9ded6ab74c859f1b670c85082431" data-id="492b9ded6ab74c859f1b670c85082431"><span><div id="492b9ded6ab74c859f1b670c85082431" class="notion-header-anchor"></div><a class="notion-hash-link" href="#492b9ded6ab74c859f1b670c85082431" title="存算分离 vs 存算一体"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">存算分离 vs 存算一体</span></span></h3><div class="notion-text notion-block-b848417ccee74127b14a99e0b1b45381">Profiling 项目最大的技术难点就是如何处理存储，这也是可观测领域一直以来的重点。其中存算分离和存算一体的选择，决定了存储引擎乃至整个产品的形态。</div><div class="notion-text notion-block-02a9cf6c699b49c08d89833a0dfe2d91">在我们上面分享的几个开源产品中，它们无一例外都选择了内嵌式——也就是存算一体的方式，无论是性能较好、灵活度较高、但缺少水平扩容的 BadgerDB，还是列存 FrostDB，存取逻辑都是和计算进程绑定在一起。</div><div class="notion-text notion-block-ccd3f17c24424a33909e5866f78bccaa">在我看来，产品的服务形态是存算分离与否的决定性因素。</div><table class="notion-simple-table notion-block-103b930472654b0f9fb20767b10bf256"><tbody><tr class="notion-simple-table-row notion-block-c66eb9f03c8744ca9be5f27287d5599d"><td class="" style="width:177px"><div class="notion-simple-table-cell">服务形态/存储类型</div></td><td class="" style="width:222.3671875px"><div class="notion-simple-table-cell">选择存算一体（内嵌存储引擎）</div></td><td class="" style="width:307px"><div class="notion-simple-table-cell">选择存算分离（分布式存储服务）</div></td></tr><tr class="notion-simple-table-row notion-block-6d6a9274483e4056b926d13283b0887d"><td class="" style="width:177px"><div class="notion-simple-table-cell">OSS</div></td><td class="" style="width:222.3671875px"><div class="notion-simple-table-cell">● 少依赖，易部署 👍<!-- -->
<!-- -->● 针对性优化灵活 👍</div></td><td class="" style="width:307px"><div class="notion-simple-table-cell">● 额外依赖，数据优化灵活度低 👎</div></td></tr><tr class="notion-simple-table-row notion-block-a23fb04728ea49a3b40222e9a59adaf4"><td class="" style="width:177px"><div class="notion-simple-table-cell">SaaS</div></td><td class="" style="width:222.3671875px"><div class="notion-simple-table-cell">● 扩展、灾备方案不完善 👎</div></td><td class="" style="width:307px"><div class="notion-simple-table-cell">● 将状态向存储侧转移，组件复杂度相对低 👍<!-- -->
<!-- -->● 针对性优化难度稍高 👎</div></td></tr></tbody></table><div class="notion-text notion-block-62231d19391d4f3296212a660cdba8dc">总而言之，产品的服务形态将很大程度上决定存储的模式。如果是偏向于 OSS 分发，选内嵌存储，如果是以 SaaS 服务为主，选专用的分布式 DBMS。当然，从具体的工程实现来说，完全可以在存储上加一个可插拔的抽象层，以适配不同的服务形态，类似<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/pyroscope/issues/169">这里的讨论</a>。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3b4160403f964f46818d70117d0dd1ec" data-id="3b4160403f964f46818d70117d0dd1ec"><span><div id="3b4160403f964f46818d70117d0dd1ec" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3b4160403f964f46818d70117d0dd1ec" title="块存储 vs 对象存储"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">块存储 vs 对象存储</span></span></h3><div class="notion-text notion-block-b43f05718b4344848f23b06d6607b0f5">在存储领域，块存储和对象存储都是非常常见的方式。</div><div class="notion-text notion-block-8d19018ac43d474f9362f09988de282f">块存储（Block Storage）是将存储数据分为固定大小的块进行存储，适合于需要低延迟、高性能、高可用的场景，如数据库、虚拟机、容器等。块存储一般使用本地存储或网络存储，操作系统可以使用块设备访问。<b>缺点在于扩展性差、价格相较于对象存储更贵，不适合存储海量数据。</b></div><div class="notion-text notion-block-d4b9131a579341c2bf44c7089c85d8f2">对象存储（Object Storage）则是将数据存储为对象，每个对象都有唯一的标识符（URI），将数据分散到多个节点上，通过分布式算法实现高可用和容错，适合于海量数据存储和分布式存储。<b>缺点在于读写性能较差，不适合要求低延迟和高性能的场景。</b></div><div class="notion-text notion-block-c53f4d3ed9774473be313ce3ed0167d6">在实际 Profiling 场景下，通常会有两部分数据：</div><ul class="notion-list notion-list-disc notion-block-74a5923f88d349b48cd321ea183f933d"><li>近期需要频繁访问的短期热数据</li></ul><ul class="notion-list notion-list-disc notion-block-d51f46b186184f60971be1e4f1b4a84c"><li>可能会存在较长时间的冷数据</li></ul><div class="notion-text notion-block-ea3ea48573b14580912e18fdf355f83e">从原理上来说，热、冷数据应该分别存放到块存储和对象存储中，类似上面提到的 Phlare 方案，而不是一股脑放到块存储（Pyroscope OSS 的做法）或者全部放到对象存储（好像也没人这么做）。</div><div class="notion-text notion-block-4e155dd05728429dbb54cf449f36f32a">即使 Phlare 的方案看起来很合理，但它依旧是内嵌型存储，目前还没有一个比较成熟的分布式 DBMS 支持这样的特性。Pyroscope 在其云服务中也放弃了原来的内嵌式 K-V 存储，而转向了借用 Parquet 的分布式存储 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/grafana/tempo">Tempo </a>方案（来自其 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://pyroscope.io/blog/introducing-pyroscope-cloud/#pyroscope-clouds-major-scaling-improvements">blog</a>），在保证后端存储针对性优化的同时，利用类似 Thanos objstore 的方案实现了利用对象存储的扩展能力，遗憾的是尚未将这部分代码开源，也无法研究其内部细节了。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-61ca23ded6ce4926892710f5dc7049d9" data-id="61ca23ded6ce4926892710f5dc7049d9"><span><div id="61ca23ded6ce4926892710f5dc7049d9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#61ca23ded6ce4926892710f5dc7049d9" title="eBPF vs Native Language Tools"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">eBPF vs N<b>ative Language Tools</b></span></span></h3><div class="notion-text notion-block-c74106429e6746d48c0d243219f77262">Profier 是 Profiling 数据来源的基础，上述不少产品中都采用了 eBPF 作为采集方案，那么是否只要使用了 eBPF 就代表着开销更小、数据更全呢？并不全是，Pyroscope 的<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://pyroscope.io/blog/ebpf-profiling-pros-cons/">这篇 blog</a> 给了我们一个比较客观的对比。首先从数据来源的层级来看，可以将 Profiler 分为两类：</div><ul class="notion-list notion-list-disc notion-block-2486291cacb54336a7b3d00c59ba61bb"><li>用户态: 流行的性能分析工具，如pprof，async-profiler，rbspy，py-spy，pprof-rs，dotnet-trace等，都在这个层面上运行。</li></ul><ul class="notion-list notion-list-disc notion-block-cc608e8d11a94510b0d85765738cc08d"><li>内核态: 基于 eBPF 的各种 Profiler 封装和 Linux perf 工具可以从内核获取整个系统的堆栈跟踪</li></ul><div class="notion-text notion-block-27b555bb81b74efbbbd319ee0956c182">由于数据来源的层级不同，它们各有长短。</div><div class="notion-text notion-block-a21e473e284143dc8f1e21e7f2898bce">对于用户态的工具而言：</div><ul class="notion-list notion-list-disc notion-block-e5f17aa7468e4e4cb1bd067e98010fb1"><li>可以非常灵活的标记用户的应用代码（例如 标记 spans, controllers, functions）👍</li></ul><ul class="notion-list notion-list-disc notion-block-60e8ba7403374f2f95b23dd1deda2d43"><li>能够分析代码的各个特定部分（例如 Lambda 函数、测试套件、脚本）👍</li></ul><ul class="notion-list notion-list-disc notion-block-6d8c92280f8c4f2c858252cceb2330cd"><li>有着更容易分析其他类型数据的能力（例如内存、goroutines）👍</li></ul><ul class="notion-list notion-list-disc notion-block-7185f4e5505040a9b70cbc9b6d0586b4"><li>本地开发十分便捷，容易使用 👍</li></ul><ul class="notion-list notion-list-disc notion-block-14f40af546844a22b9581691963d3dff"><li>复杂，如果一个系统是多语言的，很难获取一个全局视图 👎</li></ul><ul class="notion-list notion-list-disc notion-block-83f7faf9e12a46288737717d197ad0ca"><li>对于基建元信息的标识能力有限（例如 Kubernetes） 👎</li></ul><div class="notion-text notion-block-79a3017bebf8405b8f0be94e1d92e4be">对于内核态的工具而言：</div><ul class="notion-list notion-list-disc notion-block-1f1d13c96ca2484a8e078597707b2475"><li>非常容易就能获取到跨语言的全局视图 👍</li></ul><ul class="notion-list notion-list-disc notion-block-26ab1028fe7249a4a9e6504e3bf3c352"><li>很容易对基建元信息进行标识能力有限（例如 Kubernetes Pods） 👍</li></ul><ul class="notion-list notion-list-disc notion-block-f7463e7683aa4a21b51d345eac377ccc"><li>所有语言在符号化上都是一致的 👍</li></ul><ul class="notion-list notion-list-disc notion-block-19b0ebf4ad92472bb1fb6172b5f132bb"><li>对 Linux 内核版本有要求 👎</li></ul><ul class="notion-list notion-list-disc notion-block-a024146a8f434abca61e3ecbfa2e12a4"><li>用户层级的代码比较难标记 👎</li></ul><ul class="notion-list notion-list-disc notion-block-f6e331e183a04959bb90aae07cfbf1af"><li>内存、goroutines 很难获取对应数据 👎</li></ul><ul class="notion-list notion-list-disc notion-block-dd0cbd1001384d5d839250796d1e0c02"><li>开发者想在本地开发比较困难 👎</li></ul><ul class="notion-list notion-list-disc notion-block-4d8582b254cf4fc686ef241d0a9f906d"><li>解释器型的语言获取的信息较为有限 👎</li></ul><div class="notion-text notion-block-401e72b99a914b33b3e6ec8a90f21a9f">简单来说，这两种方案的方向是反的：自下而上和自上而下，它们的数据信息理应做到互相补充，现阶段仅有 Pyroscope 对它做了<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://pyroscope.io/blog/ebpf-profiling-pros-cons/#pyroscopes-solution-merge-ebpf-profiling-and-native-language-profiling">有限的整合优化</a>，需要进一步关注进展。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f9474cb377364a1faa740d5276deb613" data-id="f9474cb377364a1faa740d5276deb613"><span><div id="f9474cb377364a1faa740d5276deb613" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f9474cb377364a1faa740d5276deb613" title="pprof vs OT"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">pprof vs OT</span></span></h3><div class="notion-text notion-block-23659b2844e64076bc6ed9707a300a32">pprof 本身是一个开源的性能分析工具套件，它可以抓取并组装 CPU、内存、goroutine 等性能数据，并且通过配套的工具可以生成各种可视化视图，例如火焰图、调用图等。</div><div class="notion-text notion-block-75537ccbfc254c6bb85a51b392657ed4">同时 pprof 也定义了相关的 Profile 数据格式，<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/google/pprof/blob/main/proto/profile.proto">以 Protocol Buffers 呈现</a>。它由一系列的记录 Sample 组成：包含了函数调用堆栈以及相应的计数器值。</div><div class="notion-text notion-block-80509e2702df445ba67615834a7e3a04">以下讨论的 pprof 指的是<b>其代表的数据格式。</b></div><div class="notion-text notion-block-08845340169643afa381ddd55b7ec206">可以通过<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/DataDog/go-profiler-notes/blob/18fd7f410e681d4b43c9afb403a4bdf23af29f99/examples/cpu/pprof.samples.cpu.001.pprof.txt#L1">它的文本表达示例</a>或者下面这张图理解其中的关联关系（除了 Stacktrace 是额外抽象出来的中间表）</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-5e17dafb13e44533b6adeb6703c1e3e1"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2Fa436eddf-7b62-4cff-b8ed-d0b14037d1ca%2FUntitled.png%3Fid%3D5e17dafb-13e4-4533-b6ad-eb6703c1e3e1%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607200%26signature%3DXpU2lmtodm0jpWz68mFvKkT4xjKV8zPD0wVk5w95bnc?table=block&amp;id=5e17dafb-13e4-4533-b6ad-eb6703c1e3e1&amp;cache=v2" loading="lazy" alt="基本对齐 pprof 模型的列存数据表，来自 Phlare" decoding="async"/><figcaption class="notion-asset-caption">基本对齐 pprof 模型的列存数据表，来自 Phlare</figcaption></div></figure><div class="notion-text notion-block-1ebdfc01fc724957a1b66a2fd72a5c18">pprof 在设计上是跨语言的，它理应成为一个跨语言标准，但受限于历史的进程，大多数语言的采集工具比它的历史更久，各种工具和采集链已经较为成熟，所以，除了 Go 语言有着极好的 pprof 支持，其他语言都没有成熟的 pprof 格式转换方案（例如<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/timpalpant/pypprof"> Python 虽然有，但缺乏维护</a>）。这中间的沟壑既给了 Pyroscope 较多的对接工作量，也给 OT 的标准化留足了空间。</div><div class="notion-text notion-block-95b44f9d6fbd4bf59f4830ddf1943ab1">Open Telemetry <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/open-telemetry/oteps/blob/main/text/profiles/0212-profiling-vision.md">预期将 Profiling 格式做一个标准化</a>，包括了非常多的工作内容：</div><ul class="notion-list notion-list-disc notion-block-375bd97f20a8429a8707024d6ad2b625"><li>尽可能多兼容各种 Profiling 格式</li></ul><ul class="notion-list notion-list-disc notion-block-ce3ccec35cfd4635b51f7297c06ed255"><li>应尽可能高效地传输分析数据，并且制定一个无损的 Profiling 模型，重点在于解析、转码（与其他格式之间的转换）和分析的效率上</li></ul><ul class="notion-list notion-list-disc notion-block-bc9095b196c24f18acb8fba2a90aa6d3"><li>应该可以清晰地映射到标准数据模型（例如 collapsed、pprof、JFR 等）</li></ul><ul class="notion-list notion-list-disc notion-block-71b30cb94448430192956a7417b3b987"><li>应该包含表示其他 OT Signal 之间关系的机制（例如 span 中的调用链）</li></ul><ul class="notion-list notion-list-disc notion-block-af7918c09ff14612a1d645f8f93f5e2d"><li>对于已经流行的 Profiler，保持尽可能小的转换开销</li></ul><div class="notion-text notion-block-54325062d698464f80e678ac3943769a">OT 的愿景是非常美好的，但从可观察的<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/open-telemetry/opentelemetry-profiling">进展</a>来说，并不是非常顺利，至少距离上一次有效的更新已经过了几个月了。<b>所以，现阶段在没有 OT 标准化格式之前，pprof 仍旧是 Profiling 数据格式为数不多的选择。</b></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-e6f5bc4ccbe141c492231597ed30f5d1" data-id="e6f5bc4ccbe141c492231597ed30f5d1"><span><div id="e6f5bc4ccbe141c492231597ed30f5d1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e6f5bc4ccbe141c492231597ed30f5d1" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h2><div class="notion-text notion-block-6bbef891e4134069867bd3006d522efe">Continuous Profiling 是一个不新不旧的领域，有着不大不小的市场，伴随着可观测领域常见的问题。在 OT 标准化前，Pyroscope 算是领先了一个身位，但各产品仍处于百舸争流的阶段，需要 Continuous Focusing 。</div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[从 奇思乱想 到 妙想天开]]></title>
            <link>https://next.emergencyexit.xyz//upgrade-blog</link>
            <guid>https://next.emergencyexit.xyz//upgrade-blog</guid>
            <pubDate>Thu, 20 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[打怪→获得经验→升级⤴️]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-0c0d5bfd8642460aaedc5a8277725196"><div class="notion-viewport"></div><div class="notion-text notion-block-9efc17fbe87e4de6ad5d5a5d436b1798">两年前我在 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://emergencyexit.xyz/use-notion-as-blog.html"><b><b>使用 Notion 搭建个人静态 Blog</b></b></a><b><b> </b></b>一文中描述了本博客站点的搭建方式，实现了个人博客 从零到一。随着这两年笔耕不辍，近二十篇水文陆续问世，对站点的功能有了更高的要求，于是决定对博客方案进行全新升级，也希望能从“奇思乱想“的水文时代，向”妙想天开“的高质量博客站点迈进。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-d392edb8b7d347e2888253c38532259a" data-id="d392edb8b7d347e2888253c38532259a"><span><div id="d392edb8b7d347e2888253c38532259a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#d392edb8b7d347e2888253c38532259a" title="升级"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">升级</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-5c2185d8eed04a749ca5c7e185a1966d" data-id="5c2185d8eed04a749ca5c7e185a1966d"><span><div id="5c2185d8eed04a749ca5c7e185a1966d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5c2185d8eed04a749ca5c7e185a1966d" title="工具的局限"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">工具的局限</span></span></h4><div class="notion-text notion-block-d25f1d7885324fbcacb9a01f38f59d70">两年前工具选型时并未有太多的调研，看到 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/dragonman225/notablog">notablog</a> 渲染出的站点样式好看、功能基本能满足需求，就立马实施上马。经过这两年的体验，总结了一些该工具功能上的缺失：</div><ul class="notion-list notion-list-disc notion-block-f24064939e314b83be63aa0c3c608038"><li>缺少 RSS 支持</li></ul><ul class="notion-list notion-list-disc notion-block-a9a5d4316b40445688341d9c0da249c9"><li>不支持分页，文章越来越多，页面越来越长</li></ul><ul class="notion-list notion-list-disc notion-block-0e21fd7104274547a614fe080cbc763a"><li>不支持搜索，和分页类似，文章越多越不友好，我还想多写几篇</li></ul><ul class="notion-list notion-list-disc notion-block-55a32294c9854e6b974c811f91470100"><li>缺少持续的更新（例如不支持 Simple Table/Mermaid 等 Notion 新特性、Go 代码块样式异常）</li></ul><ul class="notion-list notion-list-disc notion-block-6f9d79ac53ca4f4798c2965411e1cacc"><li>缺少切换黑暗模式主题</li></ul><div class="notion-text notion-block-a1a63700fd6e4f7fa09d8ec8f66b5bfe">部分功能缺失<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/dragonman225/notablog/issues/created_by/IMBlues">我在 issue 中向作者提出了feature request</a> ，虽然都有回应，但也都束之高阁，很长时间都没见到开工的样子。</div><div class="notion-text notion-block-ed30d1362b6f49ac9039150d202bc0cd">于是我对其他 Notion 博客生成工具进行调研，表中列举了一些我关注的功能点（在这里更多考察的开箱即用的能力）</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-e7292203bcfc409388611eade09fdecd" data-id="e7292203bcfc409388611eade09fdecd"><span><div id="e7292203bcfc409388611eade09fdecd" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e7292203bcfc409388611eade09fdecd" title="其他 Notion 工具"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">其他 Notion 工具</span></span></h4><table class="notion-simple-table notion-block-63aec3fa6b3d4004946ea82835465111"><tbody><tr class="notion-simple-table-row notion-block-de185efa57014549a7f3bb61a9b3f33a"><td class="" style="width:96px"><div class="notion-simple-table-cell">名称</div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">概述</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">RSS</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">评论</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">分析</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">搜索</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">sitemap</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">黑暗模式</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">响应式</div></td></tr><tr class="notion-simple-table-row notion-block-668fd43e9c454083b10fa74afb1fa743"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/ijjk/notion-blog">Notion Blog</a> </div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">Next.js 维护者，Vercel 公司工程师开发</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-21834e4eabcc47259f69b4477b63487f"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/craigary/nobelium">Nobelium</a> </div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">和 notablog 类似的静态构建工具：功能支持更多，使用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://nextjs.org/">Next.js</a> 原生支持 Vercel</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-1c47c1a7fdb343e4b3b3f317b76761c0"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/tangly1024/NotionNext">NotionNext</a> </div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">在 Nobelium 的基础上支持了更多主题</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-6ccdd9d739274290b391e93964d28490"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/transitive-bullshit/nextjs-notion-starter-kit"><b><b>Next.js Notion Starter Kit</b></b></a></div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">非常完善的构建工具，支持全文搜索</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-52d0defa838c426790f77806c6f0cd07"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/samuelkraft/notion-blog-nextjs"><b>notion-blog-nextjs</b></a></div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">Next.js + Notion 原生 API</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">✅</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">✅</div></td></tr><tr class="notion-simple-table-row notion-block-e1e67c6f70284b87803e3f190655f0d0"><td class="" style="width:96px"><div class="notion-simple-table-cell"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/leoncvlt/loconotion">Loconotion</a> </div></td><td class="" style="width:169px"><div class="notion-simple-table-cell">一个用 Python 编写的 Notion 静态页面生成器，与其他通过 Next.js 生成页面不同，它让 Notion 自己渲染，然后将页面抓取出来，理论上能最大程度上还原 Notion 的样式。默认并不能生成一个站点。</div></td><td class="" style="width:58px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:48px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:49px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:52px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:76px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:81px"><div class="notion-simple-table-cell">❌</div></td><td class="" style="width:68px"><div class="notion-simple-table-cell">❌</div></td></tr></tbody></table><div class="notion-text notion-block-f7359f80c0984650974258fab805fbc1">经过功能的简单筛选，优胜的工具有三个：Nobelium \ NotionNext \ Next.js Notion Starter Kit。</div><div class="notion-text notion-block-27b2dd050f50487bbd89289f84ecb57e">个人更偏向于 Nobelium，原因如下：</div><ul class="notion-list notion-list-disc notion-block-bf3afcc36f9e41df9548422d169bef73"><li>默认支持的样式符合我的审美</li></ul><ul class="notion-list notion-list-disc notion-block-7e5100e1ec174961b1a82b3e3ea4698a"><li>在基本功能都支持的前提下，代码足够简单，作为后端开发我能够比较轻松的修改和维护</li></ul><div class="notion-text notion-block-10c836a08bca48b5a4678fe58f9986c2">另外两个工具：</div><ul class="notion-list notion-list-disc notion-block-6c1f111d6c41499ebde5f77a89afc546"><li>Next.js Notion Starter Kit 本身非常推荐，功能齐全，样式好看，比 Nobelium 稍微复杂一些，最大优势是仍旧在积极维护中。</li></ul><ul class="notion-list notion-list-disc notion-block-8d27c6597026432189cd00c01bf9071a"><li>NotionNext 支持了更多主题，是否足够好看见仁见智，有一些类似<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.tangly1024.com/zh/features/articleLock">“文章锁”</a>的功能用不上。</li></ul><div class="notion-text notion-block-956d2a2e4eb1414f8939102abc9bb71c">秉承着 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zen-of-python.info/simple-is-better-than-complex.html">Simple is better than complex</a> 的原则，“妙想天开” 将选用 Nobelium 作为生成工具。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-206c876337c24a27b17124de4f472c47" data-id="206c876337c24a27b17124de4f472c47"><span><div id="206c876337c24a27b17124de4f472c47" class="notion-header-anchor"></div><a class="notion-hash-link" href="#206c876337c24a27b17124de4f472c47" title="工具改造"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">工具改造</span></span></h4><div class="notion-text notion-block-d91cdbb7f16f464b9653147511dd5361">虽然 Nobelium 已经支持了我所有的需求，但我仍旧需要对它进行一些改造，因为它原生是面向 Vercel 部署构建的，而我想要一个纯静态站点部署在 Github Pages，而非 Next.js 所推崇的 SSR 服务端渲染。那么为啥不用 Vercel ？最直接的原因：墙。本身访问量就不多，进一步提高访问门槛只会更加门可罗雀。</div><div class="notion-text notion-block-33456e9e0f874fedaf7f8c534f28cea0">所以第一步就是如何通过 Action 将 Next.js 应用在 Github Pages 上。具体的做法可以参考<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://gregrickaby.com/2020/03/21/next-js-github-pages">这篇文章</a>和<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/gregrickaby/nextjs-github-pages">这个项目</a>。最后的效果就是，只需要将源码推到主分支，既可以自动执行 <code class="notion-inline-code">npm build</code> 和 <code class="notion-inline-code">npm export</code> 到 <code class="notion-inline-code">gh-pages</code> 分支，然后 Pages 相关配置使用 <code class="notion-inline-code">gh-pages</code> 即可。</div><div class="notion-text notion-block-9f3f2403e07a41c19d1fc13065ad6d02">同时又因为我将动态渲染改成了静态站点，其中一些 <code class="notion-inline-code">getserverSideProps</code> 动态部分（如 RSS）就需要改造成构建时生成，相关的步骤可以参考：</div><ul class="notion-list notion-list-disc notion-block-d414208fa6d343628e7277a716d9991f"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://dev.to/kendalmintcode/create-a-next-js-rss-feed-for-your-static-website-210p">https://dev.to/kendalmintcode/create-a-next-js-rss-feed-for-your-static-website-210p</a></li></ul><ul class="notion-list notion-list-disc notion-block-c916a7dccac74c12aba44c60a4c0930a"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://sreetamdas.com/blog/rss-for-nextjs">https://sreetamdas.com/blog/rss-for-nextjs</a></li></ul><div class="notion-text notion-block-7fff25642c254a8bb943ca5aedfbe548">也可以直接参考<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/IMBlues/nobelium">我已经改造好的项目</a>。</div><div class="notion-text notion-block-d74f07cfccc046e08d1b2e42ed218752">然后就可以开始对文章列表进行迁移了（完全手动的，一点点复制，还好写的文章不算特别多），其中有两点需要额外注意：</div><ul class="notion-list notion-list-disc notion-block-64ea5c50cdae47ef83b39cfabd0cfc37"><li>尽量保证原文的 URL 一致。由于 notablog 默认会在 slug 后面多加一个 <code class="notion-inline-code">.html</code> ，所以在新工具中旧文章的 <code class="notion-inline-code">slug</code> 中需要额外加上 <code class="notion-inline-code">.html</code> 后缀，来保证更换站点后，原文 URL 不变。</li></ul><ul class="notion-list notion-list-disc notion-block-5ff81815b54e41eaab5fca7888b32a99"><li>由于我使用了 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://utteranc.es/"><b><b>utterances</b></b></a><b><b> </b></b>作为评论系统，需要保证文章迁移前后能够有同样的评论 (issueTerm → “pathname”)</li></ul><div class="notion-text notion-block-e0652f4ff4914bb3b6064914a3f2d089">最后对站点整体样式进行一些个人化的样式微调，大功告成：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://next.emergencyexit.xyz/">布鲁斯鱼的妙想天开</a> 🎊</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-bee3460432c1434992c51d60e73afa29" data-id="bee3460432c1434992c51d60e73afa29"><span><div id="bee3460432c1434992c51d60e73afa29" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bee3460432c1434992c51d60e73afa29" title="后续可能的升级点——传播的局限"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">后续可能的升级点——传播的局限</span></span></h3><div class="notion-text notion-block-157eb8b2bb82492082968f1c0caac8ce">由于之前并未有太多博客建站的经验，所以很多问题考虑不周，也大大制约了本博客的传播能力<s>（当然，主要是文章水分过高，价值不够）。</s></div><div class="notion-text notion-block-eb92abd737624bcda31e0fe935775293">主要有以下几个方面：</div><ul class="notion-list notion-list-disc notion-block-fd8f579588534f86901c6b4408180aa4"><li>缺少国内 CDN 加速。本站是中文站点，却经常引用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://unsplash.com/">Upslash</a> 的大图，丝毫没有把国内用户访问体验放在心上。</li></ul><ul class="notion-list notion-list-disc notion-block-da796d97a9d1444ca84534a96bc18988"><li>搜索绝缘体。虽然我也不太看重百度搜索，也不想让自己的文章出现在一堆 CSDN、百度百家的文章中，但是由于未备案和 Github Pages 的部署性质，基本和国内的搜索说拜拜了。</li></ul><ul class="notion-list notion-list-disc notion-block-9b0a600c91fc4c1bb356cc5ab4806efa"><li><s>文章太水了，没有让人阅读和分享的欲望（这个暂时解决不了，能力一般，水平有限）</s></li></ul><div class="notion-blank notion-block-3b179dae9f0642728723e4d618872937"> </div><div class="notion-callout notion-gray_background_co notion-block-04cccd37d615495eae7a70da01f5fa6b"><span class="notion-page-icon" role="img" aria-label="🤪">🤪</span><div class="notion-callout-text">我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cloud.tencent.com/developer/support-plan?invite_code=34ky79072xmo4">https://cloud.tencent.com/developer/support-plan?invite_code=34ky79072xmo4</a></div></div><div class="notion-blank notion-block-b690c655c4af4fc7a431e8e44cabeefd"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[WTF Go: Constants]]></title>
            <link>https://next.emergencyexit.xyz//wtf-go-constants.html</link>
            <guid>https://next.emergencyexit.xyz//wtf-go-constants.html</guid>
            <pubDate>Tue, 11 Oct 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[ WTF Go: 初看反直觉，仔细研究却大有设计]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-f6ba5dfd50004e1580b47d3456bc676a"><div class="notion-viewport"></div><pre class="notion-code language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"time"</span>
	<span class="token string">"math/rand"</span>
<span class="token punctuation">)</span>

<span class="token comment">// invalid operation: rand.Intn(10) * 1000 * time.Millisecond (mismatched types int and time.Duration)</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> ❌

<span class="token comment">// 🤔 make sense.</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> ✅

<span class="token comment">// wtf ?!</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> ✅ </code></pre><div class="notion-text notion-block-c39aa2c506de4a38884207f6cc0666f4">看看上面这个简单的例子：</div><ul class="notion-list notion-list-disc notion-block-94339645b11c4208ac1de17ef66e21d6"><li>第一个错误很容易理解： 整型不能和 <code class="notion-inline-code">time.Duration</code> 相乘</li></ul><ul class="notion-list notion-list-disc notion-block-90a7e274dd4740ac97bd29e4c8b56822"><li>第二个例子修正了这一问题，符合预期</li></ul><ul class="notion-list notion-list-disc notion-block-f1ecf287e16c4698bfa18a71b4789179"><li>第三个例子带来了疑问，为什么 <code class="notion-inline-code">1000 * time.Millisecond</code> 却没有问题？明明 <code class="notion-inline-code">1000</code> 也是个整型？编译器戴了有色眼镜？</li></ul><div class="notion-text notion-block-2aa15d50137b414bb6ed5569ce63f326">别慌，仔细看看 <code class="notion-inline-code">rand.Intn(10) * 1000</code> 和 <code class="notion-inline-code">1000</code> 的区别在于：前者是变量，类型已经确定了，通不过编译是情理之中；而后者是常量，类型并不是 <code class="notion-inline-code">int</code> ，属于 <code class="notion-inline-code">untyped constants</code> ，编译器会尝试将它转换成 <code class="notion-inline-code">time.Duration</code> 。</div><div class="notion-text notion-block-4b6e7022ba1c41dc9dec86be35016e6a">这就勾起了我的好奇心，那如果我写个一个 <code class="notion-inline-code">float</code> 常量会怎样呢？</div><pre class="notion-code language-go"><code class="language-go"><span class="token comment">// (untyped float constant) truncated to int64</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000.1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> ❌</code></pre><div class="notion-text notion-block-5581a723f1c9437da180b271dde64dfb">果然是不行的。那么究竟这个无类型常量的类型转换是依照什么规则进行的呢？</div><div class="notion-text notion-block-fda4059895d742c18a5c11fcd2834e98">首先每一种常量的<b>写法</b>都会对应着一种默认类型：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-bead2efbe82d41e6a20ac11ad6d2aa44"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:540px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Ffile.notion.so%2Ff%2Fs%2F4841bfb7-5a0d-42ae-ba4c-55881d39feec%2FUntitled.png%3Fid%3Dbead2efb-e82d-41e6-a20a-c11ad6d2aa44%26table%3Dblock%26spaceId%3Db0a64676-90b9-4734-9c63-2d704ee573b6%26expirationTimestamp%3D1681378607692%26signature%3DJGTZFsIaKVXIPI1pEMuZO8OuSehVzu9LCYGCIwTvg3w?table=block&amp;id=bead2efb-e82d-41e6-a20a-c11ad6d2aa44&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-blank notion-block-fd185c5379f34f0a8f0cafca86305977"> </div><div class="notion-text notion-block-b39975e4a04d40b4b8693d417031d653">然后，看看 <code class="notion-inline-code">time.Duration</code> 的定义：</div><pre class="notion-code language-go"><code class="language-go">type Duration int64

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    Nanosecond  Duration <span class="token operator">=</span> <span class="token number">1</span>
    Microsecond          <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Nanosecond
    Millisecond          <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Microsecond
    Second               <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> Millisecond
    Minute               <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> Second
    Hour                 <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> Minute
<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-b8de09386e5b45e7a5f0ae8bfc054707">也就是说 <code class="notion-inline-code">1000</code> 的写法默认类型为 <code class="notion-inline-code">int</code> ，编译器会尝试做一次类型转换 <code class="notion-inline-code">int</code> → <code class="notion-inline-code">time.Duration</code> ，而 <code class="notion-inline-code">int64</code> 和 <code class="notion-inline-code">int</code> 又能做到完全兼容，所以编译通过。</div><div class="notion-blank notion-block-bb978502225d458d8ea95627d61232a4"> </div><div class="notion-text notion-block-73679d6edd4946938e9b7e3de693eee1">WTF，Go…</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-387dcc99be4b4d9bb32787dccb641d7b" data-id="387dcc99be4b4d9bb32787dccb641d7b"><span><div id="387dcc99be4b4d9bb32787dccb641d7b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#387dcc99be4b4d9bb32787dccb641d7b" title="参考："><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考：</span></span></h3><ul class="notion-list notion-list-disc notion-block-ba5cdf07de3944ea84183d9fab8c5efb"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://go.dev/blog/constants">https://go.dev/blog/constants</a> （本文主要搬运来源）</li></ul><ul class="notion-list notion-list-disc notion-block-f7b45bfc8bf8475193cb2ae92d69b169"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://blog.learngoprogramming.com/learn-golang-typed-untyped-constants-70b4df443b61">https://blog.learngoprogramming.com/learn-golang-typed-untyped-constants-70b4df443b61</a></li></ul><div class="notion-blank notion-block-3554b88ab160438cae51c7eecbae9b14"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google 软件工程 读后感 Part I]]></title>
            <link>https://next.emergencyexit.xyz//software-engineering-at-google-impression.html</link>
            <guid>https://next.emergencyexit.xyz//software-engineering-at-google-impression.html</guid>
            <pubDate>Tue, 20 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[有趣的比喻集合]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-3927ece3993146e88e7e91d5e0b5c326"><div class="notion-viewport"></div><div class="notion-text notion-block-ec27187857af4dd7909a8b90936e43ea">总的来说，这本书值得所有软件开发从业者阅读。一些观点可能不至于奉之圭臬，但也可以提供另一种处理问题的视角。</div><div class="notion-text notion-block-897150010d224de4ba48d1ff6f8b1392">它将很多<b>存在于意识而尚未落成语言的软件工程共识</b>，用简单易读的方式总结表达了出来，相信对于大多数软件工程师都会有帮助。</div><div class="notion-text notion-block-c2ba7cfd50b3425084f45603fcbff89f">分享书中一些有趣的说法，如果你也觉得有意思，那么就买来读一读吧。</div><div class="notion-text notion-block-39594e9a3fce41e49b9a5210fdf01fa3">（如果你的「洋文🤓」够好，也可以直接<span class="notion-teal"><b>免费</b></span>阅读 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://abseil.io/resources/swe-book/html/toc.html">英文原版</a>）</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-07d4b358fcd44b0b90fb5a295bd4b1dd" data-id="07d4b358fcd44b0b90fb5a295bd4b1dd"><span><div id="07d4b358fcd44b0b90fb5a295bd4b1dd" class="notion-header-anchor"></div><a class="notion-hash-link" href="#07d4b358fcd44b0b90fb5a295bd4b1dd" title="海勒姆定律（Hyrum’s Law）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">海勒姆定律（Hyrum’s Law）</span></span></h3><blockquote class="notion-quote notion-block-57a7a82e02e64c1ca392536ae1ba3027">当一个 API 有足够多的用户时，在约定中你所承诺的已不重要：所有在你系统里面被观察到的行为都会被一些用户所依赖。</blockquote><div class="notion-text notion-block-4a142d26df674781897ce80fd220c487">我从中读出来的关键点：拒绝侥幸心理。当用户体量足够大时，任何改动都需要通过测试来收尾，侥幸心理自认为某些逻辑人畜无害，一两次可能可以省事儿，但总有一天会翻船。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-78bb3c9293c94075b5e2d2754f376ba1" data-id="78bb3c9293c94075b5e2d2754f376ba1"><span><div id="78bb3c9293c94075b5e2d2754f376ba1" class="notion-header-anchor"></div><a class="notion-hash-link" href="#78bb3c9293c94075b5e2d2754f376ba1" title="巴士系数（Truck Factor）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">巴士系数（<b>Truck Factor</b>）</span></span></h3><blockquote class="notion-quote notion-block-c067d91017c642edaf839e01370db824">指多少关键开发者被巴士撞了会让项目停摆。</blockquote><div class="notion-text notion-block-11cde37630c343f0a75319a674254b53">开发者被巴士撞了虽然有点残忍，但确实是一个很形象的表述——当成员突然不参与工作或失去通讯能力。可能在很多团队中，开发者的<b>突然离职</b>是更贴近这种场景的情况。想要尽量避免因为关键人物的离开而导致项目停摆，书中也列举了基础的预防措施：备份或者结对编程，“每一个人在工作时都需要第二双眼睛的监督”，最重要的是 “拒绝隐藏”。</div><div class="notion-text notion-block-33bed20e701b40cb81c0322f955c84b9">就我个人的经验而言，在项目开发过程中保持良好的文档记录习惯是一种“美德”，在一些更有追求的团队，更应该是“义务”。良好的文档可以一定程度上保持当“巴士”袭来时，团队能够依靠文档维持相当程度的稳定。</div><div class="notion-text notion-block-ec305ffabbeb455098df8f3d02b657c0">当然以上都是从 <b>“团队最优” </b>的角度来说，并不是所有公司都有 Google 的优秀风气，我还在别的团队听过”教会徒弟，饿死师傅“的说法。</div><div class="notion-text notion-block-e4707ad77bbc4cafb4441ddf3eba5912">这其中孰对孰错，是分享还是私藏，很难在这篇读后感中用几百字讨论清楚。</div><div class="notion-text notion-block-6898e8ff30cf46638d1d72ec2c563dad">我们需要保持清醒：互联网从业有它的特殊性——知识获取门槛极低，任何领域都可以通过网络资源轻松入门，但同时也有其他行业相似的普遍性——在资本逐利的背景下，行业失去高增长，更低成本的人力总是会更有竞争力。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-0f50d6ae1c1e4bf4a295cb1abb100879" data-id="0f50d6ae1c1e4bf4a295cb1abb100879"><span><div id="0f50d6ae1c1e4bf4a295cb1abb100879" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0f50d6ae1c1e4bf4a295cb1abb100879" title="左移思想（Left Shift）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">左移思想（Left Shift）</span></span></h3><blockquote class="notion-quote notion-block-8864520720f8419ab3d1ea039198f93d">在开发人员工作流的早期发现问题通常会降低成本。</blockquote><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-64e5a128d5ba4638a1c92360e5482d1a"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:432px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F33295efc-1f2c-441e-8829-fb516edd724c%2FUntitled.png?table=block&amp;id=64e5a128-d5ba-4638-a1c9-2360e5482d1a&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-12c690895f02451998de285e999ba4b5">配合此图，还是非常容易理解的。从开发人员的角度来看，可能存在的问题在越前端解决付出的成本肯定是越小的。举个小例子，陶文在 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zhuanlan.zhihu.com/p/357411780">《不要以 DRY 之名，发明低代码 DSL 去残害你的同事》</a>提到过，缺乏与上游（比如产品、策划）的沟通，只是在开发侧 “一厢情愿” 的抽象可能是一个误区：“先要把需求的源头给按住了。而不是在需求的下游，用可复用抽象代码来兜底”。</div><div class="notion-text notion-block-aac58e9671844d35ad0ccc013e987983">类似地，在敏捷开发和 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://devops.com/devops-shift-left-avoid-failure/">DevOps 开发理论中也提到过</a> ，同时还有一个 “<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://devops.com/shift-right-testing-the-emergence-of-testops/">测试右移</a>” 的概念，在测试或者是性能检查时，尽量从贴近用户端出发来保证整个产品流程的质量。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-0d9a2e22b9e049a8bac1ff5ca37930de" data-id="0d9a2e22b9e049a8bac1ff5ca37930de"><span><div id="0d9a2e22b9e049a8bac1ff5ca37930de" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0d9a2e22b9e049a8bac1ff5ca37930de" title="经理人炎症（Manageritis）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">经理人炎症（Manageritis）</span></span></h3><blockquote class="notion-quote notion-block-0fe7688ff117426b89f4240ba74b020c">对于处于进步边缘的有抱负的或者那些刚刚晋升的领导者，存在一种高度危险的自我炎症，称为“管理炎”。</blockquote><div class="notion-text notion-block-f6c396005f6a40a086d0c1750da40ca2">更简单说法是 “刻意管理”，这种症状多数出现在从个人贡献者 → 管理者身份转变期。很大的原因是，作为技术开发者，我们已经很习惯于在专业技能上投资，并有着合适的回报预期：比如定期在某个领域深入学习，你就能立马获得该领域的技能提升。但是转变到“经理”时，这个回报周期变得不一样了（通常会更长），带领团队向上提升，个体的技能成长反而不容易被感知，会导致做出更高频次的“投资”动作，更加”努力管理”，更容易显得刻意。</div><div class="notion-text notion-block-5dee97aa820d411fbc7f0b9e60bcc51b">还有一个方面的原因，从个人贡献者到管理者后，将会面临很多抉择的场景：<em>自己动手，快速解决问题 </em>vs <em>交给他人，更慢更困难地解决问题</em>，及时从更长尺度上来看，后者收益会更高，但在这个抉择面前，没有经验的管理者还是会显得非常犹豫。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-af607e49d1ed49c0ad3bb362bf92ffbe" data-id="af607e49d1ed49c0ad3bb362bf92ffbe"><span><div id="af607e49d1ed49c0ad3bb362bf92ffbe" class="notion-header-anchor"></div><a class="notion-hash-link" href="#af607e49d1ed49c0ad3bb362bf92ffbe" title="碧昂丝规则（Beyoncé Rule）"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">碧昂丝规则（Beyoncé Rule）</span></span></h3><blockquote class="notion-quote notion-block-08f7f47edaa44f40a7387935ba510099">“如果你喜欢它，你就应该测试它”。</blockquote><div class="notion-text notion-block-06be070f5c2f4fe29ec84970faf12195">原型是：&quot;If you liked it then you shoulda put a ring on it”，来自于碧昂斯 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.youtube.com/watch?v=4m1EFMoRFvY">Single Lady(Put a Ring on It)</a> 歌词（我感觉关联性不大，我猜是碧昂斯粉丝的私货 🤣）。</div><div class="notion-text notion-block-b55310de83394d8a8578c751aa107df5">意思是“所有不想被破坏的东西”都应该被测试。当你的项目依赖于某些外部系统时，如果想确保一些特性能够符合预期，那么唯一的办法就是在自己的项目编写测试。</div><div class="notion-text notion-block-7b582dc921d64925af13c234ff261fe9">这一点容易被泛化到外部系统的所有特性，我的理解是需要妥善处理依赖的外部系统<b>常见的重点场景</b>出现异常的情况，而不是全部，也不应该关注全部。</div><div class="notion-text notion-block-140a4fcfb666460b9428f70357693cbd">在 Google 内部常有一种说法：“如果一个产品由于基础设施的变更出现中断或其它问题，但是在我们的持续集成(CI)系统中的自动化测试用例并没有发现这个问题，那么就不应该由负责基础设施的团队承担责任。”</div><div class="notion-text notion-block-c0789386a8ff49b3941623f22c3334df">在我们日常的工作场景中，大家普遍是没有这个意识的，如果基础设施出问题，无论我们是否有预料，黑锅都可以毫无负担的甩下去，也造成基础设施部门普遍承受了过多压力 xD。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-42d3995b003b481b880565f8f241d6b8" data-id="42d3995b003b481b880565f8f241d6b8"><span><div id="42d3995b003b481b880565f8f241d6b8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#42d3995b003b481b880565f8f241d6b8" title="Fin"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Fin</span></span></h3><div class="notion-text notion-block-f4922f38c9ce4edc8ea1d08ddecb407b">书中还有一些更大值得讨论的话题，以后或许有机会可以结合自己的项目经历写出来聊聊<em><s>（典型的挖坑不埋）</s></em>。</div><div class="notion-blank notion-block-161f0f3cd34d432493910405685342ba"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Django ORM：天使与魔鬼 II]]></title>
            <link>https://next.emergencyexit.xyz//django-orm-best-practice-II.html</link>
            <guid>https://next.emergencyexit.xyz//django-orm-best-practice-II.html</guid>
            <pubDate>Fri, 09 Sep 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[CRUD boy 回来了]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-6ad26f7b18284d64a9483cc6367f6901"><div class="notion-viewport"></div><div class="notion-text notion-block-917f169ee9c34019a62c5f85892e3620">最近重操 CRUD 旧业，又有一些新的发现，故增加一篇 <a class="notion-link" href="https://www.notion.so/982e294cabb247aa878134d8bb6fd6ce">Django ORM：天使与魔鬼</a> Part II。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-4d19de6795b04c9f89f8e3a758d0954c" data-id="4d19de6795b04c9f89f8e3a758d0954c"><span><div id="4d19de6795b04c9f89f8e3a758d0954c" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4d19de6795b04c9f89f8e3a758d0954c" title="利用 batch_size 控制数据库单次提交的大小"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">利用 batch_size 控制数据库单次提交的大小</span></span></h3><div class="notion-text notion-block-4441855d1bb34da0aed6aa17fcf05202"><code class="notion-inline-code">bulk_create</code> 和 <code class="notion-inline-code">bulk_update</code> 是我们常用的批量创建、更新的方法，但批量提速一时爽，提交过长会直接导致任务失败。</div><div class="notion-text notion-block-5c409ae54dae4b2b882909acbbeec43c">之前没有细致查阅文档，想当然 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/TencentBlueKing/bk-user/blob/cd3d14b72d92de0cf687e9466a797b9fd07e0daf/src/api/bkuser_core/common/db_sync.py#L140">手写了批量提交分片的逻辑</a> ，虽然也完全实现了功能，但终究多了一份需要维护的逻辑，实际上直接用 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/querysets/#bulk-create">Django 默认提供的 </a><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/querysets/#bulk-create"><code class="notion-inline-code">batch_size</code></a> 即可。</div><pre class="notion-code language-python"><code class="language-python">from itertools <span class="token keyword">import</span> islice

batch_size <span class="token operator">=</span> <span class="token number">100</span>
objs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">Entry</span><span class="token punctuation">(</span>headline<span class="token operator">=</span><span class="token string">'Test %s'</span> <span class="token operator">%</span> i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token literal-property property">True</span><span class="token operator">:</span>
    batch <span class="token operator">=</span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token function">islice</span><span class="token punctuation">(</span>objs<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> not batch<span class="token operator">:</span>
        <span class="token keyword">break</span>
    Entry<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">bulk_create</span><span class="token punctuation">(</span>batch<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span></code></pre><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-4560c1f2cdc34fc8b26c830584140494" data-id="4560c1f2cdc34fc8b26c830584140494"><span><div id="4560c1f2cdc34fc8b26c830584140494" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4560c1f2cdc34fc8b26c830584140494" title="通过 Prefetch 控制预取的查询"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">通过 Prefetch 控制预取的查询</span></span></h3><div class="notion-text notion-block-942fb49c92dd440eacbde16315aa4e4c"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping">N + 1 问题</a>是非常常见的查询效率杀手。在 Django 中我们通常会使用 <code class="notion-inline-code">selected_related</code> 或<code class="notion-inline-code">prefetch_related</code> 来预取关联对象，来减少和 DB 之间的交互，但是在使用上也需要有一些注意的地方。</div><div class="notion-text notion-block-29fd3c9a717c4acaa7d4af894c3bf0e7">首先，预取需要精确控制到字段。</div><div class="notion-text notion-block-e116a47ba91e4fe3a33d9bbd54be8429">Django 默认的查询方式都是粗放的，例如普通查询不使用 <code class="notion-inline-code">values</code> 或者 <code class="notion-inline-code">only</code> 时都是 <code class="notion-inline-code">select *</code> ，而预取也不例外，看看下面这个例子。</div><pre class="notion-code language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	<span class="token operator">...</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	foo <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">ForeignKey</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span>
	<span class="token operator">...</span>

<span class="token keyword">class</span> <span class="token class-name">Baz</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
  <span class="token string">""</span><span class="token string">"A very large table"</span><span class="token string">""</span>
	foo <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">ForeignKey</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-844a600b3a5c44fb806ca38269fa0a16">我们在查询 <code class="notion-inline-code">Foo</code> 时，会尝试预取关联字段以加速后续数据读取，但如果我们在调用时不加任何参数：<code class="notion-inline-code">Foo.objects.all().prefetch_related()</code> ，<b>默认地 Django 会将所有关联字段都取出来</b>，加入 <code class="notion-inline-code">Baz</code> 表无比巨大，本来用作性能优化的 <code class="notion-inline-code">prefetch_related</code> 就会摇身变成耗时怪兽。</div><div class="notion-text notion-block-05eabf30586c4efd84335bcd09602fed">此外，我们还会遇到级联预取的场景。</div><pre class="notion-code language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	<span class="token operator">...</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	foo <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">ForeignKey</span><span class="token punctuation">(</span>Foo<span class="token punctuation">,</span> related_name<span class="token operator">=</span><span class="token string">"bars"</span><span class="token punctuation">)</span>
	<span class="token operator">...</span>

<span class="token keyword">class</span> <span class="token class-name">Baz</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token operator">:</span>
	bar <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">ForeignKey</span><span class="token punctuation">(</span>Bar<span class="token punctuation">,</span> related_name<span class="token operator">=</span><span class="token string">"bazs"</span><span class="token punctuation">)</span>
	large_config <span class="token operator">=</span> models<span class="token punctuation">.</span><span class="token function">JSONField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">...</span></code></pre><div class="notion-text notion-block-f2e6729bc91346c6ad21fd1a2bcd4ff4">此时在后续的循环处理中，我们需要通过 <code class="notion-inline-code">Foo</code> 对象查询到 <code class="notion-inline-code">Baz</code> 的数据，为了避免 N + 1 我们也会多级预取:</div><pre class="notion-code language-python"><code class="language-python">Foo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">select_related</span><span class="token punctuation">(</span><span class="token string">"bars"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prefetch_related</span><span class="token punctuation">(</span><span class="token string">"bars__bazs"</span><span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-e7a383c89d8a47d98bb03ea1215373c5">此时二级预取也是默认获取全部字段，倘若 <code class="notion-inline-code">Baz</code> 表中有一个需要额外耗时序列化的字段，同样会使优化适得其反。这时可以考虑引入 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.djangoproject.com/zh-hans/4.1/ref/models/querysets/#prefetch-objects"><code class="notion-inline-code">Prefetch</code></a> 对象，做更细致的查询控制。</div><pre class="notion-code language-python"><code class="language-python">Foo<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">select_related</span><span class="token punctuation">(</span><span class="token string">"bars"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">prefetch_related</span><span class="token punctuation">(</span>
	<span class="token function">Prefetch</span><span class="token punctuation">(</span><span class="token string">"bars__bazs"</span><span class="token punctuation">,</span> queryset<span class="token operator">=</span>Baz<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token string">"large_config"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span></code></pre><div class="notion-blank notion-block-49ad21cac56745f889392cedcb9e5b71"> </div><div class="notion-text notion-block-744cc7796009402fab94db362da28356">是不是觉得 ORM 查询本身也挺繁杂的？用 SQL 有时会更直接清晰地多。所以也会有一些完全<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://dev.solita.fi/2021/06/01/why-avoid-an-orm.html">不使用 ORM 的观点</a>。在我看来，ORM 能让 90% 的查询都变得结构化更清晰、更易维护、甚至更安全，但剩下的 10% 也许会耗费更多的精力，所以何时使用 ORM 是根据具体项目场景来定的，不能因噎废食。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-b5a4d66ac57a4ca8b13e1028109b39c7" data-id="b5a4d66ac57a4ca8b13e1028109b39c7"><span><div id="b5a4d66ac57a4ca8b13e1028109b39c7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b5a4d66ac57a4ca8b13e1028109b39c7" title="小广告"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">小广告</span></span></h3><div class="notion-text notion-block-f88ddea20edb497b87e46b9377a818d2">是不是觉得 Part II 内容有点少？没关系，更多的内容我都放在了这里。</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-11be5a01c4ec4b2abb68cbf4b3bc73dc" href="https://github.com/TencentBlueKing/python-best-practices"><div><div class="notion-bookmark-title">GitHub - TencentBlueKing/python-best-practices</div><div class="notion-bookmark-description">Contribute to TencentBlueKing/python-best-practices development by creating an account on GitHub.</div><div class="notion-bookmark-link"><img src="https://github.com/favicon.ico" alt="GitHub - TencentBlueKing/python-best-practices" loading="lazy"/><div>https://github.com/TencentBlueKing/python-best-practices</div></div></div><div class="notion-bookmark-image"><img src="https://opengraph.githubassets.com/e9d11601584d87c0fbb4092264f7ab23a33987f8d05dfb8b0e0c57157aecc9b3/TencentBlueKing/python-best-practices" alt="GitHub - TencentBlueKing/python-best-practices" loading="lazy"/></div></a></div><div class="notion-text notion-block-c4cb7b9d7d92463eb7dd154161269031">我和团队小伙伴整理了很多 Python\Django\DRF 的最佳实践经验，项目会持续更新，欢迎一起探讨维护，希望每一个 CRUD 男孩/女孩都能少踩坑。</div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ReDoS：正则也许会让你的系统更脆弱]]></title>
            <link>https://next.emergencyexit.xyz//redos-and-why.html</link>
            <guid>https://next.emergencyexit.xyz//redos-and-why.html</guid>
            <pubDate>Tue, 01 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[“充数的文章描述”]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-9d18b689cdc24d3f81daa690c700caee"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-71c5c2ad3a0042a5854d1ffd540fb85b"><a href="#16167b014e884180872922c343d81f2f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">引</span></a><a href="#06a24e1d70ff4b4d8890c4411ad92c88" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">Evil Regex 大敌当前</span></a><a href="#11ab27b4d2ec4f7399a9aecafa750e00" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">知己知彼，百战不殆</span></a><a href="#1596c45ca40b4f4998f3be993530b2ee" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">NFA vs DFA</span></a><a href="#b0f1e34a5f0242bb83f7f49d56c2621f" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Thompson NFA 构造 vs DFA</span></a><a href="#ddeb7f785eb14d7b868a6917822d6ab5" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">为什么主流编程语言这么慢？</span></a><a href="#6e320bb2c4334d31af6172db35ede111" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">正面对抗 Evil Regex</span></a><a href="#8a414c655d0842eb9a242a88266b28e7" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">pyre2</span></a><a href="#12c4a78bedf14dcf8397441db47e3f36" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">regex</span></a><a href="#8ef69d8b54184936a684009d1c35948e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-16167b014e884180872922c343d81f2f" data-id="16167b014e884180872922c343d81f2f"><span><div id="16167b014e884180872922c343d81f2f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#16167b014e884180872922c343d81f2f" title="引"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">引</span></span></h3><div class="notion-text notion-block-64a4a303b845467c8de321306c3fee84">这里有一段看起来稀松平常、人畜无害的 Python 代码，你可以试着执行一下：</div><pre class="notion-code language-python"><code class="language-python"><span class="token keyword">import</span> re
<span class="token keyword">import</span> time


value <span class="token operator">=</span> <span class="token string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaabs"</span>
strange_regex <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"(a+)+s"</span><span class="token punctuation">)</span>

start <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
re<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>strange_regex<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
end <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">print</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-6bb9397fa1ab4801b7edd5bff3e9243b">不知道大家执行了多久，在我开发机上使用 Python 3.6+（包括 3.10.x）<b>需要耗费20秒以上</b>，即使 CPU ——Apple M1 Pro 的性能已经相当强悍了。</div><div class="notion-text notion-block-e33e99798c1f48bd897156f2a344cbf3">可以试想一下，如果在生产环境服务的关键请求链路中存在这样正则匹配，加上不可控的用户输入，很容易落入“性能陷阱”，轻则拖慢系统，重则直接让服务暴露在 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/ReDoS">ReDoS</a> (Regual Expression Denial-of-Service) 的风险之下。</div><div class="notion-text notion-block-429048f3ea3c4f989258b2e1a3aa81c4">随手一搜，已经有不少相关的案例发生：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23343">CVE-2021-23343</a> 、<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41817">CVE-2021-41817</a>。所以，它值得我们格外重视。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-06a24e1d70ff4b4d8890c4411ad92c88" data-id="06a24e1d70ff4b4d8890c4411ad92c88"><span><div id="06a24e1d70ff4b4d8890c4411ad92c88" class="notion-header-anchor"></div><a class="notion-hash-link" href="#06a24e1d70ff4b4d8890c4411ad92c88" title="Evil Regex 大敌当前"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Evil Regex 大敌当前</span></span></h3><div class="notion-text notion-block-421e347965f04238accb85b4748a20b0">先来看一些和上面例子类似的、典型的邪恶正则：</div><ul class="notion-list notion-list-disc notion-block-98d8301372354699a816e8fd5bc08002"><li><code class="notion-inline-code">(a+)+</code></li></ul><ul class="notion-list notion-list-disc notion-block-0d6cd58d075b49089d85ceaf2ab1753e"><li><code class="notion-inline-code">([a-zA-Z]+)*</code></li></ul><ul class="notion-list notion-list-disc notion-block-51804104983f4c3981f8d0f152a88f9f"><li><code class="notion-inline-code">(a|aa)+</code></li></ul><ul class="notion-list notion-list-disc notion-block-d0d2e591195a4ac8b863524a9b98eba7"><li><code class="notion-inline-code">(a|a?)+</code></li></ul><ul class="notion-list notion-list-disc notion-block-c6b2c4201dcd4463b918ba3275a4887b"><li><code class="notion-inline-code">(a|a)+$</code></li></ul><ul class="notion-list notion-list-disc notion-block-b4e5e7f0f44740ff8b09a30eb3ab254a"><li> <code class="notion-inline-code">(.*a){x} for x \&gt; 10</code></li></ul><div class="notion-text notion-block-95a16b9277c84bd788ffad18af9382a9">它们都有共同的一些特点：</div><ul class="notion-list notion-list-disc notion-block-eb56bd6f90c74deaaf58989c90b25b0a"><li>存在子表达重复——形如 <code class="notion-inline-code">()+</code> 、 <code class="notion-inline-code">()*</code></li></ul><ul class="notion-list notion-list-disc notion-block-0f99c854d6a74797b1fb0c53db1de6a8"><li>在重复的子表达中：</li><ul class="notion-list notion-list-disc notion-block-0f99c854d6a74797b1fb0c53db1de6a8"><li>存在重复项—— <code class="notion-inline-code">(a+)+</code></li><li>存在交替重复—— <code class="notion-inline-code">(a|aa)+</code></li></ul></ul><ul class="notion-list notion-list-disc notion-block-481496a757be470f9f6e511dc06659e9"><li>在重复的子表达的末尾，存在一个子表达式无法匹配的内容，例如 <code class="notion-inline-code">(a|a)+$</code></li></ul><div class="notion-text notion-block-a492ebc689144979995324686ba5ca7f">那么为什么这些重复会导致匹配速度如此之慢呢？我们要看看正则的具体实现思路。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-11ab27b4d2ec4f7399a9aecafa750e00" data-id="11ab27b4d2ec4f7399a9aecafa750e00"><span><div id="11ab27b4d2ec4f7399a9aecafa750e00" class="notion-header-anchor"></div><a class="notion-hash-link" href="#11ab27b4d2ec4f7399a9aecafa750e00" title="知己知彼，百战不殆"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">知己知彼，百战不殆</span></span></h3><div class="notion-text notion-block-492dbeb1cfc1451b95d0a1dbecd70d7a">当前主流语言的正则实现机制都是构建<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton"><b>非确定有限状态自动机(NFA)</b></a><b> </b>，相较于<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton"><b>确定有限状态自动机(DFA)</b></a>，前者会使用<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Backtracking">回溯法(backtracking)</a>，这也是导致邪恶正则存在的根因。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-1596c45ca40b4f4998f3be993530b2ee" data-id="1596c45ca40b4f4998f3be993530b2ee"><span><div id="1596c45ca40b4f4998f3be993530b2ee" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1596c45ca40b4f4998f3be993530b2ee" title="NFA vs DFA"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">NFA vs DFA</span></span></h4><div class="notion-text notion-block-3f9b78a623b0451c9cf0799a903fdc0b">（该章节中的图例均来自<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://swtch.com/~rsc/regexp/regexp1.html">这篇文章</a>，我在这里做了内容简化，建议有兴趣的同学阅读英文原文）</div><div class="notion-text notion-block-620943d008c0426da775e5a82b0f2f74">FA 有限自动机，又称 FSM 有限状态机，在当前的语境下，我们统一都是用 FA 来描述。这种计算模型比较常见，所以我们就着重关注 NFA 和 DFA 的对比。</div><div class="notion-text notion-block-36f538b5c08e41df94547097e1490efd">首先，来看一个简单的正则表达式—— <code class="notion-inline-code">a(bb)+a</code> ，它可以转换成以下两种表达：</div><div class="notion-row notion-block-8b914cd473c64b568ab10330ec59c60f"><div class="notion-column notion-block-9cbe557272fc42eb982c33bdfb7972bd" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-64d3af5c94464206883ad1543abd6203"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:54px"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe41cc1a4-ae04-422e-8a4d-22e77e03d496%2FUntitled.png?table=block&amp;id=64d3af5c-9446-4206-883a-d1543abd6203&amp;cache=v2" loading="lazy" alt="DFA" decoding="async"/><figcaption class="notion-asset-caption">DFA</figcaption></div></figure></div><div class="notion-spacer"></div><div class="notion-column notion-block-3a10ae26ed6b4fee9b000d4e03623deb" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-6fdf1be8b201455488080f316c0cea35"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:54px"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F18765429-1c82-4046-9afe-21a3a68d505d%2FUntitled.png?table=block&amp;id=6fdf1be8-b201-4554-8808-0f316c0cea35&amp;cache=v2" loading="lazy" alt="NFA" decoding="async"/><figcaption class="notion-asset-caption">NFA</figcaption></div></figure></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-351ce2ee5b03445fa5e21f10c9d4c8f5">上面两张图能够很清晰地表现出二者的不同：</div><ul class="notion-list notion-list-disc notion-block-0f74de50e44b48628c88eb34d668addd"><li>DFA 中，每一个状态在接收到输入时，下一个状态都是确定的。</li></ul><ul class="notion-list notion-list-disc notion-block-6db506c14054421eb3826a97952bf93c"><li>NFA 中，存在某些状态在接收到输入时，无法确定下一个状态：例如图中的 S2 接收到字符 b，S1 和 S3 都是可能的下一个状态。所以系统在分支选择时，需要进行猜测。</li></ul><div class="notion-text notion-block-1b2eff3ae49e4c19b23519afe1033bfd">理论上，每一条正则表达式都可以等同转换成一个 NFA 状态机，那么如果使用 NFA 进行匹配，如何处理猜测分支就很重要了。下面我们来看一个简单遍历猜测的例子。</div><div class="notion-text notion-block-61de96581b8649f9a63000513ca7458b">根据正则 <code class="notion-inline-code">abab|abbb</code> 我们可以建立如下的 NFA：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-a81212ec0de24ed5befc71a01610d802"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:364px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F100299f6-ef9d-41f6-b77c-dfbcb1644614%2FUntitled.png?table=block&amp;id=a81212ec-0de2-4ed5-befc-71a01610d802&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-9d8ec084d55741759e4c296c58045065">模拟计算机匹配输入 <code class="notion-inline-code">abbb</code>，可以有如下两种路径：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-e4c28ba34b134c6ca5a9a0d69c02ed8f"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2d01c07f-0cde-40f3-8ad1-837137c1d9d8%2FUntitled.png?table=block&amp;id=e4c28ba3-4b13-4c6c-a5a9-a0d69c02ed8f&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-0fd8ce7c02894191b05b1c13de3bf6d6">以 Step 0 开始的路径，在匹配到第三个字符时出错，此时不得不采用回溯，再次从一开始进行匹配，即 Step 4 → Step 8。</div><div class="notion-text notion-block-98ec072a50a04ad68c2e3b7317d2b355">通过这个回溯方法，我们来思考正则表达式 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span> 与字符串 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span> 匹配：</div><div class="notion-text notion-block-50124f3a5808418c8ce289482e7c3f29">如果每一次判断 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span> 是否存在时，都会尝试匹配“存在”的情况，再匹配不存在的情况，而整个字符串长度为 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，也就是时间复杂度为  <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>。</div><div class="notion-text notion-block-d65ba5a0c9b140f9a94c6fd9c0987fce">当前主流的语言（Perl, PCRE, Python, Ruby等）采用了<b>递归</b>来实现深度优先回溯，相较于 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Thompson%27s_construction">Thompson NFA</a>，最终实现的效果都是惊人的糟糕。</div><div class="notion-row notion-block-4088dc8fdb2b46e39e930be62fcd58b6"><div class="notion-column notion-block-cf952c80f58d42c494f54b20d578f2b2" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-08040b98a5b94de2945d4247f370a6ec"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:301px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F62d6c97a-651f-4dae-9157-3711b51864ef%2FUntitled.png?table=block&amp;id=08040b98-a5b9-4de2-945d-4247f370a6ec&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></div><div class="notion-spacer"></div><div class="notion-column notion-block-98b4b7afbadd4ca487963dc17f121754" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-46b7fb61de5e43cda2bb4539a1289ce4"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:302px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc1b2f543-8d54-4deb-be08-868bc57b76b6%2FUntitled.png?table=block&amp;id=46b7fb61-de5e-43cd-a2bb-4539a1289ce4&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure></div><div class="notion-spacer"></div></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-b0f1e34a5f0242bb83f7f49d56c2621f" data-id="b0f1e34a5f0242bb83f7f49d56c2621f"><span><div id="b0f1e34a5f0242bb83f7f49d56c2621f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b0f1e34a5f0242bb83f7f49d56c2621f" title="Thompson NFA 构造 vs DFA"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Thompson NFA 构造 vs DFA</span></span></h4><div class="notion-text notion-block-afff615182dc435797079cc33b8aefd7">为什么使用了 Thompson NFA 构造出的正则匹配会快这么多呢？主要的原因是：通过划分多个子表达式，合并相同的内容，从而减少了回溯次数。</div><div class="notion-text notion-block-6cdd0a3f42c640deb1ff811859b6d99d"><span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span> 可以转换成 Thompson 构造，图示：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-bd7f13b291b6492a8f8a5d6ca6538309"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F72c2591d-be7f-4f93-b93b-30904f2f6b6c%2FUntitled.png?table=block&amp;id=bd7f13b2-91b6-492a-8f8a-5d6ca6538309&amp;cache=v2" loading="lazy" alt="notion image" decoding="async"/></div></figure><div class="notion-text notion-block-4adb904d36044ce89832ec563f19787d">稍微做一些解释：</div><ul class="notion-list notion-list-disc notion-block-294f0999d9db457992ec78d4fcf9fe15"><li>q 是开始，f 是结束，白圈是状态，连线是流转</li></ul><ul class="notion-list notion-list-disc notion-block-c912429971304c0ca8c14ebace72871d"><li>ε 代表着无输入</li></ul><div class="notion-text notion-block-9e2bbaa903264df6abc8ed9da0294974">通过以上的结构，Thompson NFA 匹配的时间复杂度为  <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，空间复杂度为<span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>。</div><div class="notion-blank notion-block-260ec4a9ed5046938614b4ab45ae7d56"> </div><div class="notion-text notion-block-bd241b5ae0bf4d23b71a7cdd8c3e8648">而 DFA 更容易理解，因为它是典型的空间换时间。</div><div class="notion-row notion-block-8b5cf75e5a9943e0899a0d186eb3497b"><div class="notion-column notion-block-acc05c036d394d77997d269693990926" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-dd9acf4affef4e29a77df33a9f6ee061"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:424px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7febb121-726d-47a6-80c5-9351397addd6%2FUntitled.png?table=block&amp;id=dd9acf4a-ffef-4e29-a77d-f33a9f6ee061&amp;cache=v2" loading="lazy" alt="NFA" decoding="async"/><figcaption class="notion-asset-caption">NFA</figcaption></div></figure></div><div class="notion-spacer"></div><div class="notion-column notion-block-c621a865b06447f4b2fd833d81b688d3" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-d8d60f096b0f4e069dc8b2409811f5ac"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:496px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F903b942f-49b7-4953-923c-55fb6d520bd5%2FUntitled.png?table=block&amp;id=d8d60f09-6b0f-4e06-9dc8-b2409811f5ac&amp;cache=v2" loading="lazy" alt="DFA" decoding="async"/><figcaption class="notion-asset-caption">DFA</figcaption></div></figure></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-323df8cbfe25433eba3d392eb38f2e8b">可以看到每一个 DFA 的状态都等同于某一时刻 NFA 状态列表，所以 DFA 在最坏情况下，空间复杂度 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>，也会在构建阶段消耗更多时间。同时没有了回溯，整个匹配时间就是字符串长度，复杂度为 <span role="button" tabindex="0" class="notion-equation notion-equation-inline"><span></span></span>。为了保证 DFA 的空间消耗，一般都会额外对构建出的 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/DFA_minimization">DFA 做简化</a>，减少图的大小。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-ddeb7f785eb14d7b868a6917822d6ab5" data-id="ddeb7f785eb14d7b868a6917822d6ab5"><span><div id="ddeb7f785eb14d7b868a6917822d6ab5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ddeb7f785eb14d7b868a6917822d6ab5" title="为什么主流编程语言这么慢？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">为什么主流编程语言这么慢？</span></span></h4><div class="notion-text notion-block-556cfad12c9a4e90bc6a5aa982a85b89">说来有趣，Thompson NFA 构造法应该是编译原理的基础概念，DFA 方法从概念上也是比较简单，为什么当前的主流语言没有采用，反而采用了一个带有回溯的、效果远逊的版本？</div><div class="notion-text notion-block-4b68cbc5f2e14f5bbff6d29e174812aa">经过一番冲浪搜索，简单概括我找到的结论：<b>历史的局限</b>。</div><blockquote class="notion-quote notion-block-f0186a0b42784296a704da19665a61ff"><em>While writing the text editor sam [6] in the early 1980s, Rob Pike wrote a new regular expression implementation, which Dave Presotto extracted into a library that appeared in the Eighth Edition. Pike&#x27;s implementation incorporated submatch tracking into an efficient NFA simulation but, like the rest of the Eighth Edition source, was not widely distributed. Pike himself did not realize that his technique was anything new. </em><span class="notion-red"><em>Henry Spencer reimplemented the Eighth Edition library interface from scratch, but using backtracking, and released his implementation into the public domain.</em></span><em> </em><span class="notion-red"><em>It became very widely used, eventually serving as the basis for the slow regular expression implementations mentioned earlier: Perl, PCRE, Python, and so on.</em></span></blockquote><div class="notion-text notion-block-7f091f2eb6e74c62bbd877d83c1d92a8">可以从上文得知，正则匹配的实现首先需要兼容原来的使用方式，而当时开发者并未了解 NFA 模拟方法，而是自己从零实现了一个回溯方法，并且被广泛地传播开了。即使这个实现很慢，但是由于已经被大规模采用，且能满足大多数的使用场景，各个主流语言也没有替换它。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-6e320bb2c4334d31af6172db35ede111" data-id="6e320bb2c4334d31af6172db35ede111"><span><div id="6e320bb2c4334d31af6172db35ede111" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6e320bb2c4334d31af6172db35ede111" title="正面对抗 Evil Regex"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">正面对抗 Evil Regex</span></span></h3><div class="notion-text notion-block-ed1e3a4cebbf4d4689dc02e9e576134b">既然当前主流语言的实现肯定会存在性能陷阱，我们是否有办法检测邪恶正则呢？答案是肯定的。</div><div class="notion-text notion-block-787a7eab4c8143eea147b25f34efb1c4">在社区里有不少相关项目，例如：<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/doyensec/regexploit">regexploit</a> 、<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/olivo/redos-detector">redos-detector</a> 、<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/davisjam/vuln-regex-detector">vuln-regex-detector</a> 等，它们都可以扫描出有风险的正则，就像这样：</div><pre class="notion-code language-shell"><code class="language-shell">$ echo <span class="token string">"(a+)+s"</span> <span class="token operator">|</span> regexploit
<span class="token literal-property property">Pattern</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token punctuation">)</span><span class="token operator">+</span>s
<span class="token operator">--</span><span class="token operator">-</span>
<span class="token function">Redos</span><span class="token punctuation">(</span>starriness<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> prefix_sequence<span class="token operator">=</span><span class="token constant">SEQ</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> redos_sequence<span class="token operator">=</span><span class="token constant">SEQ</span><span class="token punctuation">{</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">+</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">+</span><span class="token punctuation">}</span> <span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> repeated_character<span class="token operator">=</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">,</span> killer<span class="token operator">=</span>None<span class="token punctuation">)</span>
Worst<span class="token operator">-</span><span class="token keyword">case</span> <span class="token literal-property property">complexity</span><span class="token operator">:</span> <span class="token number">11</span> <span class="token function">⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐</span> <span class="token punctuation">(</span>exponential<span class="token punctuation">)</span>
Repeated character<span class="token operator">:</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>
<span class="token literal-property property">Example</span><span class="token operator">:</span> <span class="token string">'a'</span> <span class="token operator">*</span> <span class="token number">3456</span></code></pre><div class="notion-text notion-block-1e6c9924ca8148c2adbe7335b9bf6c62">但是它们局限于静态的正则扫描，对于我们开发者而言，静态防御并不能完全清除风险。更好的思路是直接替换语言的默认实现。以 Python 举例，我们也找到了一些替换库：</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-8a414c655d0842eb9a242a88266b28e7" data-id="8a414c655d0842eb9a242a88266b28e7"><span><div id="8a414c655d0842eb9a242a88266b28e7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8a414c655d0842eb9a242a88266b28e7" title="pyre2"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">pyre2</span></span></h4><pre class="notion-code language-shell"><code class="language-shell">pip install pyre2</code></pre><div class="notion-text notion-block-efda542abaf5447f92a67e6709475006">来自 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/google/re2/">Google re2</a> 模块的 Python 封装 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/facebook/pyre2">pyre2</a>，使用了 DFA 的构造方式。可以替换原生 <code class="notion-inline-code">re</code> 模块，大多数场景都可以得到速度的稳步提升，不存在性能陷阱。</div><div class="notion-text notion-block-289140745a58440b96faea1ec82f6395">但对于 DFA 模拟来说，都是自古华山一条道，比如 <code class="notion-inline-code">(?P=&lt;name&gt;)</code> 这样的属于 <code class="notion-inline-code">backreference</code> 的捕获组语法就无法支持了。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-12c4a78bedf14dcf8397441db47e3f36" data-id="12c4a78bedf14dcf8397441db47e3f36"><span><div id="12c4a78bedf14dcf8397441db47e3f36" class="notion-header-anchor"></div><a class="notion-hash-link" href="#12c4a78bedf14dcf8397441db47e3f36" title="regex"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">regex</span></span></h4><pre class="notion-code language-shell"><code class="language-shell">pip install regex</code></pre><div class="notion-text notion-block-1f35e9047a1c4d47a37d67ce17ed1e04"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/mrabarnett/mrab-regex">regex</a> 模块<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/mrabarnett/mrab-regex/issues/136">并未使用 DFA 构造</a>，在完全兼容 <code class="notion-inline-code">re</code> 模块的同时，支持了一些<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/mrabarnett/mrab-regex#old-vs-new-behaviour">新特性</a>。由于实现方案的不同，也没有很明确的文档阐述，尚不清楚它具体的算法（<em>有待进一步从代码层面解读</em>），但是从效果上，它的性能要<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/mrabarnett/mrab-regex/issues/320">略好于原生模块</a>，仅从文中里例子测试看来，也规避了性能陷阱，可以谨慎采用。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-8ef69d8b54184936a684009d1c35948e" data-id="8ef69d8b54184936a684009d1c35948e"><span><div id="8ef69d8b54184936a684009d1c35948e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8ef69d8b54184936a684009d1c35948e" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h3><ul class="notion-list notion-list-disc notion-block-4c31a30c7e0e4ba19ea2a53dafd478c5"><li>和很多其他场景一样，程序需要时刻警惕用户的输入，任何不经过校验的内容都可能将程序拖垮。</li></ul><ul class="notion-list notion-list-disc notion-block-18e7ee68eda94a45b67b4c11dffeb5a7"><li>理论和实际存在各种各样的鸿沟，在面临现实场景时，理想的想法落地总是困难的。</li></ul><ul class="notion-list notion-list-disc notion-block-a5f4f5f11c0843a7b1ab7a3cbee60843"><li>原生不代表就是最优秀的。有特殊需求时可以使用社区方案进行替换。</li></ul><div class="notion-blank notion-block-3672e91b6a7c4125b6980f6f543b1536"> </div><div class="notion-text notion-block-b38fb92df2184f5096ca8ac1e6c65b00">参考：</div><ul class="notion-list notion-list-disc notion-block-2d5c165011ab41b7950ff02c9a393e88"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://swtch.com/~rsc/regexp/regexp1.html">https://swtch.com/~rsc/regexp/regexp1.html</a></li></ul><ul class="notion-list notion-list-disc notion-block-67c19c430a1c49d1ac8563f6f162c2ef"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS</a></li></ul><ul class="notion-list notion-list-disc notion-block-b05ea5bd8ae540baa38b654a5b723fac"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://shivankaul.com/blog/nfa-dfa-and-regexes">https://shivankaul.com/blog/nfa-dfa-and-regexes</a></li></ul><ul class="notion-list notion-list-disc notion-block-0049a5a2d6d54dae964b80639ecb4144"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://arstechnica.com/civis/viewtopic.php?f=20&amp;t=1195549">https://arstechnica.com/civis/viewtopic.php?f=20&amp;t=1195549</a></li></ul><ul class="notion-list notion-list-disc notion-block-237dd0aa005e4059a61b62f30bed7dc0"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://news.ycombinator.com/item?id=466957">https://news.ycombinator.com/item?id=466957</a></li></ul><ul class="notion-list notion-list-disc notion-block-9da5e5cb8a684f21bd2f67051397c140"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://medium.com/swlh/visualizing-thompsons-construction-algorithm-for-nfas-step-by-step-f92ef378581b">https://medium.com/swlh/visualizing-thompsons-construction-algorithm-for-nfas-step-by-step-f92ef378581b</a></li></ul><div class="notion-blank notion-block-3f8d2e743c47466294fb92ded6f58558"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[旧代码拾遗：如何在 Python 代码中修改 DNS 解析]]></title>
            <link>https://next.emergencyexit.xyz//update-dns-in-python.html</link>
            <guid>https://next.emergencyexit.xyz//update-dns-in-python.html</guid>
            <pubDate>Fri, 18 Feb 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[旧代码拾遗]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-a6c3c98f9ef945de9d524baec7327464"><div class="notion-viewport"></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-38daf52d57c342d4be99642547e69bec" data-id="38daf52d57c342d4be99642547e69bec"><span><div id="38daf52d57c342d4be99642547e69bec" class="notion-header-anchor"></div><a class="notion-hash-link" href="#38daf52d57c342d4be99642547e69bec" title="Why"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Why</span></span></h3><div class="notion-text notion-block-86d81791a3264f1f850f6fb0215f7f8e">我们访问 K8S 的 ApiServer 服务，由于为了保证安全性，证书中签发的域名仅包括 <code class="notion-inline-code">kubernetes</code> 和初始的有限 IP 列表，当 ApiServer 服务的 Master 节点需要被替换时，就无法使用新的节点 IP 访问了。解决的方案就是将 <code class="notion-inline-code">kubernetes</code> 域名和新的 IP 临时绑定，骗过证书校验。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-57a46d1303cc45398d79ae16a961b878" data-id="57a46d1303cc45398d79ae16a961b878"><span><div id="57a46d1303cc45398d79ae16a961b878" class="notion-header-anchor"></div><a class="notion-hash-link" href="#57a46d1303cc45398d79ae16a961b878" title="How？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">How？</span></span></h3><div class="notion-text notion-block-0134574ed5fc47fdb7044f7ae5305657">废话不多说，直接看代码</div><pre class="notion-code language-python"><code class="language-python"># <span class="token operator">-</span><span class="token operator">*</span><span class="token operator">-</span> coding<span class="token operator">:</span> utf<span class="token operator">-</span><span class="token number">8</span> <span class="token operator">-</span><span class="token operator">*</span><span class="token operator">-</span>
<span class="token keyword">import</span> contextlib
<span class="token keyword">import</span> importlib
<span class="token keyword">import</span> threading
from typing <span class="token keyword">import</span> Callable<span class="token punctuation">,</span> Dict<span class="token punctuation">,</span> Optional

from urllib3<span class="token punctuation">.</span>util <span class="token keyword">import</span> connection


<span class="token keyword">class</span> <span class="token class-name">CustomLocalDnsResolver</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>local<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token string">""</span>"支持线程级自定义 Dns 记录
    <span class="token string">""</span>"

    def <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token literal-property property">dns_map</span><span class="token operator">:</span> Optional<span class="token punctuation">[</span>dict<span class="token punctuation">]</span><span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token operator">:</span>
        # 线程保存各自 dns_map，但是访问入口均为 dns_map
        self<span class="token punctuation">.</span>dns_map <span class="token operator">=</span> dns_map or <span class="token punctuation">{</span><span class="token punctuation">}</span>


def <span class="token function">get_patch_create_connection_with_dns</span><span class="token punctuation">(</span>dns_resolver<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Callable<span class="token operator">:</span>
    <span class="token string">""</span><span class="token string">"simply get patched create_connection"</span><span class="token string">""</span>

    # 保留原方法
    _orig_create_connection <span class="token operator">=</span> <span class="token function">getattr</span><span class="token punctuation">(</span>importlib<span class="token punctuation">.</span><span class="token function">import_module</span><span class="token punctuation">(</span><span class="token string">'urllib3.util.connection'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'create_connection'</span><span class="token punctuation">)</span>

    def <span class="token function">patched_create_connection</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token string">""</span><span class="token string">"在 urllib3's create_connection 流程前解析 address"</span><span class="token string">""</span>
        domain<span class="token punctuation">,</span> port <span class="token operator">=</span> address
        # 当 _local_dns<span class="token punctuation">.</span>dns_map 为空，对正常流程无影响
        host <span class="token operator">=</span> dns_resolver<span class="token punctuation">.</span>dns_map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span> domain<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token function">_orig_create_connection</span><span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>

    <span class="token keyword">return</span> patched_create_connection


_local_dns <span class="token operator">=</span> <span class="token function">CustomLocalDnsResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
# patch 全局 create_connection
connection<span class="token punctuation">.</span>create_connection <span class="token operator">=</span> <span class="token function">get_patch_create_connection_with_dns</span><span class="token punctuation">(</span>_local_dns<span class="token punctuation">)</span>


@contextlib<span class="token punctuation">.</span>contextmanager
def <span class="token function">update_local_dns_once</span><span class="token punctuation">(</span>dns_map<span class="token operator">:</span> Dict<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token string">""</span><span class="token string">"一次性修改线程 dns 解析"</span><span class="token string">""</span>
    _local_dns<span class="token punctuation">.</span>dns_map <span class="token operator">=</span> dns_map
    <span class="token keyword">yield</span>
    _local_dns<span class="token punctuation">.</span>dns_map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


# 具体的使用场景
<span class="token keyword">with</span> <span class="token function">update_local_dns_once</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string-property property">"kubernetes"</span><span class="token operator">:</span> <span class="token string">"192.168.1.1"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span>
    # 可以在该 context 中请求外部系统</code></pre><div class="notion-blank notion-block-d6c4207d6e5f406d98f2f7f01373402a"> </div><div class="notion-blank notion-block-1798e8cd901544068cc7e842253d62bc"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[小记：如何将 Logstash7 镜像替换为 KonaJDK]]></title>
            <link>https://next.emergencyexit.xyz//use-konajdk-in-logstash-image.html</link>
            <guid>https://next.emergencyexit.xyz//use-konajdk-in-logstash-image.html</guid>
            <pubDate>Tue, 28 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[随手记录，简单却防遗忘]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-f7327b98b06a423a8b9f646e5ba2123f"><div class="notion-viewport"></div><div class="notion-blank notion-block-db808c0aadf3437d856ba61c501ddc3f"> </div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-56d00d6fc33c42f993dac1cac2f1192d" data-id="56d00d6fc33c42f993dac1cac2f1192d"><span><div id="56d00d6fc33c42f993dac1cac2f1192d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#56d00d6fc33c42f993dac1cac2f1192d" title="Step 0 预备环境"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Step 0 预备环境</span></span></h3><div class="notion-text notion-block-a6c6802f89cd49ffa227d1412ba85e2e">Rake 是一个由 Ruby 实现的 Make-like 工具，可以用 Ruby 来编排项目任务流程，例如出二进制包、构建镜像等。在 GitHub Logstash 项目的 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/elastic/logstash/blob/main/rakelib/artifacts.rake">rakelib</a> 里找到镜像构建逻辑。</div><div class="notion-text notion-block-e2aa50674a46414493bdf4a5db0a4b63">构建之前，需要保证构建机包含以下工具：</div><ul class="notion-list notion-list-disc notion-block-21edbc015296410cb6d699195fb2c21a"><li>Docker</li></ul><ul class="notion-list notion-list-disc notion-block-b097a4840a8244bb9c6f71c05339decc"><li>GNU Make</li></ul><ul class="notion-list notion-list-disc notion-block-e3e863afff554e338340b7d47028d284"><li>Python 3.5+ with Virtualenv</li></ul><ul class="notion-list notion-list-disc notion-block-ec9f85330613463c8cb3c0baf40783b6"><li>JRuby 9.1+ （实际上 Mac 自带 Ruby 也是可行的）</li></ul><div class="notion-text notion-block-481102291cd947a7b7755166ccfb5104">然后将 Logstash 项目 clone 到本地，并切换到预期修改的版本：</div><pre class="notion-code language-bash"><code class="language-bash">git checkout v7<span class="token punctuation">.</span><span class="token number">16.2</span></code></pre><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-77fd59e96d934fc29d55c6ffb4e0fb71" data-id="77fd59e96d934fc29d55c6ffb4e0fb71"><span><div id="77fd59e96d934fc29d55c6ffb4e0fb71" class="notion-header-anchor"></div><a class="notion-hash-link" href="#77fd59e96d934fc29d55c6ffb4e0fb71" title="Step 1 精简构建步骤"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Step 1 精简构建步骤</span></span></h3><div class="notion-text notion-block-71b0a3dec2a74de8a3cfddbcd89f377b">构建步骤中，默认会包括 Windows\MacOS 以及 Arm 的构建，如果你并不需要这些平台，可以如下手动修改构建步骤，能够大大加快你的构建速度：</div><pre class="notion-code language-ruby"><code class="language-ruby"># <span class="token function">create_archive_pack</span><span class="token punctuation">(</span>license_details<span class="token punctuation">,</span> <span class="token string">"x86_64"</span><span class="token punctuation">,</span> <span class="token string">"linux"</span><span class="token punctuation">,</span> <span class="token string">"windows"</span><span class="token punctuation">,</span> <span class="token string">"darwin"</span><span class="token punctuation">)</span>
<span class="token function">create_archive_pack</span><span class="token punctuation">(</span>license_details<span class="token punctuation">,</span> <span class="token string">"x86_64"</span><span class="token punctuation">,</span> <span class="token string">"linux"</span><span class="token punctuation">)</span>
# <span class="token function">create_archive_pack</span><span class="token punctuation">(</span>license_details<span class="token punctuation">,</span> <span class="token string">"arm64"</span><span class="token punctuation">,</span> <span class="token string">"linux"</span><span class="token punctuation">)</span></code></pre><figcaption class="notion-asset-caption"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/elastic/logstash/blob/2cf6675f538247be091df9d31cc455538f029a07/rakelib/artifacts.rake#L142">artifacts.rake</a></figcaption><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-912a6e2fab744f6e8b0f4b434806f701" data-id="912a6e2fab744f6e8b0f4b434806f701"><span><div id="912a6e2fab744f6e8b0f4b434806f701" class="notion-header-anchor"></div><a class="notion-hash-link" href="#912a6e2fab744f6e8b0f4b434806f701" title="Step 2 修改 Python 版本"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Step 2 修改 Python 版本</span></span></h3><div class="notion-text notion-block-2adb74e716a2480ea35f6f3b07850e98">如果你不想为了构建镜像额外下载其他 Python 版本，可以手动修改 Makefile</div><pre class="notion-code language-makefile"><code class="language-makefile"># <span class="token constant">PY_VERSION</span> <span class="token operator">?</span><span class="token operator">=</span> <span class="token number">3.6</span><span class="token number">.13</span>
# <span class="token operator">=></span>
<span class="token constant">PY_VERSION</span> <span class="token operator">?</span><span class="token operator">=</span> <span class="token number">3.6</span><span class="token number">.7</span></code></pre><figcaption class="notion-asset-caption"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/elastic/logstash/blob/2cf6675f538247be091df9d31cc455538f029a07/docker/Makefile#L3">Makefile</a></figcaption><div class="notion-text notion-block-bad578fd54a34a018be8aa73abcb9e3b">理论上保证 Python 版本大于 3.5 即可。</div><div class="notion-blank notion-block-53071725dbcc47bbacf124bd49fbb662"> </div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-2c3c96643334464f9ebc93d14cea61c2" data-id="2c3c96643334464f9ebc93d14cea61c2"><span><div id="2c3c96643334464f9ebc93d14cea61c2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#2c3c96643334464f9ebc93d14cea61c2" title="Step 3 指定 JDK 版本"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Step 3 指定 JDK 版本</span></span></h3><div class="notion-text notion-block-9fc57152348c48088f81bdd78a10d2f1">如标题所示，我们的目标是将 Logstash 镜像里的 OpenJDK 替换成 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/Tencent/TencentKona-11">KonaJDK</a>。构建时手动指定 JDK 地址即可</div><pre class="notion-code language-bash"><code class="language-bash"><span class="token constant">JDK_URL</span><span class="token operator">=</span>https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>Tencent<span class="token operator">/</span>TencentKona<span class="token operator">-</span><span class="token number">11</span><span class="token operator">/</span>releases<span class="token operator">/</span>download<span class="token operator">/</span>kona11<span class="token punctuation">.</span><span class="token number">0.13</span><span class="token operator">-</span>fiber<span class="token operator">/</span>TencentKona<span class="token operator">-</span><span class="token number">11.0</span><span class="token number">.13</span><span class="token punctuation">.</span>b1_jdk_fiber_linux<span class="token operator">-</span>x86_64<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz rake artifact<span class="token operator">:</span>docker</code></pre><div class="notion-blank notion-block-26ebe1cc373b40a2af4165805f5c18f8"> </div><div class="notion-text notion-block-bf0dcb10928d45a9a50662a45d504b34">等待构建，大功告成 xD</div><div class="notion-blank notion-block-46d2d7251c9f4e1398e84f133d1796db"> </div></main>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[用 GraphQL 查询你的 Django 应用]]></title>
            <link>https://next.emergencyexit.xyz//use-graphql-with-django.html</link>
            <guid>https://next.emergencyexit.xyz//use-graphql-with-django.html</guid>
            <pubDate>Sat, 27 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[强是挺强，但适用场景依旧有限]]></description>
            <content:encoded><![CDATA[<main class="notion light-mode notion-page notion-block-9a08823eeec64cc09ec8890cb0650aa7"><div class="notion-viewport"></div><div class="notion-table-of-contents notion-gray notion-block-7cbbabf5b06b4f1b832fe664023382bd"><a href="#6f80cc74a749486d8ad82ae7a1aea572" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">什么是 GraphQL ？</span></a><a href="#5041039329414c21aaebd26612c47d03" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">它有什么有意思的特性</span></a><a href="#5be2fa55f8854b9dae359baadc092859" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Fragments</span></a><a href="#51381a94e35a4a2790d130b10e46dbd2" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">Directives</span></a><a href="#f7baf2676dcd4b14a48a5960996fbfbb" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">和 REST 相比较有什么优势和劣势？</span></a><a href="#8b386b3470f74f38862ae13b9c8ee6e9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">TLDR</span></a><a href="#1d318237ebd04d408d49f9a6ac2982d0" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">vs 扩展的 REST 协议</span></a><a href="#3db8daa2fcb0409baa596fd5472b9ff3" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">什么是 GraphQL 客户端?</span></a><a href="#499a5d133c9b493e946a692b0e21a062" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">服务端落地：GraphQL → Django</span></a><a href="#8c904f70489a4268a7b5c8f4ca2d51e6" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">支持 Relay</span></a><a href="#3d929743493649a6a43da55924cdfa5e" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">引入 graphene-django-extras</span></a><a href="#0068853173e54e1bacc12aa21d51205d" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:24px">鉴权</span></a><a href="#10f53459be3844c7a1355a1ed5bd63b9" class="notion-table-of-contents-item"><span class="notion-table-of-contents-item-body" style="display:inline-block;margin-left:0">总结</span></a></div><div class="notion-callout notion-gray_background_co notion-block-2986488d269c41b787a73096363557d2"><span class="notion-page-icon" role="img" aria-label="😶‍🌫️">😶‍🌫️</span><div class="notion-callout-text">全文以后端开发视角写作，部分涉及到前端开发的介绍可能存在错误或者不准确，欢迎在评论区斧正</div></div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-6f80cc74a749486d8ad82ae7a1aea572" data-id="6f80cc74a749486d8ad82ae7a1aea572"><span><div id="6f80cc74a749486d8ad82ae7a1aea572" class="notion-header-anchor"></div><a class="notion-hash-link" href="#6f80cc74a749486d8ad82ae7a1aea572" title="什么是 GraphQL ？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">什么是 GraphQL ？</span></span></h3><div class="notion-text notion-block-9ce07e2a85a94064abc0f2e22d9324cf">先来看看 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://zh.wikipedia.org/wiki/GraphQL">wikipedia</a>：</div><blockquote class="notion-quote notion-block-5e3b15ce4caa4fc9a4bdf513a497a202">GraphQL 是一个开源的，面向 API 而创造出来的数据查询操作语言以及相应的服务端运行环境。</blockquote><div class="notion-text notion-block-46ff6eaaa64045318192214e00ed3b7a">GraphQL 首先是一种查询语言，它定义了一种通用的数据查询方式，可以理解为一种通用的 SQL，只不过前者面向抽象的数据集，后者往往是具体的关系型数据库。</div><div class="notion-text notion-block-2cbc564d204a449faf4f770a57101a88">其次，它还包括一种服务端运行时，用于实现查询语句解析、数据类型定义。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-5041039329414c21aaebd26612c47d03" data-id="5041039329414c21aaebd26612c47d03"><span><div id="5041039329414c21aaebd26612c47d03" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5041039329414c21aaebd26612c47d03" title="它有什么有意思的特性"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">它有什么有意思的特性</span></span></h3><div class="notion-text notion-block-78e75c481cda4072b1e02f6cd843e186">仅从后端开发视角，列举几个觉得有意思的特性</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-5be2fa55f8854b9dae359baadc092859" data-id="5be2fa55f8854b9dae359baadc092859"><span><div id="5be2fa55f8854b9dae359baadc092859" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5be2fa55f8854b9dae359baadc092859" title="Fragments"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Fragments</span></span></h4><pre class="notion-code language-graphql"><code class="language-graphql">query <span class="token function">HeroComparison</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">$first</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">3</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">leftComparison</span><span class="token operator">:</span> <span class="token function">hero</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">episode</span><span class="token operator">:</span> <span class="token constant">EMPIRE</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>comparisonFields
  <span class="token punctuation">}</span>
  <span class="token literal-property property">rightComparison</span><span class="token operator">:</span> <span class="token function">hero</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">episode</span><span class="token operator">:</span> <span class="token constant">JEDI</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>comparisonFields
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

fragment comparisonFields on Character <span class="token punctuation">{</span>
  name
  <span class="token function">friendsConnection</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">first</span><span class="token operator">:</span> $first</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    totalCount
    edges <span class="token punctuation">{</span>
      node <span class="token punctuation">{</span>
        name
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-c04278bd4ae44492a254104fde035325">使用 Fragment 复用查询内容，并且可以定义参数</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-51381a94e35a4a2790d130b10e46dbd2" data-id="51381a94e35a4a2790d130b10e46dbd2"><span><div id="51381a94e35a4a2790d130b10e46dbd2" class="notion-header-anchor"></div><a class="notion-hash-link" href="#51381a94e35a4a2790d130b10e46dbd2" title="Directives"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">Directives</span></span></h4><pre class="notion-code language-graphql"><code class="language-graphql">query <span class="token function">Hero</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">$episode</span><span class="token operator">:</span> Episode<span class="token punctuation">,</span> <span class="token literal-property property">$withFriends</span><span class="token operator">:</span> Boolean<span class="token operator">!</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">hero</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">episode</span><span class="token operator">:</span> $episode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name
    friends @<span class="token function">include</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">if</span><span class="token operator">:</span> $withFriends</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      name
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

# variables
<span class="token punctuation">{</span>
  <span class="token string-property property">"episode"</span><span class="token operator">:</span> <span class="token string">"JEDI"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"withFriends"</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-50804a4e6c7d45c1a89613654cb0eedd">可以通过通用的两种指令来控制一些字段的返回：</div><ul class="notion-list notion-list-disc notion-block-b6b987cd363943509af04767f54d1795"><li> <code class="notion-inline-code">@include(if: Boolean)</code> </li></ul><ul class="notion-list notion-list-disc notion-block-9d6988932833425689d6246356037357"><li> <code class="notion-inline-code">@skip(if: Boolean)</code> </li></ul><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-f7baf2676dcd4b14a48a5960996fbfbb" data-id="f7baf2676dcd4b14a48a5960996fbfbb"><span><div id="f7baf2676dcd4b14a48a5960996fbfbb" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f7baf2676dcd4b14a48a5960996fbfbb" title="和 REST 相比较有什么优势和劣势？"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">和 REST 相比较有什么优势和劣势？</span></span></h3><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-8b386b3470f74f38862ae13b9c8ee6e9" data-id="8b386b3470f74f38862ae13b9c8ee6e9"><span><div id="8b386b3470f74f38862ae13b9c8ee6e9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8b386b3470f74f38862ae13b9c8ee6e9" title="TLDR"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">TLDR</span></span></h4><div class="notion-text notion-block-b286d02d551a49ceb9c46c7736257409">REST 更多是从 HTTP 协议出发的一种约定协议，因为受制于 HTTP 协议本身的设计，在<b>表达能力</b>上是弱于<b>作为查询语言</b>的 GraphQL 的。</div><div class="notion-text notion-block-a88e97e928ae41ab81936449989916a6">同时，REST 通常都是由后端开发者主动封装，而 GraphQL 则是由前端主动拼装。</div><div class="notion-text notion-block-865d80be70cf4e4aaacde0d426f1e966">所以如果面对的场景是<span class="notion-teal">前端需求复杂而多变，GraphQL 肯定比 REST 更适合快速迭代。</span></div><div class="notion-text notion-block-d59f255d52314c30b7292fcf4312e374">也正因此，GraphQL 在实现上更加繁复，所以<span class="notion-pink">面对 API 数量少、需求不会轻易的场景时，REST 反而是更适合的技术选型。</span></div><div class="notion-blank notion-block-dd6dda57e33e4cc4a158fe795567d923"> </div><div class="notion-text notion-block-bae7469dcdf3408cab30219494171505"><em>作为后端开发，学习和使用 GraphQL 的动力，更多是</em><em><b>想将自己从 CRUD 的泥沼中拯救出来，</b></em><em>将更多的精力放在其他更重要的技术上。</em></div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-1d318237ebd04d408d49f9a6ac2982d0" data-id="1d318237ebd04d408d49f9a6ac2982d0"><span><div id="1d318237ebd04d408d49f9a6ac2982d0" class="notion-header-anchor"></div><a class="notion-hash-link" href="#1d318237ebd04d408d49f9a6ac2982d0" title="vs 扩展的 REST 协议"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">vs 扩展的 REST 协议</span></span></h4><div class="notion-text notion-block-9b5c1dee8abf461f85b0cc6ab7187b8c">（此小节中图片拷贝自<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.howtographql.com/basics/1-graphql-is-th">网络</a>，懒得画）</div><div class="notion-text notion-block-9f3b0d45de334ab4bbd7ee7edf38e4ff">和 REST 一样，GraphQL 并不是什么开发框架，它只是定义了一种通用型查询的 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>。</div><div class="notion-text notion-block-9a384f67fe30477f978ff21b22e36de9">而使用 REST 协议进行资源拉取，我们总是会面临一些实际的问题，而 GraphQL 可以在一定程度上解决。那么肯定会有同学在想，REST 是非常灵活的，完全可以通过自建一个查询语法，弥补上述的 REST 缺陷，何必要另外引入 GraphQL 徒增复杂度呢。</div><div class="notion-text notion-block-016edec76cf34328ac821ba4bc4268e3">说的没错，所以我们在阐述这些问题的时候，也会附上我们当前基于 REST 的解决方案。</div><div class="notion-blank notion-block-9151f0fa7aa04512bd8567f9b597b835"> </div><div class="notion-text notion-block-86523c26bb6f4ca881988768cfd86c64"><b>Overfetching：</b></div><div class="notion-text notion-block-261e9041ab2347b7aa5f4f2ac4bf7283">假如我们定义了一个 <code class="notion-inline-code">/comments</code> 的 API，输出评论列表。以 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.django-rest-framework.org/">django-rest-framework</a> 为例，我们都会定义一个 <code class="notion-inline-code">Serializer</code> 来声明它的输入和输出。</div><pre class="notion-code language-python"><code class="language-python">from rest_framework <span class="token keyword">import</span> serializers

<span class="token keyword">class</span> <span class="token class-name">CommentSerializer</span><span class="token punctuation">(</span>serializers<span class="token punctuation">.</span>Serializer<span class="token punctuation">)</span><span class="token operator">:</span>
    email <span class="token operator">=</span> serializers<span class="token punctuation">.</span><span class="token function">EmailField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    content <span class="token operator">=</span> serializers<span class="token punctuation">.</span><span class="token function">CharField</span><span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span>
    logo <span class="token operator">=</span> serializer<span class="token punctuation">.</span><span class="token function">ImageField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">...</span><span class="token punctuation">(</span>省略数不清的字段<span class="token punctuation">)</span>
    created <span class="token operator">=</span> serializers<span class="token punctuation">.</span><span class="token function">DateTimeField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    ip_from <span class="token operator">=</span> serializers<span class="token punctuation">.</span><span class="token function">IPAddressField</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-9243ba0ad276413398efd52a86e73c76">看起来符合常理，它可以轻松满足大多数评论列表的需求。但是也许某一天，我们需要一个评论的精简列表的 API，当前返回内容中，除了 <code class="notion-inline-code">content</code> 以外的其他字段都变成多余了，那么后端开发需要重新定一个 <code class="notion-inline-code">MinimalCommentSerializer</code> 来满足新的需求。</div><div class="notion-text notion-block-c1041cb777b346d89717b6b8227d5719">在 REST 基础中，我们增加了 <code class="notion-inline-code">fields</code> 参数，并在 <code class="notion-inline-code">DRF Serializer</code> 里做了<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/TencentBlueKing/bk-user/blob/8c633e0a3821beb839ed120c4514c5733e675862/src/api/bkuser_core/common/viewset.py#L71">特殊处理（你可以点击查看源码）</a>，实现的具体效果：</div><pre class="notion-code language-json"><code class="language-json"># 查询 comment，并限制结果返回字段
<span class="token operator">/</span>api<span class="token operator">/</span>comments<span class="token operator">?</span>fields<span class="token operator">=</span>email<span class="token punctuation">,</span>content

# 返回
<span class="token punctuation">{</span>
  <span class="token string-property property">"results"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token string-property property">"email"</span><span class="token operator">:</span> <span class="token string">"foo@bar.com"</span><span class="token punctuation">,</span>
      <span class="token string-property property">"content"</span><span class="token operator">:</span> <span class="token string">"I love this blog, simple and good looking."</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-f597e7e436cb44f4940b946ac14191db">而如果我们使用 GraphQL，写法上会更自然：</div><pre class="notion-code language-graphql"><code class="language-graphql">query <span class="token punctuation">{</span>
  comment <span class="token punctuation">{</span>
    email
    content
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-73155088d28a4e6f8b82bf2551ad1a67"><b>Underfetching</b></div><div class="notion-text notion-block-5b93503e6e0c47fa8165bb452f67c8f3">相较于 Overfetching 是获取了过多数据，Underfetching 则是在请求获取的数据不足够满足需求。</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-76d7c8f902c246cba62dfd7a00b5c990"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:720px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7396e0b5-7539-4174-992e-c35a8076984e%2FUntitled.png?table=block&amp;id=76d7c8f9-02c2-46cb-a62d-fd7a00b5c990&amp;cache=v2" loading="lazy" alt="传统的 REST 协议" decoding="async"/><figcaption class="notion-asset-caption">传统的 REST 协议</figcaption></div></figure><div class="notion-text notion-block-f20ce9deab744d049c5c529571cf5b0a">假如我们需要获取所有用户维度的评论，我们需要先获取通过 <code class="notion-inline-code">/users</code> 所有用户 id，再使用 id 列表遍历查询 <code class="notion-inline-code">/users/&lt;id&gt;/comments</code> 来获取相关的列表。</div><div class="notion-text notion-block-664a1feb5c8f4030a77f313f8f2c05f0">在 REST 中，为了这个需求我们可能会额外为 <code class="notion-inline-code">/users</code> 增加一个参数 <code class="notion-inline-code">with_comments</code> </div><pre class="notion-code language-json"><code class="language-json"># 查询 users，并限制结果返回字段
<span class="token operator">/</span>api<span class="token operator">/</span>users<span class="token operator">?</span>with_comments<span class="token operator">=</span><span class="token number">1</span>

# 返回
<span class="token punctuation">{</span>
  <span class="token string-property property">"results"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token string-property property">"username"</span><span class="token operator">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span>
      <span class="token string-property property">"telephone"</span><span class="token operator">:</span> <span class="token string">"12345"</span><span class="token punctuation">,</span>
      <span class="token string-property property">"comments"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          <span class="token string-property property">"email"</span><span class="token operator">:</span> <span class="token string">"foo@bar.com"</span><span class="token punctuation">,</span>
          <span class="token string-property property">"content"</span><span class="token operator">:</span> <span class="token string">"I love this blog, simple and good looking."</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre><div class="notion-blank notion-block-d002648bd6984cb1ac8c6a0951653437"> </div><div class="notion-text notion-block-511e89a1906b47068da530351636a8ab">相较于自定义的 REST 协议，使用 GraphQL 可以更简单：</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-801be6ddb7bf4afd988363ef9ea359ea"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:624px;max-width:100%;flex-direction:column"><img style="object-fit:contain" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc730795a-8b87-497e-a6c8-38c4c29f310a%2FUntitled.png?table=block&amp;id=801be6dd-b7bf-4afd-9883-63ef9ea359ea&amp;cache=v2" loading="lazy" alt="使用 GraphQL，只需要一次请求" decoding="async"/><figcaption class="notion-asset-caption">使用 GraphQL，只需要一次请求</figcaption></div></figure><hr class="notion-hr notion-block-a7cc3850d7d34e9394559e3c484535a8"/><div class="notion-blank notion-block-ae2e1ab9de4445e9af25da3b4283ed30"> </div><div class="notion-text notion-block-e5388855af4c4978ab5d79d928a68fac">相信通过上面的例子，我们可以清晰地看出，相较于 GraphQL ，基于 REST 扩展协议存在这些问题：</div><ul class="notion-list notion-list-disc notion-block-0c2d157b66104281b7465d60c317263c"><li>不够通用，用户有额外的学习成本，增加了额外的文档负担。</li></ul><ul class="notion-list notion-list-disc notion-block-bf511966e9b04e6f9565a4435370aaf7"><li>基于 REST ，单个请求只能针对单个对象进行描述。需要等待需求沉淀，由后端主动封装，迭代节奏会更慢。</li></ul><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-3db8daa2fcb0409baa596fd5472b9ff3" data-id="3db8daa2fcb0409baa596fd5472b9ff3"><span><div id="3db8daa2fcb0409baa596fd5472b9ff3" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3db8daa2fcb0409baa596fd5472b9ff3" title="什么是 GraphQL 客户端?"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">什么是 GraphQL 客户端?</span></span></h3><div class="notion-text notion-block-b271423a2db348a9a08562e982457465">我们主要聚焦于 GraphQL 服务端提供，但是也需要先看一下所谓的客户端究竟做了什么。</div><div class="notion-text notion-block-e4ae6016eb264be39a05804c3bd07f25">简单来说，要想在原生 Javascript 中直接使用 GraphQL 并不是一件特别容易的事，需要一些库来协助拉取和管理 GraphQL 数据。</div><div class="notion-text notion-block-3114c568468f4b9cb5b95fe9120d51dd">相较于原生的 GraphQL ，客户端主要解决了几件事情：</div><ul class="notion-list notion-list-disc notion-block-2729ac7032e44245a0b78c928929cfda"><li>客户端数据拉取缓存问题（包括缓存一致性、更新缓存等）</li></ul><ul class="notion-list notion-list-disc notion-block-f3841eb2487b404d8002ecfebcd4e44b"><li>数据分页、声明式数据获取</li></ul><ul class="notion-list notion-list-disc notion-block-dd027b39a3d647529443d0b0220299df"><li>...</li></ul><div class="notion-text notion-block-5b0213aea8b443078ff3c6d9eb1455b5">主流的客户端框架主要有两种—— <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://relay.dev/">Relay</a> 和 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://www.apollographql.com/">Apollo</a> ，我们仅从有限的角度来看下二者的异同：</div><div class="notion-collection notion-block-79eac296c4544b138687c18a99776607"><div class="notion-collection-header" style="padding-left:96px;padding-right:96px"><div class="notion-collection-header-title">Relay vs Apollo</div></div><div class="notion-table" style="width:1024px;max-width:1024px"><div class="notion-table-view" style="padding-left:96px;padding-right:96px"><div class="notion-table-header"><div class="notion-table-header-inner"><div class="notion-table-th"><div class="notion-table-view-header-cell" style="width:232.66949462890625px"><div class="notion-table-view-header-cell-inner"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M7.74 8.697a.81.81 0 01.073.308.894.894 0 01-.9.888.867.867 0 01-.825-.592l-.333-.961H2.058l-.333.961a.882.882 0 01-.838.592A.884.884 0 010 9.005c0-.11.025-.222.062-.308l2.403-6.211c.222-.58.776-.986 1.442-.986.653 0 1.22.407 1.442.986l2.39 6.211zM2.6 6.824h2.613L3.907 3.102 2.6 6.824zm8.8-3.118c1.355 0 2.6.542 2.6 2.255V9.08a.8.8 0 01-.789.814.797.797 0 01-.788-.703c-.395.468-1.097.764-1.874.764-.949 0-2.07-.64-2.07-1.972 0-1.392 1.121-1.897 2.07-1.897.789 0 1.491.246 1.886.727v-.826c0-.604-.518-.998-1.306-.998-.469 0-.888.123-1.32.394a.64.64 0 01-.307.086.602.602 0 01-.592-.604c0-.221.123-.419.284-.517a3.963 3.963 0 012.206-.641zm-.222 5.188c.505 0 .998-.172 1.257-.517v-.74c-.259-.345-.752-.517-1.257-.517-.616 0-1.122.332-1.122.9 0 .554.506.874 1.122.874zM.656 11.125h12.688a.656.656 0 110 1.313H.656a.656.656 0 110-1.313z"></path></svg><div class="notion-collection-column-title-body"></div></div></div></div></div><div class="notion-table-th"><div class="notion-table-view-header-cell" style="width:232.66949462890625px"><div class="notion-table-view-header-cell-inner"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M7 4.568a.5.5 0 00-.5-.5h-6a.5.5 0 00-.5.5v1.046a.5.5 0 00.5.5h6a.5.5 0 00.5-.5V4.568zM.5 1a.5.5 0 00-.5.5v1.045a.5.5 0 00.5.5h12a.5.5 0 00.5-.5V1.5a.5.5 0 00-.5-.5H.5zM0 8.682a.5.5 0 00.5.5h11a.5.5 0 00.5-.5V7.636a.5.5 0 00-.5-.5H.5a.5.5 0 00-.5.5v1.046zm0 3.068a.5.5 0 00.5.5h9a.5.5 0 00.5-.5v-1.045a.5.5 0 00-.5-.5h-9a.5.5 0 00-.5.5v1.045z"></path></svg><div class="notion-collection-column-title-body">Relay</div></div></div></div></div><div class="notion-table-th"><div class="notion-table-view-header-cell" style="width:369.66949462890625px"><div class="notion-table-view-header-cell-inner"><div class="notion-collection-column-title"><svg viewBox="0 0 14 14" class="notion-collection-column-title-icon"><path d="M7 4.568a.5.5 0 00-.5-.5h-6a.5.5 0 00-.5.5v1.046a.5.5 0 00.5.5h6a.5.5 0 00.5-.5V4.568zM.5 1a.5.5 0 00-.5.5v1.045a.5.5 0 00.5.5h12a.5.5 0 00.5-.5V1.5a.5.5 0 00-.5-.5H.5zM0 8.682a.5.5 0 00.5.5h11a.5.5 0 00.5-.5V7.636a.5.5 0 00-.5-.5H.5a.5.5 0 00-.5.5v1.046zm0 3.068a.5.5 0 00.5.5h9a.5.5 0 00.5-.5v-1.045a.5.5 0 00-.5-.5h-9a.5.5 0 00-.5.5v1.045z"></path></svg><div class="notion-collection-column-title-body">Apollo</div></div></div></div></div></div></div><div class="notion-table-header-placeholder"></div><div class="notion-table-body"><div class="notion-table-row"><div class="notion-table-cell notion-table-cell-title" style="width:232.66949462890625px"><span class="notion-property notion-property-title"><a class="notion-page-link" href="https://www.notion.so/bc1b723e68814b8db570eaa51d4dd328"><span class="notion-page-title"><svg class="notion-page-title-icon notion-page-icon" alt="框架支持" viewBox="0 0 30 30" width="16"><path d="M16,1H4v28h22V11L16,1z M16,3.828L23.172,11H16V3.828z M24,27H6V3h8v10h10V27z M8,17h14v-2H8V17z M8,21h14v-2H8V21z M8,25h14v-2H8V25z"></path></svg><span class="notion-page-title-text">框架支持</span></span></a></span></div><div class="notion-table-cell notion-table-cell-text" style="width:232.66949462890625px"><span class="notion-property notion-property-text">仅支持 React, React Native</span></div><div class="notion-table-cell notion-table-cell-text" style="width:369.66949462890625px"><span class="notion-property notion-property-text">无框架限定</span></div></div><div class="notion-table-row"><div class="notion-table-cell notion-table-cell-title" style="width:232.66949462890625px"><span class="notion-property notion-property-title"><a class="notion-page-link" href="https://www.notion.so/574b8c14d70949388afad8250db9a9ee"><span class="notion-page-title"><svg class="notion-page-title-icon notion-page-icon" alt="GraphQL API" viewBox="0 0 30 30" width="16"><path d="M16,1H4v28h22V11L16,1z M16,3.828L23.172,11H16V3.828z M24,27H6V3h8v10h10V27z M8,17h14v-2H8V17z M8,21h14v-2H8V21z M8,25h14v-2H8V25z"></path></svg><span class="notion-page-title-text">GraphQL API</span></span></a></span></div><div class="notion-table-cell notion-table-cell-text" style="width:232.66949462890625px"><span class="notion-property notion-property-text">需要特定的 Schema 支持</span></div><div class="notion-table-cell notion-table-cell-text" style="width:369.66949462890625px"><span class="notion-property notion-property-text">无需特定的 Schema 支持</span></div></div><div class="notion-table-row"><div class="notion-table-cell notion-table-cell-title" style="width:232.66949462890625px"><span class="notion-property notion-property-title"><a class="notion-page-link" href="https://www.notion.so/c0029db1fe0c44948186e6eb55c57632"><span class="notion-page-title"><svg class="notion-page-title-icon notion-page-icon" alt="学习成本" viewBox="0 0 30 30" width="16"><path d="M16,1H4v28h22V11L16,1z M16,3.828L23.172,11H16V3.828z M24,27H6V3h8v10h10V27z M8,17h14v-2H8V17z M8,21h14v-2H8V21z M8,25h14v-2H8V25z"></path></svg><span class="notion-page-title-text">学习成本</span></span></a></span></div><div class="notion-table-cell notion-table-cell-text" style="width:232.66949462890625px"><span class="notion-property notion-property-text">较高</span></div><div class="notion-table-cell notion-table-cell-text" style="width:369.66949462890625px"><span class="notion-property notion-property-text">较低</span></div></div><div class="notion-table-row"><div class="notion-table-cell notion-table-cell-title" style="width:232.66949462890625px"><span class="notion-property notion-property-title"><a class="notion-page-link" href="https://www.notion.so/5cf89e43953a4289aef7334c7760d81a"><span class="notion-page-title"><svg class="notion-page-title-icon notion-page-icon" alt="生产力" viewBox="0 0 30 30" width="16"><path d="M16,1H4v28h22V11L16,1z M16,3.828L23.172,11H16V3.828z M24,27H6V3h8v10h10V27z M8,17h14v-2H8V17z M8,21h14v-2H8V21z M8,25h14v-2H8V25z"></path></svg><span class="notion-page-title-text">生产力</span></span></a></span></div><div class="notion-table-cell notion-table-cell-text" style="width:232.66949462890625px"><span class="notion-property notion-property-text">高</span></div><div class="notion-table-cell notion-table-cell-text" style="width:369.66949462890625px"><span class="notion-property notion-property-text">较低</span></div></div><div class="notion-table-row"><div class="notion-table-cell notion-table-cell-title" style="width:232.66949462890625px"><span class="notion-property notion-property-title"><a class="notion-page-link" href="https://www.notion.so/d710e6b7a1a2458493f3a4a06adc7f6e"><span class="notion-page-title"><svg class="notion-page-title-icon notion-page-icon" alt="灵活性" viewBox="0 0 30 30" width="16"><path d="M16,1H4v28h22V11L16,1z M16,3.828L23.172,11H16V3.828z M24,27H6V3h8v10h10V27z M8,17h14v-2H8V17z M8,21h14v-2H8V21z M8,25h14v-2H8V25z"></path></svg><span class="notion-page-title-text">灵活性</span></span></a></span></div><div class="notion-table-cell notion-table-cell-text" style="width:232.66949462890625px"><span class="notion-property notion-property-text">固定结构</span></div><div class="notion-table-cell notion-table-cell-text" style="width:369.66949462890625px"><span class="notion-property notion-property-text">较灵活</span></div></div><div class="notion-table-row"><div class="notion-table-cell notion-table-cell-title" style="width:232.66949462890625px"><span class="notion-property notion-property-title"><a class="notion-page-link" href="https://www.notion.so/4e0a6851a331441cbb68fd9b6fa17ffb"><span class="notion-page-title"><svg class="notion-page-title-icon notion-page-icon" alt="是否支持订阅" viewBox="0 0 30 30" width="16"><path d="M16,1H4v28h22V11L16,1z M16,3.828L23.172,11H16V3.828z M24,27H6V3h8v10h10V27z M8,17h14v-2H8V17z M8,21h14v-2H8V21z M8,25h14v-2H8V25z"></path></svg><span class="notion-page-title-text">是否支持订阅</span></span></a></span></div><div class="notion-table-cell notion-table-cell-text" style="width:232.66949462890625px"><span class="notion-property notion-property-text">否</span></div><div class="notion-table-cell notion-table-cell-text" style="width:369.66949462890625px"><span class="notion-property notion-property-text">是</span></div></div></div></div></div></div><div class="notion-text notion-block-25bbafb30a124becb56e2e541cd779e4">简而言之，Realy 更复杂，更能够应对大型应用，Apollo 更轻量，不过需要更多的手工劳动。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-499a5d133c9b493e946a692b0e21a062" data-id="499a5d133c9b493e946a692b0e21a062"><span><div id="499a5d133c9b493e946a692b0e21a062" class="notion-header-anchor"></div><a class="notion-hash-link" href="#499a5d133c9b493e946a692b0e21a062" title="服务端落地：GraphQL → Django"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">服务端落地：GraphQL → Django</span></span></h3><div class="notion-text notion-block-d82aba35a7ee4c7e896c4366b1d5ec5e">想要将 GraphQL 引入现有的项目，我们需要安装两个基础的依赖：</div><ul class="notion-list notion-list-disc notion-block-850425fb270440e89da6348449515cbf"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/graphql-python/graphene-django">graphene-django</a> </li></ul><ul class="notion-list notion-list-disc notion-block-06516dcbe6bf497184297351f2d2b55c"><li><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/carltongibson/django-filter">django-filter</a></li></ul><div class="notion-text notion-block-7f566dd96e93421b9e7552ca098c92db">二者分别负责两部分的工作：</div><ul class="notion-list notion-list-disc notion-block-269531b02e9c47c88da2441c19e7ccc0"><li>Django Model ⇒  Schema</li></ul><ul class="notion-list notion-list-disc notion-block-17baeebedf8c4e94a698faf2a0dfebd4"><li>Query  ⇒  Filter Django Model </li></ul><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-8c904f70489a4268a7b5c8f4ca2d51e6" data-id="8c904f70489a4268a7b5c8f4ca2d51e6"><span><div id="8c904f70489a4268a7b5c8f4ca2d51e6" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8c904f70489a4268a7b5c8f4ca2d51e6" title="支持 Relay"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">支持 Relay</span></span></h4><div class="notion-text notion-block-e80c823d66984b70aef628752f33c177">graphene-django 本身 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://docs.graphene-python.org/projects/django/en/latest/tutorial-relay/">默认支持 Relay</a>，所以你可以很容易地开启</div><pre class="notion-code language-python"><code class="language-python">from graphene <span class="token keyword">import</span> relay
from graphene_django <span class="token keyword">import</span> DjangoObjectType
from ingredients<span class="token punctuation">.</span>models <span class="token keyword">import</span> Category

# Graphene will automatically map the Category model's fields onto the CategoryNode<span class="token punctuation">.</span>
# This is configured <span class="token keyword">in</span> the CategoryNode's Meta <span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token keyword">as</span> you can see below<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">CategoryNode</span><span class="token punctuation">(</span>DjangoObjectType<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token operator">:</span>
        model <span class="token operator">=</span> Category
        filter_fields <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'ingredients'</span><span class="token punctuation">]</span>
        interfaces <span class="token operator">=</span> <span class="token punctuation">(</span>relay<span class="token punctuation">.</span>Node<span class="token punctuation">,</span> <span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-eecb673cd4084d57ad0a511380cd6b28">不过很多时候考虑到 Relay 的复杂度，有时都不适合引入，更何况 Relay 需要特殊的 Schema 支持：</div><div class="notion-row notion-block-419c60d4a1a84f0ba4d39bb116e55b71"><div class="notion-column notion-block-63a72f800f3946378539183410ea26ba" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><pre class="notion-code language-graphql"><code class="language-graphql">query <span class="token punctuation">{</span>
  allIngredients <span class="token punctuation">{</span>
    edges <span class="token punctuation">{</span>
      node <span class="token punctuation">{</span>
        id<span class="token punctuation">,</span>
        name
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><figcaption class="notion-asset-caption">Relay Schema：edges、node 层级同样会出现在返回值</figcaption></div><div class="notion-spacer"></div><div class="notion-column notion-block-5c0491f03bc64f83aea39c6375e5f19d" style="width:calc((100% - (1 * min(32px, 4vw))) * 0.5)"><pre class="notion-code language-graphql"><code class="language-graphql">query <span class="token punctuation">{</span>
  allIngredients <span class="token punctuation">{</span>
    id
    name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>



</code></pre><figcaption class="notion-asset-caption">原生 Schema： 明显更自然、简洁</figcaption></div><div class="notion-spacer"></div></div><div class="notion-text notion-block-25b4916ef4774955a012fbc141f700eb">这时候 graphene-django 就存在一个问题，当不使用 Relay 时，存在一些功能缺失：</div><ul class="notion-list notion-list-disc notion-block-ded5b120c51d4b1b8132a268a7d6b3f9"><li>Fragment \ Directives </li></ul><ul class="notion-list notion-list-disc notion-block-c75d9e445c274d5da510af554f9830a5"><li>分页、过滤</li></ul><ul class="notion-list notion-list-disc notion-block-33259eba02144fa9acda4e3e1eaf90ec"><li>通过 DRF Serializer 定义 Mutations</li></ul><div class="notion-text notion-block-21b3d48f64384238aad0c4a13b125c0f">所以我们需要引入额外的库来解决。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-3d929743493649a6a43da55924cdfa5e" data-id="3d929743493649a6a43da55924cdfa5e"><span><div id="3d929743493649a6a43da55924cdfa5e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3d929743493649a6a43da55924cdfa5e" title="引入 graphene-django-extras"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">引入 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/eamigo86/graphene-django-extras">graphene-django-extras</a></span></span></h4><pre class="notion-code language-python"><code class="language-python">from graphene <span class="token keyword">import</span> ObjectType
from graphene_django_extras <span class="token keyword">import</span> DjangoListObjectField<span class="token punctuation">,</span> DjangoListObjectType
from graphene_django_extras<span class="token punctuation">.</span>paginations <span class="token keyword">import</span> LimitOffsetGraphqlPagination

<span class="token keyword">class</span> <span class="token class-name">CommentListType</span><span class="token punctuation">(</span>DjangoListObjectType<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token operator">:</span>
        model <span class="token operator">=</span> Comment
        fields <span class="token operator">=</span> <span class="token string">"__all__"</span>
        pagination <span class="token operator">=</span> <span class="token function">LimitOffsetGraphqlPagination</span><span class="token punctuation">(</span>default_limit<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">,</span> ordering<span class="token operator">=</span><span class="token string">"-id"</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Query</span><span class="token punctuation">(</span>ObjectType<span class="token punctuation">)</span><span class="token operator">:</span>
    comments <span class="token operator">=</span> <span class="token function">DjangoListObjectField</span><span class="token punctuation">(</span>CommentListType<span class="token punctuation">,</span> description<span class="token operator">=</span><span class="token string">"Query all comments"</span><span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-7b3762d8e2ad445e9c38eac7bedd68e5"><b>支持复杂过滤查询</b></div><div class="notion-text notion-block-6ebe03413a0040f4b7b5295e3b67a824">可以在列表对象中增加 <code class="notion-inline-code">filter_fields</code> ，针对不同的字段支持不同的 Django 复杂查询方法。</div><pre class="notion-code language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CommentListType</span><span class="token punctuation">(</span>DjangoListObjectType<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token operator">:</span>
        model <span class="token operator">=</span> Comment
        filter_fields <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token string-property property">"id"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"exact"</span><span class="token punctuation">,</span> <span class="token string">"in"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token string-property property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"exact"</span><span class="token punctuation">,</span> <span class="token string">"icontains"</span><span class="token punctuation">,</span> <span class="token string">"istartswith"</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
        pagination <span class="token operator">=</span> <span class="token function">LimitOffsetGraphqlPagination</span><span class="token punctuation">(</span>default_limit<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">,</span> ordering<span class="token operator">=</span><span class="token string">"-username"</span><span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-c71e31a767824aff9b82ee53004c179c">这样就可以将一些 Django 的查询能力释放到前端</div><pre class="notion-code language-graphql"><code class="language-graphql">query <span class="token punctuation">{</span>
  <span class="token function">comments</span><span class="token punctuation">(</span>id__In<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> content_Icontains<span class="token operator">:</span> <span class="token string">"Amazing"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    totalCount
    <span class="token function">results</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">limit</span><span class="token operator">:</span> <span class="token number">10</span> <span class="token literal-property property">offset</span><span class="token operator">:</span> <span class="token number">0</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      id
      email
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre><div class="notion-text notion-block-208020ce25114ee2a60d8b07df687d43"><b>自定义查询字段</b></div><div class="notion-text notion-block-fa290cc6855049289a6df8b9537c6cf3">Django 默认的查询能力，对于一些特殊字段并不能完全覆盖需求，这时我们就需要针对这些内容手写一些处理逻辑。</div><pre class="notion-code language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Query</span><span class="token punctuation">(</span>ObjectType<span class="token punctuation">)</span><span class="token operator">:</span>
    user <span class="token operator">=</span> <span class="token function">Field</span><span class="token punctuation">(</span>UserType<span class="token punctuation">,</span> description<span class="token operator">=</span><span class="token string">"Retrieve certain user"</span><span class="token punctuation">,</span> id<span class="token operator">=</span><span class="token function">Int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> username<span class="token operator">=</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

		def <span class="token function">resolve_user</span><span class="token punctuation">(</span>
        self<span class="token punctuation">,</span> <span class="token literal-property property">context</span><span class="token operator">:</span> <span class="token string">"GraphQLResolveInfo"</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span> Optional<span class="token punctuation">[</span>int<span class="token punctuation">]</span> <span class="token operator">=</span> None<span class="token punctuation">,</span> <span class="token literal-property property">username</span><span class="token operator">:</span> Optional<span class="token punctuation">[</span>str<span class="token punctuation">]</span> <span class="token operator">=</span> None
    <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> User<span class="token operator">:</span>
        <span class="token keyword">if</span> id is not None<span class="token operator">:</span>
            <span class="token keyword">return</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pk<span class="token operator">=</span>id<span class="token punctuation">)</span>

        <span class="token keyword">if</span> username is None<span class="token operator">:</span>
            raise <span class="token function">ValueError</span><span class="token punctuation">(</span><span class="token string">"username or pk at least one is required"</span><span class="token punctuation">)</span>

        # <span class="token keyword">do</span> some custom logic
        <span class="token operator">...</span>

        <span class="token keyword">return</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>username<span class="token operator">=</span>username<span class="token punctuation">)</span></code></pre><div class="notion-text notion-block-cce7dff50ba44dffa5f85844bfdcf91b">需要注意的是，当我们使用 <code class="notion-inline-code">resolve_</code> 函数去处理查询时，GraphQL 和 REST 本质上只是查询 DSL 有所区别，都会遇到类似像 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping">N+1</a> 这样的慢查询问题，所以需要谨慎地将前端的查询转换成可靠的 Django ORM 查询。</div><h4 class="notion-h notion-h3 notion-h-indent-1 notion-block-0068853173e54e1bacc12aa21d51205d" data-id="0068853173e54e1bacc12aa21d51205d"><span><div id="0068853173e54e1bacc12aa21d51205d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#0068853173e54e1bacc12aa21d51205d" title="鉴权"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">鉴权</span></span></h4><div class="notion-text notion-block-41b09c496df54886b6b685e8f38fb9c5">由于 API 请求并不再经过传统封装的 ViewSet，原有的鉴权组件不再能使用，你需要引入新的 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/redzej/graphene-permissions">graphene-permissions</a> 来解决针对用户的权限控制。</div><div class="notion-text notion-block-486546d75ed744b48491c065b47b6915">本文成文时，graphene-permissions 对于最新的 Graphene 3.x 有一些<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://github.com/redzej/graphene-permissions/pull/36">小的兼容性问题</a>，由于该库代码量非常小，可以考虑复制到自己的项目手动维护。</div><pre class="notion-code language-python"><code class="language-python">from <span class="token punctuation">.</span>mixins <span class="token keyword">import</span> AuthNode
from <span class="token punctuation">.</span>permissions <span class="token keyword">import</span> AllowSuperuser

<span class="token keyword">class</span> <span class="token class-name">UserNode</span><span class="token punctuation">(</span>AuthNode<span class="token punctuation">,</span> DjangoObjectType<span class="token punctuation">)</span><span class="token operator">:</span>
    permission_classes <span class="token operator">=</span> <span class="token punctuation">(</span>AllowAuthenticated<span class="token punctuation">,</span><span class="token punctuation">)</span>

    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token operator">:</span>
        model <span class="token operator">=</span> User
        filter_fields <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span><span class="token punctuation">)</span>
        interfaces <span class="token operator">=</span> <span class="token punctuation">(</span>relay<span class="token punctuation">.</span>Node<span class="token punctuation">,</span><span class="token punctuation">)</span></code></pre><div class="notion-blank notion-block-3a7758ed778747038fbc0b83f8c7ec6e"> </div><div class="notion-text notion-block-212d68c0638c45c1a66570938e3eb1c7">尴尬的是，如果你并不想用 Relay，我们需要针对 graphene-django-extras 做一些自己的定制，而原有的封装没有很好地暴露足够的接口，经过一番探索并无头绪，最终作罢🥴。</div><h3 class="notion-h notion-h2 notion-h-indent-0 notion-block-10f53459be3844c7a1355a1ed5bd63b9" data-id="10f53459be3844c7a1355a1ed5bd63b9"><span><div id="10f53459be3844c7a1355a1ed5bd63b9" class="notion-header-anchor"></div><a class="notion-hash-link" href="#10f53459be3844c7a1355a1ed5bd63b9" title="总结"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">总结</span></span></h3><ul class="notion-list notion-list-disc notion-block-9d67626a1d9641cd90f5af2e20aa6bc9"><li>GraphQL 在前端需求迭代频繁的场景下，比 REST 更符合现代开发节奏</li></ul><ul class="notion-list notion-list-disc notion-block-9f6415435fd9484fbc2ce5c4d2770bfe"><li>GraphQL 的语言设计比自定义扩展的 REST 更自然，更具备通用性</li></ul><ul class="notion-list notion-list-disc notion-block-2448995dbf5046fb8d4cf720a8a4991a"><li>GraphQL 会将比较多的工作放到客户端，适合成熟的客户端开发团队，反之 REST 是更好的选择</li></ul><ul class="notion-list notion-list-disc notion-block-df526e5ca78840c8a0cf8355e37cf7bf"><li>Django 相关的生态建设并不完善，没有一个足够强大、开箱即用的整合方案</li></ul><ul class="notion-list notion-list-disc notion-block-f819d57fbe4b469683400d4b084480c1"><li>由于查询并不是基于 Uri 维度，会给周边配套的生态—— 监控、日志等 ——带来一些新的挑战</li></ul><div class="notion-blank notion-block-ddaf5c2480f746f791a762c4707709f5"> </div></main>]]></content:encoded>
        </item>
    </channel>
</rss>